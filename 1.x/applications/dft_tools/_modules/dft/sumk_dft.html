<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>dft.sumk_dft &mdash; TRIQS DFTTools 1.4.0 documentation</title>
    
    <link rel="stylesheet" href="../../_static/triqs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '1.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/MathJax/MathJax.js?config=default"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="TRIQS DFTTools 1.4.0 documentation" href="../../contents.html" />
    <link rel="up" title="Module code" href="../index.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    
    <li><a href="../../install.html">Install</a></li>
    
    <li><a href="../../documentation.html">Documentation</a></li>
    
    <li><a href="../../issues.html">Issues</a></li>
    
    <li><a href="../../about.html">About DFTTools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../../index.html">dft tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://triqs.github.io/1.x">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for dft.sumk_dft</h1><div class="highlight"><pre>

<span class="c">##########################################################################</span>
<span class="c">#</span>
<span class="c"># TRIQS: a Toolbox for Research in Interacting Quantum Systems</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2011 by M. Aichhorn, L. Pourovskii, V. Vildosola</span>
<span class="c">#</span>
<span class="c"># TRIQS is free software: you can redistribute it and/or modify it under the</span>
<span class="c"># terms of the GNU General Public License as published by the Free Software</span>
<span class="c"># Foundation, either version 3 of the License, or (at your option) any later</span>
<span class="c"># version.</span>
<span class="c">#</span>
<span class="c"># TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="c"># WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c"># details.</span>
<span class="c">#</span>
<span class="c"># You should have received a copy of the GNU General Public License along with</span>
<span class="c"># TRIQS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c">#</span>
<span class="c">##########################################################################</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">pytriqs.utility.dichotomy</span> <span class="kn">as</span> <span class="nn">dichotomy</span>
<span class="kn">from</span> <span class="nn">pytriqs.gf.local</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pytriqs.utility.mpi</span> <span class="kn">as</span> <span class="nn">mpi</span>
<span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">symmetry</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">block_structure</span> <span class="kn">import</span> <span class="n">BlockStructure</span>
<span class="kn">from</span> <span class="nn">sets</span> <span class="kn">import</span> <span class="n">Set</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>


<div class="viewcode-block" id="SumkDFT"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT">[docs]</a><span class="k">class</span> <span class="nc">SumkDFT</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class provides a general SumK method for combining ab-initio code and pytriqs.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SumkDFT.__init__"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf_file</span><span class="p">,</span> <span class="n">h_field</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">use_dft_blocks</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">dft_data</span><span class="o">=</span><span class="s">&#39;dft_input&#39;</span><span class="p">,</span> <span class="n">symmcorr_data</span><span class="o">=</span><span class="s">&#39;dft_symmcorr_input&#39;</span><span class="p">,</span> <span class="n">parproj_data</span><span class="o">=</span><span class="s">&#39;dft_parproj_input&#39;</span><span class="p">,</span>
                 <span class="n">symmpar_data</span><span class="o">=</span><span class="s">&#39;dft_symmpar_input&#39;</span><span class="p">,</span> <span class="n">bands_data</span><span class="o">=</span><span class="s">&#39;dft_bands_input&#39;</span><span class="p">,</span> <span class="n">transp_data</span><span class="o">=</span><span class="s">&#39;dft_transp_input&#39;</span><span class="p">,</span>
                 <span class="n">misc_data</span><span class="o">=</span><span class="s">&#39;dft_misc_input&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Initialises the class from data previously stored into an hdf5 archive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hdf_file : string</span>
<span class="sd">                   Name of hdf5 containing the data.</span>
<span class="sd">        h_field : scalar, optional</span>
<span class="sd">                  The value of magnetic field to add to the DFT Hamiltonian. </span>
<span class="sd">                  The contribution -h_field*sigma is added to diagonal elements of the Hamiltonian.</span>
<span class="sd">                  It cannot be used with the spin-orbit coupling on; namely h_field is set to 0 if self.SO=True.</span>
<span class="sd">        use_dft_blocks : boolean, optional</span>
<span class="sd">                         If True, the local Green&#39;s function matrix for each spin is divided into smaller blocks </span>
<span class="sd">                          with the block structure determined from the DFT density matrix of the corresponding correlated shell.</span>

<span class="sd">                         Alternatively and additionally, the block structure can be analyzed using :meth:`analyse_block_structure &lt;dft.sumk_dft.SumkDFT.analyse_block_structure&gt;`</span>
<span class="sd">                         and manipulated using the SumkDFT.block_structre attribute (see :class:`BlockStructure &lt;dft.block_structure.BlockStructure&gt;`).</span>
<span class="sd">        dft_data : string, optional</span>
<span class="sd">                   Name of hdf5 subgroup in which DFT data for projector and lattice Green&#39;s function construction are stored.</span>
<span class="sd">        symmcorr_data : string, optional</span>
<span class="sd">                        Name of hdf5 subgroup in which DFT data on symmetries of correlated shells </span>
<span class="sd">                        (symmetry operations, permutaion matrices etc.) are stored.</span>
<span class="sd">        parproj_data : string, optional</span>
<span class="sd">                       Name of hdf5 subgroup in which DFT data on non-normalized projectors for non-correlated</span>
<span class="sd">                       states (used in the partial density of states calculations) are stored.</span>
<span class="sd">        symmpar_data : string, optional</span>
<span class="sd">                       Name of hdf5 subgroup in which DFT data on symmetries of the non-normalized projectors</span>
<span class="sd">                       are stored.</span>
<span class="sd">        bands_data : string, optional</span>
<span class="sd">                     Name of hdf5 subgroup in which DFT data necessary for band-structure/k-resolved spectral</span>
<span class="sd">                     function calculations (projectors, DFT Hamiltonian for a chosen path in the Brillouin zone etc.)</span>
<span class="sd">                     are stored.</span>
<span class="sd">        transp_data : string, optional</span>
<span class="sd">                      Name of hdf5 subgroup in which DFT data necessary for transport calculations are stored.</span>
<span class="sd">        misc_data : string, optional</span>
<span class="sd">                    Name of hdf5 subgroup in which miscellaneous DFT data are stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">hdf_file</span><span class="p">)</span> <span class="o">==</span> <span class="n">StringType</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;Give a string for the hdf5 filename to read the input!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span> <span class="o">=</span> <span class="n">hdf_file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span> <span class="o">=</span> <span class="n">dft_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span> <span class="o">=</span> <span class="n">symmcorr_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parproj_data</span> <span class="o">=</span> <span class="n">parproj_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmpar_data</span> <span class="o">=</span> <span class="n">symmpar_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands_data</span> <span class="o">=</span> <span class="n">bands_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transp_data</span> <span class="o">=</span> <span class="n">transp_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">misc_data</span> <span class="o">=</span> <span class="n">misc_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">=</span> <span class="n">h_field</span>

            <span class="c"># Read input from HDF:</span>
            <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;energy_unit&#39;</span><span class="p">,</span> <span class="s">&#39;n_k&#39;</span><span class="p">,</span> <span class="s">&#39;k_dep_projection&#39;</span><span class="p">,</span> <span class="s">&#39;SP&#39;</span><span class="p">,</span> <span class="s">&#39;SO&#39;</span><span class="p">,</span> <span class="s">&#39;charge_below&#39;</span><span class="p">,</span> <span class="s">&#39;density_required&#39;</span><span class="p">,</span>
                              <span class="s">&#39;symm_op&#39;</span><span class="p">,</span> <span class="s">&#39;n_shells&#39;</span><span class="p">,</span> <span class="s">&#39;shells&#39;</span><span class="p">,</span> <span class="s">&#39;n_corr_shells&#39;</span><span class="p">,</span> <span class="s">&#39;corr_shells&#39;</span><span class="p">,</span> <span class="s">&#39;use_rotations&#39;</span><span class="p">,</span> <span class="s">&#39;rot_mat&#39;</span><span class="p">,</span>
                              <span class="s">&#39;rot_mat_time_inv&#39;</span><span class="p">,</span> <span class="s">&#39;n_reps&#39;</span><span class="p">,</span> <span class="s">&#39;dim_reps&#39;</span><span class="p">,</span> <span class="s">&#39;T&#39;</span><span class="p">,</span> <span class="s">&#39;n_orbitals&#39;</span><span class="p">,</span> <span class="s">&#39;proj_mat&#39;</span><span class="p">,</span> <span class="s">&#39;bz_weights&#39;</span><span class="p">,</span> <span class="s">&#39;hopping&#39;</span><span class="p">,</span>
                              <span class="s">&#39;n_inequiv_shells&#39;</span><span class="p">,</span> <span class="s">&#39;corr_to_inequiv&#39;</span><span class="p">,</span> <span class="s">&#39;inequiv_to_corr&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subgroup_present</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
                <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span> <span class="o">=</span> <span class="n">Symmetry</span><span class="p">(</span><span class="n">hdf_file</span><span class="p">,</span> <span class="n">subgroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_field</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.000001</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s">&quot;For SO, the external magnetic field is not implemented, setting it to 0!&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span> <span class="o">=</span> <span class="p">[[</span><span class="s">&#39;up&#39;</span><span class="p">,</span> <span class="s">&#39;down&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s">&#39;ud&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c"># Convert spin_block_names to indices -- if spin polarized,</span>
            <span class="c"># differentiate up and down blocks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{}]</span>
            <span class="k">for</span> <span class="n">iso</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c"># SO = 0 or 1</span>
                <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="n">iso</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="n">iso</span><span class="p">][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="n">iso</span><span class="p">][</span><span class="n">isp</span><span class="p">]]</span> <span class="o">=</span> <span class="n">isp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span> <span class="o">=</span> <span class="n">BlockStructure</span><span class="p">()</span>

            <span class="c"># GF structure used for the local things in the k sums</span>
            <span class="c"># Most general form allowing for all hybridisation, i.e. largest</span>
            <span class="c"># blocks possible</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]]</span>
                                   <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="c"># First set a standard gf_struct solver:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">([(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s">&#39;dim&#39;</span><span class="p">]))</span>
                                           <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s">&#39;SO&#39;</span><span class="p">]]])</span>
                                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="c"># Set standard (identity) maps from gf_struct_sumk &lt;-&gt;</span>
            <span class="c"># gf_struct_solver</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="p">[{}</span>
                                         <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
                    <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">inner_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span>
            <span class="c"># assume no shells are degenerate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c"># initialise mu</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_dc</span><span class="p">()</span>  <span class="c"># initialise the double counting</span>

            <span class="c"># Analyse the block structure and determine the smallest gf_struct</span>
            <span class="c"># blocks and maps, if desired</span>
            <span class="k">if</span> <span class="n">use_dft_blocks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analyse_block_structure</span><span class="p">()</span></div>

<span class="c">################</span>
<span class="c"># hdf5 FUNCTIONS</span>
<span class="c">################</span>

<div class="viewcode-block" id="SumkDFT.read_input_from_hdf"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.read_input_from_hdf">[docs]</a>    <span class="k">def</span> <span class="nf">read_input_from_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgrp</span><span class="p">,</span> <span class="n">things_to_read</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Reads data from the HDF file. Prints a warning if a requested dataset is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subgrp : string</span>
<span class="sd">                 Name of hdf5 file subgroup from which the data are to be read.</span>
<span class="sd">        things_to_read : list of strings</span>
<span class="sd">                         List of datasets to be read from the hdf5 file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subgroup_present : boolean</span>
<span class="sd">                           Is the subgrp is present in hdf5 file?</span>
<span class="sd">        value_read : boolean</span>
<span class="sd">                     Did the reading of requested datasets succeed?</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c"># initialise variables on all nodes to ensure mpi broadcast works at</span>
        <span class="c"># the end</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">subgroup_present</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
                <span class="n">subgroup_present</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="c"># first read the necessary things:</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">]:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;Loading </span><span class="si">%s</span><span class="s"> failed!&quot;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span>
                        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">things_to_read</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                        <span class="s">&quot;Loading failed: No </span><span class="si">%s</span><span class="s"> subgroup in hdf5!&quot;</span> <span class="o">%</span> <span class="n">subgrp</span><span class="p">)</span>
                <span class="n">subgroup_present</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">value_read</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">del</span> <span class="n">ar</span>
        <span class="c"># now do the broadcasting:</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)))</span>
        <span class="n">subgroup_present</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">subgroup_present</span><span class="p">)</span>
        <span class="n">value_read</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">value_read</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">subgroup_present</span><span class="p">,</span> <span class="n">value_read</span></div>

<div class="viewcode-block" id="SumkDFT.save"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">things_to_save</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s">&#39;user_data&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Saves data from a list into the HDF file. Prints a warning if a requested data is not found in SumkDFT object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        things_to_save : list of strings</span>
<span class="sd">                         List of datasets to be saved into the hdf5 file.</span>
<span class="sd">        subgrp : string, optional</span>
<span class="sd">                 Name of hdf5 file subgroup in which the data are to be stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>  <span class="c"># do nothing on nodes</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s">&#39;a&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
            <span class="n">ar</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="p">[</span> <span class="s">&quot;gf_struct_sumk&quot;</span><span class="p">,</span> <span class="s">&quot;gf_struct_solver&quot;</span><span class="p">,</span>
                    <span class="s">&quot;solver_to_sumk&quot;</span><span class="p">,</span> <span class="s">&quot;sumk_to_solver&quot;</span><span class="p">,</span> <span class="s">&quot;solver_to_sumk_block&quot;</span><span class="p">]:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s">&quot;It is not recommended to save &#39;{}&#39; individually. Save &#39;block_structure&#39; instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s"> not found, and so not saved.&quot;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ar</span></div>

<div class="viewcode-block" id="SumkDFT.load"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">things_to_load</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s">&#39;user_data&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Loads user data from the HDF file. Raises an exeption if a requested dataset is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        things_to_read : list of strings</span>
<span class="sd">                         List of datasets to be read from the hdf5 file.</span>
<span class="sd">        subgrp : string, optional</span>
<span class="sd">                 Name of hdf5 file subgroup from which the data are to be read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list_to_return : list</span>
<span class="sd">                         A list containing data read from hdf5.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>  <span class="c"># do nothing on nodes</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;Loading </span><span class="si">%s</span><span class="s"> failed!&quot;</span> <span class="o">%</span> <span class="n">subgrp</span><span class="p">)</span>
        <span class="n">list_to_return</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_load</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">list_to_return</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;load: </span><span class="si">%s</span><span class="s"> not found, and so not loaded.&quot;</span> <span class="o">%</span> <span class="n">it</span>
        <span class="k">del</span> <span class="n">ar</span>
        <span class="k">return</span> <span class="n">list_to_return</span></div>

<span class="c">################</span>
<span class="c"># CORE FUNCTIONS</span>
<span class="c">################</span>

<div class="viewcode-block" id="SumkDFT.downfold"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.downfold">[docs]</a>    <span class="k">def</span> <span class="nf">downfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf_to_downfold</span><span class="p">,</span> <span class="n">gf_inp</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s">&#39;corr&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Downfolds a block of the Green&#39;s function for a given shell and k-point using the corresponding projector matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index for which the downfolding is to be done.</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be downfolded.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        bname : string</span>
<span class="sd">                Block name of the target block of the lattice Green&#39;s function.</span>
<span class="sd">        gf_to_downfold : Gf </span>
<span class="sd">                       Block of the Green&#39;s function that is to be downfolded.</span>
<span class="sd">        gf_inp : Gf </span>
<span class="sd">                 FIXME </span>
<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: orthonormalized projectors for correlated shells are used for the downfolding.</span>
<span class="sd">                 - if shells=&#39;all&#39;: non-normalized projectors for all included shells are used for the downfolding.</span>

<span class="sd">        ir : integer, optional</span>
<span class="sd">             Index of equivalent site in the non-correlated shell &#39;ish&#39;, only used if shells=&#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_downfolded : Gf</span>
<span class="sd">                      Downfolded block of the lattice Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf_downfolded</span> <span class="o">=</span> <span class="n">gf_inp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># get spin index for proj. matrices</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ir</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;downfold: provide ir if treating all shells.&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_all</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>

        <span class="n">gf_downfolded</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span>
            <span class="n">projmat</span><span class="p">,</span> <span class="n">gf_to_downfold</span><span class="p">,</span> <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">gf_downfolded</span></div>

<div class="viewcode-block" id="SumkDFT.upfold"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.upfold">[docs]</a>    <span class="k">def</span> <span class="nf">upfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf_to_upfold</span><span class="p">,</span> <span class="n">gf_inp</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s">&#39;corr&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Upfolds a block of the Green&#39;s function for a given shell and k-point using the corresponding projector matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index for which the upfolding is to be done.</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be upfolded.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        bname : string</span>
<span class="sd">                Block name of the target block of the lattice Green&#39;s function.</span>
<span class="sd">        gf_to_upfold : Gf </span>
<span class="sd">                       Block of the Green&#39;s function that is to be upfolded.</span>
<span class="sd">        gf_inp : Gf </span>
<span class="sd">                 FIXME </span>
<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: orthonormalized projectors for correlated shells are used for the upfolding.</span>
<span class="sd">                 - if shells=&#39;all&#39;: non-normalized projectors for all included shells are used for the upfolding.</span>

<span class="sd">        ir : integer, optional</span>
<span class="sd">             Index of equivalent site in the non-correlated shell &#39;ish&#39;, only used if shells=&#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_upfolded : Gf</span>
<span class="sd">                      Upfolded block of the lattice Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf_upfolded</span> <span class="o">=</span> <span class="n">gf_inp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c"># get spin index for proj. matrices</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ir</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;upfold: provide ir if treating all shells.&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_all</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>

        <span class="n">gf_upfolded</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span>
            <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_to_upfold</span><span class="p">,</span> <span class="n">projmat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gf_upfolded</span></div>

<div class="viewcode-block" id="SumkDFT.rotloc"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.rotloc">[docs]</a>    <span class="k">def</span> <span class="nf">rotloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">gf_to_rotate</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s">&#39;corr&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Rotates a block of the local Green&#39;s function from the local frame to the global frame and vice versa.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be rotated.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        gf_to_rotate : Gf </span>
<span class="sd">                       Block of the Green&#39;s function that is to be rotated.</span>
<span class="sd">        direction : string</span>
<span class="sd">                    The direction of rotation can be either </span>

<span class="sd">                    - &#39;toLocal&#39; : global -&gt; local transformation,</span>
<span class="sd">                    - &#39;toGlobal&#39; : local -&gt; global transformation.</span>

<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: the rotation matrix for the correlated shell &#39;ish&#39; is used,</span>
<span class="sd">                 - if shells=&#39;all&#39;: the rotation matrix for the generic (non-correlated) shell &#39;ish&#39; is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_rotated : Gf</span>
<span class="sd">                     Rotated block of the local Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">((</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;toLocal&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;toGlobal&#39;</span><span class="p">)</span>
                <span class="p">),</span> <span class="s">&quot;rotloc: Give direction &#39;toLocal&#39; or &#39;toGlobal&#39;.&quot;</span>
        <span class="n">gf_rotated</span> <span class="o">=</span> <span class="n">gf_to_rotate</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">rot_mat_time_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">rot_mat_time_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_all_time_inv</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_all</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;toGlobal&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">:</span>
                <span class="n">gf_rotated</span> <span class="o">&lt;&lt;</span> <span class="n">gf_rotated</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                <span class="p">),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span>
                                      <span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s">&#39;toLocal&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">:</span>
                <span class="n">gf_rotated</span> <span class="o">&lt;&lt;</span> <span class="n">gf_rotated</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="p">),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">gf_rotated</span></div>

<div class="viewcode-block" id="SumkDFT.lattice_gf"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.lattice_gf">[docs]</a>    <span class="k">def</span> <span class="nf">lattice_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&quot;iw&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the lattice Green function for a given k-point from the DFT Hamiltonian and the self energy. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index.</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">             Chemical potential for which the Green&#39;s function is to be calculated.</span>
<span class="sd">             If not provided, self.chemical_potential is used for mu.</span>
<span class="sd">        iw_or_w : string, optional</span>

<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>

<span class="sd">        beta : real, optional</span>
<span class="sd">               Inverse temperature.</span>
<span class="sd">        broadening : real, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">        mesh : list, optional</span>
<span class="sd">               Data defining mesh on which the real-axis GF will be calculated, given in the form</span>
<span class="sd">               (om_min,om_max,n_points), where om_min is the minimum omega, om_max is the maximum omega and n_points is the number of points.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True the GF will be calculated with the self-energy stored in self.Sigmaimp_(w/iw), for real/Matsubara GF, respectively. </span>
<span class="sd">                     In this case the mesh is taken from the self.Sigma_imp object.</span>
<span class="sd">                     If with_Sigma=True but self.Sigmaimp_(w/iw) is not present, with_Sigma is reset to False.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  if True and with_Sigma=True, the dc correction is substracted from the self-energy before it is included into GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_latt : BlockGf</span>
<span class="sd">                 Lattice Green&#39;s function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iw_or_w</span> <span class="o">!=</span> <span class="s">&quot;iw&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iw_or_w</span> <span class="o">!=</span> <span class="s">&quot;w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;lattice_gf: Implemented only for Re/Im frequency functions.&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;Sigma_imp_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">):</span>
            <span class="n">with_Sigma</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">broadening</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c"># broadening = 2 * \Delta omega, where \Delta omega is the spacing of omega points</span>
                <span class="n">broadening</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">((</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c"># Are we including Sigma?</span>
        <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
            <span class="n">Sigma_imp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;Sigma_imp_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">)</span>
            <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">with_dc</span><span class="p">:</span>
                <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_dc</span><span class="p">(</span><span class="n">iw_or_w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;iw&quot;</span><span class="p">:</span>
                <span class="c"># override beta if Sigma_iw is present</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;w&quot;</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
                <span class="k">if</span> <span class="n">broadening</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s">&#39;lattice_gf called with Sigma and broadening &gt; 0 (broadening = {}). You might want to explicitly set the broadening to 0.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">broadening</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;iw&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;lattice_gf: Give the beta for the lattice GfReFreq.&quot;</span>
                <span class="c"># Default number of Matsubara frequencies</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">MeshImFreq</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="s">&#39;Fermion&#39;</span><span class="p">,</span> <span class="n">n_max</span><span class="o">=</span><span class="mi">1025</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;w&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;lattice_gf: Give the mesh=(om_min,om_max,n_points) for the lattice GfReFreq.&quot;</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">MeshReFreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c"># Check if G_latt is present</span>
        <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">False</span>                       <span class="c"># Assume not</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;G_latt_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">):</span>
            <span class="c"># Need to create G_latt_(i)w</span>
            <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>                                       <span class="c"># Check that existing GF is consistent</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;G_latt_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">)</span>
            <span class="n">GFsize</span> <span class="o">=</span> <span class="p">[</span><span class="n">gf</span><span class="o">.</span><span class="n">N1</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">]</span>
            <span class="n">unchangedsize</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">]]]</span> <span class="o">==</span> <span class="n">GFsize</span><span class="p">[</span>
                                <span class="n">isp</span><span class="p">]</span> <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">])])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unchangedsize</span><span class="p">:</span>
                <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;iw&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_latt_iw</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">!=</span> <span class="n">beta</span><span class="p">):</span>
                <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c"># additional check for ImFreq</span>

        <span class="c"># Set up G_latt</span>
        <span class="k">if</span> <span class="n">set_up_G_latt</span><span class="p">:</span>
            <span class="n">block_structure</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]])</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
            <span class="n">gf_struct</span> <span class="o">=</span> <span class="p">[(</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">],</span> <span class="n">block_structure</span><span class="p">[</span><span class="n">isp</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">])]</span>
            <span class="n">block_ind_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;iw&quot;</span><span class="p">:</span>
                <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;w&quot;</span><span class="p">:</span>
                <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_list</span><span class="o">=</span><span class="n">block_ind_list</span><span class="p">,</span>
                             <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">(),</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">G_latt</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;iw&quot;</span><span class="p">:</span>
            <span class="n">G_latt</span> <span class="o">&lt;&lt;</span> <span class="n">iOmega_n</span>
        <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;w&quot;</span><span class="p">:</span>
            <span class="n">G_latt</span> <span class="o">&lt;&lt;</span> <span class="n">Omega</span> <span class="o">+</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">broadening</span>

        <span class="n">idmat</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">idmat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ibl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">ibl</span><span class="p">]]</span>
            <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
            <span class="n">M</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span> <span class="o">-</span> \
                <span class="p">(</span><span class="n">idmat</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">*</span> <span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">idmat</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ibl</span><span class="p">))</span>
        <span class="n">G_latt</span> <span class="o">-=</span> <span class="n">M</span>

        <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">:</span>
                    <span class="n">gf</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span>
                                      <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>

        <span class="n">G_latt</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;G_latt_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">,</span> <span class="n">G_latt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G_latt</span></div>

    <span class="k">def</span> <span class="nf">set_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put_Sigma</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">)</span>

<div class="viewcode-block" id="SumkDFT.put_Sigma"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.put_Sigma">[docs]</a>    <span class="k">def</span> <span class="nf">put_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Inserts the impurity self-energies into the sumk_dft class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Sigma_imp : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">                    List containing impurity self-energy for all inequivalent correlated shells.</span>
<span class="sd">                    Self-energies for equivalent shells are then automatically set by this function.</span>
<span class="sd">                    The self-energies can be of the real or imaginary-frequency type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">Sigma_imp</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s">&quot;put_Sigma: Sigma_imp has to be a list of Sigmas for the correlated shells, even if it is of length 1!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">Sigma_imp</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">,</span> <span class="s">&quot;put_Sigma: give exactly one Sigma for each inequivalent corr. shell!&quot;</span>

        <span class="c"># init self.Sigma_imp_(i)w:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">gf</span><span class="p">)</span> <span class="o">==</span> <span class="n">GfImFreq</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c"># Imaginary frequency Sigma:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                                                               <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]],</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="n">SK_Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">gf</span><span class="p">)</span> <span class="o">==</span> <span class="n">GfReFreq</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c"># Real frequency Sigma:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                                                              <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]],</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="n">SK_Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;put_Sigma: This type of Sigma is not handled.&quot;</span>

        <span class="c"># transform the CTQMC blocks to the full matrix:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="c"># ish is the index of the inequivalent shell corresponding to icrsh</span>
            <span class="n">ish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">SK_Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">block_sumk</span><span class="p">][</span>
                            <span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span>

        <span class="c"># rotation from local to global coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">SK_Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">gf</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span><span class="n">icrsh</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;toGlobal&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SumkDFT.extract_G_loc"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.extract_G_loc">[docs]</a>    <span class="k">def</span> <span class="nf">extract_G_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&#39;iw&#39;</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Extracts the local downfolded Green function by the Brillouin-zone integration of the lattice Green&#39;s function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">             Input chemical potential. If not provided the value of self.chemical_potential is used as mu.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True then the local GF is calculated with the self-energy self.Sigma_imp.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True then the double-counting correction is subtracted from the self-energy in calculating the GF.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_loc_inequiv : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">                        List of the local Green&#39;s functions for all inequivalent correlated shells, </span>
<span class="sd">                        rotated into the corresponding local frames.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>

        <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;iw&quot;</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>   <span class="c"># this list will be returned</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span>
            <span class="n">G_loc_inequiv</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()],</span>
                                     <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&quot;w&quot;</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>   <span class="c"># this list will be returned</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="n">G_loc_inequiv</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">))</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()],</span>
                                     <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>                          <span class="c"># initialize to zero</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&#39;iw&#39;</span><span class="p">:</span>
                <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">mesh_parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">omega_min</span><span class="p">,</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">omega_max</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh_parameters</span><span class="p">)</span>
            <span class="n">G_latt</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="c"># init temporary storage</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span>
                        <span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>
                <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>

        <span class="c"># Collect data from mpi</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c"># G_loc[:] is now the sum over k projected to the local orbitals.</span>
        <span class="c"># here comes the symmetrisation, if needed:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">G_loc</span><span class="p">)</span>

        <span class="c"># G_loc is rotated to the local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                        <span class="n">icrsh</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s">&#39;toLocal&#39;</span><span class="p">)</span>

        <span class="c"># transform to CTQMC blocks:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">G_loc_inequiv</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">G_loc</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">block_sumk</span><span class="p">][</span><span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span>

        <span class="c"># return only the inequivalent shells:</span>
        <span class="k">return</span> <span class="n">G_loc_inequiv</span></div>

<div class="viewcode-block" id="SumkDFT.analyse_block_structure"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.analyse_block_structure">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hloc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Determines the block structure of local Green&#39;s functions by analysing the structure of </span>
<span class="sd">        the corresponding density matrices and the local Hamiltonian. The resulting block structures </span>
<span class="sd">        for correlated shells are stored in the :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between density matrix / hloc elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of correlated shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all correlated shells will be analysed.</span>
<span class="sd">        dm : list of dict, optional</span>
<span class="sd">             List of density matrices from which block stuctures are to be analysed.</span>
<span class="sd">             Each density matrix is a dict {block names: 2d numpy arrays}.</span>
<span class="sd">             If not provided, dm will be calculated from the DFT Hamiltonian by a simple-point BZ integration.</span>
<span class="sd">        hloc : list of dict, optional</span>
<span class="sd">               List of local Hamiltonian matrices from which block stuctures are to be analysed</span>
<span class="sd">               Each Hamiltonian is a dict {block names: 2d numpy arrays}.</span>
<span class="sd">               If not provided, it will be calculated using eff_atomic_levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="p">[{}</span>
                                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_matrix</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s">&#39;using_point_integration&#39;</span><span class="p">)</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">dm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">hloc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">hloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff_atomic_levels</span><span class="p">()</span>
        <span class="n">H_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">hloc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
                 <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
                <span class="c"># gives an index list of entries larger that threshold</span>
                <span class="n">dmbool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
                <span class="n">hlocbool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

                <span class="c"># Determine off-diagonal entries in upper triangular part of</span>
                <span class="c"># density matrix</span>
                <span class="n">offdiag</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">dmbool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hlocbool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="n">offdiag</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c"># Determine the number of non-hybridising blocks in the gf</span>
                <span class="n">blocs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offdiag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pair</span> <span class="o">=</span> <span class="n">offdiag</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">blocs</span><span class="p">,</span> <span class="n">blocs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>     <span class="c"># In separate blocks?</span>
                                <span class="c"># Merge two blocks</span>
                                <span class="n">b1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">)))</span>
                                <span class="k">break</span>                                  <span class="c"># Move on to next pair in offdiag</span>

                <span class="c"># Set the gf_struct for the solver accordingly</span>
                <span class="n">num_blocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">[(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])))])</span>

                <span class="c"># Construct sumk_to_solver taking (sumk_block, sumk_index) --&gt; (solver_block, solver_inner)</span>
                <span class="c"># and solver_to_sumk taking (solver_block, solver_inner) --&gt;</span>
                <span class="c"># (sumk_block, sumk_index)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">block_sumk</span> <span class="o">=</span> <span class="n">sp</span>
                        <span class="n">inner_sumk</span> <span class="o">=</span> <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">block_solv</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">_</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">inner_solv</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block_solv</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sumk</span>

            <span class="c"># Now calculate degeneracies of orbitals</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="c"># get dm for the blocks:</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">dm</span><span class="p">[</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="n">block_sumk</span><span class="p">][</span><span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">block1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">block2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">dm</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">dm</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">dm</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dm</span><span class="p">[</span><span class="n">block2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">block1</span> <span class="o">!=</span> <span class="n">block2</span><span class="p">):</span>
                            <span class="n">ind1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="n">ind2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                            <span class="c"># check if it was already there:</span>
                            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                                <span class="k">if</span> <span class="n">block1</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">n</span>
                                <span class="k">if</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                                    <span class="n">ind2</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block1</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block2</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span><span class="p">])</span></div>

<div class="viewcode-block" id="SumkDFT.density_matrix"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;using_gf&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate density matrices in one of two ways.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string, optional</span>

<span class="sd">                 - if &#39;using_gf&#39;: First get lattice gf (g_loc is not set up), then density matrix.</span>
<span class="sd">                                  It is useful for Hubbard I, and very quick.</span>
<span class="sd">                                  No assumption on the hopping structure is made (ie diagonal or not).</span>
<span class="sd">                 - if &#39;using_point_integration&#39;: Only works for diagonal hopping matrix (true in wien2k).</span>

<span class="sd">        beta : float, optional</span>
<span class="sd">               Inverse temperature.      </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens_mat : list of dicts</span>
<span class="sd">                   Density matrix for each spin in each correlated shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;using_gf&quot;</span><span class="p">:</span>

                <span class="n">G_latt_iw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&quot;iw&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>
                <span class="n">G_latt_iw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
                <span class="n">dm</span> <span class="o">=</span> <span class="n">G_latt_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
                <span class="n">MMat</span> <span class="o">=</span> <span class="p">[</span><span class="n">dm</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]]</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;using_point_integration&quot;</span><span class="p">:</span>

                <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
                <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
                <span class="n">MMat</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spn</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]):</span>
                        <span class="c"># only works for diagonal hopping matrix (true in</span>
                        <span class="c"># wien2k)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">isp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;density_matrix: the method &#39;</span><span class="si">%s</span><span class="s">&#39; is not supported.&quot;</span> <span class="o">%</span> <span class="n">method</span>

            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
                    <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
                    <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;using_gf&quot;</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">]),</span>
                                                         <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;using_point_integration&quot;</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">]),</span>
                                                                               <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>

        <span class="c"># get data from nodes:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">)</span>

        <span class="c"># Rotate to local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]),</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>

    <span class="c"># For simple dft input, get crystal field splittings.</span>
<div class="viewcode-block" id="SumkDFT.eff_atomic_levels"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.eff_atomic_levels">[docs]</a>    <span class="k">def</span> <span class="nf">eff_atomic_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the effective local Hamiltonian required as an input for</span>
<span class="sd">        the Hubbard I Solver.</span>
<span class="sd">        The local Hamiltonian (effective atomic levels) is calculated by</span>
<span class="sd">        projecting the on-site Bloch Hamiltonian:</span>

<span class="sd">        .. math:: H^{loc}_{m m&#39;} = \sum_{k} P_{m \nu}(k) H_{\nu\nu&#39;}(k) P^{*}_{\nu&#39; m&#39;}(k),</span>

<span class="sd">        where</span>

<span class="sd">        .. math:: H_{\nu\nu&#39;}(k) = [\epsilon_{\nu k} - h_{z} \sigma_{z}] \delta_{\nu\nu&#39;}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eff_atlevels : gf_struct_sumk like</span>
<span class="sd">                       Effective local Hamiltonian :math:`H^{loc}_{m m&#39;}` for each</span>
<span class="sd">                       inequivalent correlated shell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># define matrices for inequivalent shells:</span>
        <span class="n">eff_atlevels</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s">&#39;dim&#39;</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                    <span class="n">sp</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>

        <span class="c"># sum over k:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;Hsumk&quot;</span><span class="p">):</span>
            <span class="c"># calculate the sum over k. Does not depend on mu, so do it only</span>
            <span class="c"># once:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
                        <span class="n">MMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n_orb</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                        <span class="n">MMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">isp</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="n">MMat</span>
                        <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">),</span>
                                                                                 <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="c"># symmetrisation:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">)</span>

            <span class="c"># Rotate to local coordinate system:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span>
                                <span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]),</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="c"># add to matrix:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                    <span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">eff_atlevels</span></div>

<div class="viewcode-block" id="SumkDFT.init_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.init_dc">[docs]</a>    <span class="k">def</span> <span class="nf">init_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Initializes the double counting terms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span></div>

<div class="viewcode-block" id="SumkDFT.set_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.set_dc">[docs]</a>    <span class="k">def</span> <span class="nf">set_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dc_imp</span><span class="p">,</span> <span class="n">dc_energ</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Sets double counting corrections to given values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dc_imp : gf_struct_sumk like</span>
<span class="sd">                 Double-counting self-energy term.</span>
<span class="sd">        dc_energ : list of floats</span>
<span class="sd">                   Double-counting energy corrections for each correlated shell. </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span> <span class="o">=</span> <span class="n">dc_imp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="n">dc_energ</span></div>

<div class="viewcode-block" id="SumkDFT.calc_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.calc_dc">[docs]</a>    <span class="k">def</span> <span class="nf">calc_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_interact</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">J_hund</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">use_dc_formula</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates and sets the double counting corrections.</span>

<span class="sd">        If &#39;use_dc_value&#39; is provided the double-counting term is uniformly initialized</span>
<span class="sd">        with this constant and &#39;U_interact&#39; and &#39;J_hund&#39; are ignored.</span>

<span class="sd">        If &#39;use_dc_value&#39; is None the correction is evaluated according to </span>
<span class="sd">        one of the following formulae:</span>

<span class="sd">        * use_dc_formula = 0: fully-localised limit (FLL)</span>
<span class="sd">        * use_dc_formula = 1: Held&#39;s formula, i.e. mean-field formula for the Kanamori</span>
<span class="sd">                              type of the interaction Hamiltonian</span>
<span class="sd">        * use_dc_formula = 2: around mean-field (AMF)</span>

<span class="sd">        Note that FLL and AMF formulae were derived assuming a full Slater-type interaction</span>
<span class="sd">        term and should be thus used accordingly. For the Kanamori-type interaction</span>
<span class="sd">        one should use formula 1.</span>

<span class="sd">        The double-counting self-energy term is stored in `self.dc_imp` and the energy</span>
<span class="sd">        correction in `self.dc_energ`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dens_mat : gf_struct_solver like</span>
<span class="sd">                   Density matrix for the specified correlated shell.</span>
<span class="sd">        orb : int, optional</span>
<span class="sd">              Index of an inequivalent shell.</span>
<span class="sd">        U_interact : float, optional</span>
<span class="sd">                     Value of interaction parameter `U`.</span>
<span class="sd">        J_hund : float, optional</span>
<span class="sd">                 Value of interaction parameter `J`.</span>
<span class="sd">        use_dc_formula : int, optional</span>
<span class="sd">                         Type of double-counting correction (see description).</span>
<span class="sd">        use_dc_value : float, optional</span>
<span class="sd">                       Value of the double-counting correction. If specified</span>
<span class="sd">                       `U_interact`, `J_hund` and `use_dc_formula` are ignored.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>

            <span class="c"># ish is the index of the inequivalent shell corresponding to icrsh</span>
            <span class="n">ish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ish</span> <span class="o">!=</span> <span class="n">orb</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c"># ignore this orbital</span>
            <span class="c"># *(1+self.corr_shells[icrsh][&#39;SO&#39;])</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;SO&#39;</span><span class="p">]]</span>

            <span class="n">Ncr</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">]</span>
                <span class="n">Ncr</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
            <span class="n">Ncrtot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ncr</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># average the densities if there is no SP:</span>
                    <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncrtot</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">spn</span><span class="p">)</span>
                <span class="c"># correction for SO: we have only one block in this case, but</span>
                <span class="c"># in DC we need N/2</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncrtot</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">if</span> <span class="n">use_dc_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">U_interact</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">J_hund</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;set_dc: either provide U_interact and J_hund or set use_dc_value to dc value.&quot;</span>

                <span class="k">if</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># FLL</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_interact</span> <span class="o">/</span> \
                        <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Ncrtot</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                        <span class="n">Uav</span> <span class="o">=</span> <span class="n">U_interact</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="n">J_hund</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Uav</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">-=</span> <span class="n">J_hund</span> <span class="o">/</span> \
                            <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s"> and block </span><span class="si">%(sp)s</span><span class="s"> = </span><span class="si">%(Uav)f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>

                <span class="k">elif</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># Held&#39;s formula, with U_interact the interorbital onsite interaction</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                        <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Ncrtot</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                        <span class="n">Uav</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Uav</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s"> and block </span><span class="si">%(sp)s</span><span class="s"> = </span><span class="si">%(Uav)f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>

                <span class="k">elif</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c"># AMF</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">U_interact</span> <span class="o">*</span> <span class="n">Ncrtot</span> <span class="o">*</span> <span class="n">Ncrtot</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                        <span class="n">Uav</span> <span class="o">=</span> <span class="n">U_interact</span> <span class="o">*</span> \
                            <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="n">J_hund</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">-</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Uav</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span>
                            <span class="n">icrsh</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">)</span> <span class="o">/</span> <span class="n">dim</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s"> and block </span><span class="si">%(sp)s</span><span class="s"> = </span><span class="si">%(Uav)f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>

                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;DC energy for shell </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">icrsh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]))</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c"># use value provided for user to determine dc_energ and dc_imp</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">use_dc_value</span> <span class="o">*</span> <span class="n">Ncrtot</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">use_dc_value</span>

                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s"> = </span><span class="si">%(use_dc_value)f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s">&quot;DC energy = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span></div>

<div class="viewcode-block" id="SumkDFT.add_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.add_dc">[docs]</a>    <span class="k">def</span> <span class="nf">add_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&quot;iw&quot;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Subtracts the double counting term from the impurity self energy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iw_or_w : string, optional</span>

<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sigma_minus_dc : gf_struct_sumk like</span>
<span class="sd">                         Self-energy with a subtracted double-counting term.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Be careful: Sigma_imp is already in the global coordinate system!!</span>
        <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                          <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&quot;Sigma_imp_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="c"># Transform dc_imp to global coordinate system</span>
                <span class="n">dccont</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span>
                                   <span class="n">bname</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>
                <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dccont</span>

        <span class="k">return</span> <span class="n">sigma_minus_dc</span></div>

<div class="viewcode-block" id="SumkDFT.symm_deg_gf"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.symm_deg_gf">[docs]</a>    <span class="k">def</span> <span class="nf">symm_deg_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gf_to_symm</span><span class="p">,</span> <span class="n">orb</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Averages a GF over degenerate shells.</span>

<span class="sd">        Degenerate shells of an inequivalent correlated shell are defined by</span>
<span class="sd">        `self.deg_shells`. This function enforces corresponding degeneracies</span>
<span class="sd">        in the input GF.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gf_to_symm : gf_struct_solver like</span>
<span class="sd">                     Input GF.</span>
<span class="sd">        orb : int</span>
<span class="sd">              Index of an inequivalent shell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">degsh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">orb</span><span class="p">]:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">degsh</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">ss</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
            <span class="n">n_deg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degsh</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">degsh</span><span class="p">:</span>
                <span class="n">ss</span> <span class="o">+=</span> <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">n_deg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">degsh</span><span class="p">:</span>
                <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">ss</span></div>

<div class="viewcode-block" id="SumkDFT.total_density"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.total_density">[docs]</a>    <span class="k">def</span> <span class="nf">total_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&quot;iw&quot;</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the total charge within the energy window for a given chemical potential. </span>
<span class="sd">        The chemical potential is either given by parameter `mu` or, if it is not specified,</span>
<span class="sd">        taken from `self.chemical_potential`.</span>

<span class="sd">        The total charge is calculated from the trace of the GF in the Bloch basis.</span>
<span class="sd">        By default, a full interacting GF is used. To use the non-interacting GF, set</span>
<span class="sd">        parameter `with_Sigma = False`.</span>

<span class="sd">        The number of bands within the energy windows generally depends on `k`. The trace is</span>
<span class="sd">        therefore calculated separately for each `k`-point.</span>

<span class="sd">        Since in general n_orbitals depends on k, the calculation is done in the following order:</span>

<span class="sd">        .. math:: n_{tot} = \sum_{k} n(k),</span>

<span class="sd">        with</span>

<span class="sd">        .. math:: n(k) = Tr G_{\nu\nu&#39;}(k, i\omega_{n}). </span>

<span class="sd">        The calculation is done in the global coordinate system, if distinction is made between local/global.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">             Input chemical potential. If not specified, `self.chemical_potential` is used instead.</span>
<span class="sd">        iw_or_w : string, optional</span>
<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">             If `True` the full interacing GF is evaluated, otherwise the self-energy is not</span>
<span class="sd">             included and the charge would correspond to a non-interacting system.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">             Whether or not to subtract the double-counting term from the self-energy.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens : float</span>
<span class="sd">               Total charge :math:`n_{tot}`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
            <span class="n">dens</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">G_latt</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>
        <span class="c"># collect data from mpi:</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">dens</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">dens</span></div>

<div class="viewcode-block" id="SumkDFT.set_mu"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.set_mu">[docs]</a>    <span class="k">def</span> <span class="nf">set_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Sets a new chemical potential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : float</span>
<span class="sd">             New value of the chemical potential.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">mu</span></div>

<div class="viewcode-block" id="SumkDFT.calc_mu"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.calc_mu">[docs]</a>    <span class="k">def</span> <span class="nf">calc_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&#39;iw&#39;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Searches for the chemical potential that gives the DFT total charge.</span>
<span class="sd">        A simple bisection method is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : float, optional</span>
<span class="sd">                    A desired precision of the resulting total charge.</span>
<span class="sd">        iw_or_w : string, optional</span>
<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu : float</span>
<span class="sd">             Value of the chemical potential giving the DFT total charge</span>
<span class="sd">             within specified precision.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span>
            <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
        <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_required</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_below</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">dichotomy</span><span class="o">.</span><span class="n">dichotomy</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">F</span><span class="p">,</span>
                                                      <span class="n">x_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">y_value</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
                                                      <span class="n">precision_on_y</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">delta_x</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">max_loops</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                                                      <span class="n">x_name</span><span class="o">=</span><span class="s">&quot;Chemical Potential&quot;</span><span class="p">,</span> <span class="n">y_name</span><span class="o">=</span><span class="s">&quot;Total Density&quot;</span><span class="p">,</span>
                                                      <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span></div>

<div class="viewcode-block" id="SumkDFT.calc_density_correction"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.calc_density_correction">[docs]</a>    <span class="k">def</span> <span class="nf">calc_density_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dm_type</span><span class="o">=</span><span class="s">&#39;wien2k&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the charge density correction and stores it into a file.</span>

<span class="sd">        The charge density correction is needed for charge-self-consistent DFT+DMFT calculations.</span>
<span class="sd">        It represents a density matrix of the interacting system defined in Bloch basis</span>
<span class="sd">        and it is calculated from the sum over Matsubara frequecies of the full GF,</span>

<span class="sd">        ..math:: N_{\nu\nu&#39;}(k) = \sum_{i\omega_{n}} G_{\nu\nu&#39;}(k, i\omega_{n})</span>

<span class="sd">        The density matrix for every `k`-point is stored into a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">                   Name of the file to store the charge density correction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (deltaN, dens) : tuple</span>
<span class="sd">                         Returns a tuple containing the density matrix `deltaN` and</span>
<span class="sd">                         the corresponing total charge `dens`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">dm_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;vasp&#39;</span><span class="p">,</span> <span class="s">&#39;wien2k&#39;</span><span class="p">),</span> <span class="s">&quot;&#39;dm_type&#39; must be either &#39;vasp&#39; or &#39;wienk&#39;&quot;</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="o">==</span> <span class="n">StringType</span><span class="p">,</span> <span class="p">(</span><span class="s">&quot;calc_density_correction: &quot;</span>
                                              <span class="s">&quot;filename has to be a string!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;wien2k&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;dens_mat.dat&#39;</span>
            <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;vasp&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s">&#39;GAMMA&#39;</span>
        
        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
        <span class="n">band_en_correction</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c"># Fetch Fermi weights and energy window band indices</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="n">fermi_weights</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">band_window</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">fermi_weights</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dft_misc_input&#39;</span><span class="p">][</span><span class="s">&#39;dft_fermi_weights&#39;</span><span class="p">]</span>
                <span class="n">band_window</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s">&#39;dft_misc_input&#39;</span><span class="p">][</span><span class="s">&#39;band_window&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">ar</span>
            <span class="n">fermi_weights</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">fermi_weights</span><span class="p">)</span>
            <span class="n">band_window</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">band_window</span><span class="p">)</span>

<span class="c"># Convert Fermi weights to a density matrix</span>
            <span class="n">dens_mat_dft</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fermi_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)]</span>


        <span class="c"># Set up deltaN:</span>
        <span class="n">deltaN</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
            <span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span>
                                      <span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)]</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">G_latt_iw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s">&quot;iw&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_iw</span><span class="p">:</span>
                <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_latt_iw</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>

                <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">G_latt_iw</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;vasp&#39;</span><span class="p">:</span>
<span class="c"># In &#39;vasp&#39;-mode subtract the DFT density matrix</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]]</span>
                    <span class="n">diag_inds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
                    <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">diag_inds</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][:</span><span class="n">nb</span><span class="p">]</span>
                    <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
                    <span class="n">isp</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="n">nb</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]],</span> <span class="s">&quot;Number of bands is inconsistent at ik = </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
                    <span class="n">band_en_correction</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="p">:</span><span class="n">nb</span><span class="p">,</span> <span class="p">:</span><span class="n">nb</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="c"># mpi reduce:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">deltaN</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="n">band_en_correction</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">band_en_correction</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

        <span class="c"># now save to file:</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;wien2k&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;up&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
                    <span class="n">f1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s">&#39;dn&#39;</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
                <span class="c"># write chemical potential (in Rydberg):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="c"># write beta in rydberg-1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">G_latt_iw</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">G_latt_iw</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># no spin-polarization</span>

                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                                <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                         <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                         <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%.14f</span><span class="s">  </span><span class="si">%.14f</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># with spin-polarization</span>

                    <span class="c"># dict of filename: (spin index, block_name)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">to_write</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;up&#39;</span><span class="p">),</span> <span class="n">f1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;down&#39;</span><span class="p">)}</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">to_write</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;ud&#39;</span><span class="p">),</span> <span class="n">f1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&#39;ud&#39;</span><span class="p">)}</span>
                    <span class="k">for</span> <span class="n">fout</span> <span class="ow">in</span> <span class="n">to_write</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                        <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">to_write</span><span class="p">[</span><span class="n">fout</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]):</span>
                                <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]):</span>
                                    <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%.14f</span><span class="s">  </span><span class="si">%.14f</span><span class="s"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                               <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
                        <span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;Spin-polarized density matrix is not implemented&quot;</span>

            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; </span><span class="si">%i</span><span class="s">  -1  ! Number of k-points, default number of bands</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">ib1</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">ib2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; </span><span class="si">%i</span><span class="s">  </span><span class="si">%i</span><span class="s">  </span><span class="si">%i</span><span class="se">\n</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ib1</span><span class="p">,</span> <span class="n">ib2</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                                <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; </span><span class="si">%.14f</span><span class="s">  </span><span class="si">%.14f</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;Unknown density matrix type: &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">dm_type</span><span class="p">))</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">deltaN</span><span class="p">,</span> <span class="n">dens</span>

        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="n">band_en_correction</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<span class="c">################</span>
<span class="c"># FIXME LEAVE UNDOCUMENTED</span>
<span class="c">################</span>

<div class="viewcode-block" id="SumkDFT.calc_dc_for_density"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.calc_dc_for_density">[docs]</a>    <span class="k">def</span> <span class="nf">calc_dc_for_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orb</span><span class="p">,</span> <span class="n">dc_init</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Searches for DC in order to fulfill charge neutrality.</span>
<span class="sd">           If density is given, then DC is set such that the LOCAL charge of orbital</span>
<span class="sd">           orb coincides with the given density.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">dc</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dens_mat</span><span class="o">=</span><span class="n">dens_mat</span><span class="p">,</span> <span class="n">U_interact</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">J_hund</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="n">orb</span><span class="p">,</span> <span class="n">use_dc_value</span><span class="o">=</span><span class="n">dc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dens_req</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_G_loc</span><span class="p">()[</span><span class="n">orb</span><span class="p">]</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">density</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_required</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_below</span>

        <span class="n">dc</span> <span class="o">=</span> <span class="n">dichotomy</span><span class="o">.</span><span class="n">dichotomy</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">F</span><span class="p">,</span>
                                 <span class="n">x_init</span><span class="o">=</span><span class="n">dc_init</span><span class="p">,</span> <span class="n">y_value</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
                                 <span class="n">precision_on_y</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">delta_x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                 <span class="n">max_loops</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">x_name</span><span class="o">=</span><span class="s">&quot;Double Counting&quot;</span><span class="p">,</span> <span class="n">y_name</span><span class="o">=</span><span class="s">&quot;Total Density&quot;</span><span class="p">,</span>
                                 <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dc</span></div>

<div class="viewcode-block" id="SumkDFT.check_projectors"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.check_projectors">[docs]</a>    <span class="k">def</span> <span class="nf">check_projectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculated the density matrix from projectors (DM = P Pdagger) to check that it is correct and </span>
<span class="sd">           specifically that it matches DFT.&quot;&quot;&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span>
                    <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">)</span>

        <span class="c"># Rotate to local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]),</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>

<div class="viewcode-block" id="SumkDFT.sorts_of_atoms"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.sorts_of_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">sorts_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shells</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the number of inequivalent sorts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&#39;sort&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))]</span>
        <span class="n">n_sorts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sortlst</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_sorts</span></div>

<div class="viewcode-block" id="SumkDFT.number_of_atoms"><a class="viewcode-back" href="../../reference/sumk_dft.html#dft.sumk_dft.SumkDFT.number_of_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shells</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the number of inequivalent atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s">&#39;atom&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))]</span>
        <span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atomlst</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_atoms</span></div>

    <span class="c"># The following methods are here to ensure backward-compatibility</span>
    <span class="c"># after introducing the block_structure class</span>
    <span class="k">def</span> <span class="nf">__get_gf_struct_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk</span>
    <span class="k">def</span> <span class="nf">__set_gf_struct_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_gf_struct_sumk</span><span class="p">,</span><span class="n">__set_gf_struct_sumk</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_gf_struct_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver</span>
    <span class="k">def</span> <span class="nf">__set_gf_struct_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_gf_struct_solver</span><span class="p">,</span><span class="n">__set_gf_struct_solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_solver_to_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk</span>
    <span class="k">def</span> <span class="nf">__set_solver_to_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_solver_to_sumk</span><span class="p">,</span><span class="n">__set_solver_to_sumk</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_sumk_to_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">sumk_to_solver</span>
    <span class="k">def</span> <span class="nf">__set_sumk_to_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_sumk_to_solver</span><span class="p">,</span><span class="n">__set_sumk_to_solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_solver_to_sumk_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk_block</span>
    <span class="k">def</span> <span class="nf">__set_solver_to_sumk_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_solver_to_sumk_block</span><span class="p">,</span><span class="n">__set_solver_to_sumk_block</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-2013, M. Aichhorn, L. Pourovskii, V. Vildosola, C. Martins.
    </div>
  </body>
</html>