
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>DMFT for Hubbard and Hubbard-like models &#8212; nrgljubljana_interface  documentation</title>
    <link rel="stylesheet" href="../_static/triqs.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=default"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SIAM (QS)" href="../templates/SIAM_QS.html" />
    <link rel="prev" title="Anderson-Holstein impurity model" href="holstein.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head>
  <body>
<div class="pageheader">
  <ul>
    
    <li><a href="../install.html">Install</a></li>
    
    <li><a href="../documentation.html">Documentation</a></li>
    
    <li><a href="../issues.html">Issues</a></li>
    
    <li><a href="../about.html">About nrgljubljana_interface</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../index.html">nrgljubljana_interface</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;"><a href="https://rokzitko.github.io/nrgljubljana">NRG Ljubljana</a> --  <a class="triqs" style="font-size: 12px" href="https://triqs.github.io">TRIQS</a> interface</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../templates/SIAM_QS.html" title="SIAM (QS)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="holstein.html" title="Anderson-Holstein impurity model"
             accesskey="P">previous</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" accesskey="U">Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="holstein.html"
                        title="previous chapter">Anderson-Holstein impurity model</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../templates/SIAM_QS.html"
                        title="next chapter">SIAM (QS)</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/hubbard.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="dmft-for-hubbard-and-hubbard-like-models">
<span id="hubbard"></span><h1>DMFT for Hubbard and Hubbard-like models<a class="headerlink" href="#dmft-for-hubbard-and-hubbard-like-models" title="Permalink to this headline">¶</a></h1>
<p>We now present a Python script for performing DMFT calculations with the NRG
as the impurity solver. The script is fairly complete and robust, and as such it is suitable for production runs.
It supports a variety of models with different symmetry types (including cases
with block structure and with matrix-valued Green’s functions), controls
the chemical potential to achieve the selected band occupancy, performs linear or Broyden mixing
to accelerate the convergence, stores intermediate results (checkpoints) to enable
restarts, and supports arbitrary density of states in the band (e.g. tabulated in a file).
Here is the <a class="reference download internal" href="../_downloads/hubbard.py" download=""><code class="xref download docutils literal"><span class="pre">listing</span></code></a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># DMFT(NRG) for Hubbard and Hubbard-like models (including Hubbard-Holstein model)</span>
<span class="c1"># RZ, Feb 2020</span>

<span class="kn">from</span> <span class="nn">pytriqs.gf</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.operators</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.utility</span> <span class="k">import</span> <span class="n">mpi</span>
<span class="kn">from</span> <span class="nn">nrgljubljana_interface</span> <span class="k">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">MeshReFreqPts</span><span class="p">,</span> <span class="n">hilbert_transform_refreq</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">integrate</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>

<span class="c1"># Parameters</span>
<span class="n">model</span> <span class="o">=</span> <span class="s2">&quot;SIAM&quot;</span>            <span class="c1"># impurity model (from the template library)</span>
<span class="n">dos</span> <span class="o">=</span> <span class="s2">&quot;Bethe&quot;</span>             <span class="c1"># &quot;Bethe&quot; for a Bethe lattice (semicircular) DOS or a file name for reading tabulated DOS data from a file;</span>
                          <span class="c1"># format of the DOS file: lines with &quot;eps rho(eps)&quot; pairs; arbitrary bandwidth, but should be within the NRG mesh</span>
<span class="n">Bethe_unit</span> <span class="o">=</span> <span class="mf">1.0</span>          <span class="c1"># half-bandwidth in the Bethe lattice DOS for dos=&quot;Bethe&quot;; 1.0 for D=1 units, 2.0 for t=1 units</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">2.0</span>                   <span class="c1"># Hubbard electron-electron repulsion</span>
<span class="n">occupancy_goal</span> <span class="o">=</span> <span class="mf">0.8</span>      <span class="c1"># band occupancy (summed over spin)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1e-4</span>                  <span class="c1"># temperature</span>
<span class="n">B</span> <span class="o">=</span> <span class="kc">None</span>                  <span class="c1"># magnetic field for spin-polarized calculation with U(1) symmetry;</span>
                          <span class="c1"># None = non-spin-polarized calculation with SU(2) symmetry</span>
<span class="n">omega</span> <span class="o">=</span> <span class="kc">None</span>              <span class="c1"># Holstein phonon frequency</span>
<span class="n">g1</span> <span class="o">=</span> <span class="kc">None</span>                 <span class="c1"># electron-phonon coupling strength</span>
<span class="n">n1</span> <span class="o">=</span> <span class="kc">None</span>                 <span class="c1"># shift n1 in the Holstein model definition</span>
<span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>            <span class="c1"># show info messages during the iteration</span>
<span class="n">verbose_nrg</span> <span class="o">=</span> <span class="kc">False</span>       <span class="c1"># show detailed output from the NRG solver</span>
<span class="n">store_steps</span> <span class="o">=</span> <span class="kc">True</span>        <span class="c1"># store intermediate results to files (one subdirectory per iteration)</span>
<span class="n">min_iter</span> <span class="o">=</span> <span class="mi">5</span>              <span class="c1"># minimum number of iterations (prevents premature exit from the DMFT loop)</span>
<span class="n">max_iter</span> <span class="o">=</span> <span class="mi">50</span>             <span class="c1"># maximum number of iterations (signals convergence failure)</span>
<span class="n">eps_prev</span> <span class="o">=</span> <span class="mf">1e-5</span>           <span class="c1"># convergence criterium: integrated diff between two consecutive local spectral functions</span>
<span class="n">eps_loc_imp</span> <span class="o">=</span> <span class="mf">1e-5</span>        <span class="c1"># convergence criterium: integrated diff between local and impurity spectral function</span>
<span class="n">eps_occupancy</span> <span class="o">=</span> <span class="mf">1e-4</span>      <span class="c1"># convergence criterium: difference from the target occupancy (occupancy_goal)</span>
<span class="n">mixing_method</span> <span class="o">=</span> <span class="s2">&quot;broyden&quot;</span> <span class="c1"># &quot;linear&quot; or &quot;broyden&quot; mixing; the quantity being mixed is the hybridisation function</span>
<span class="n">occup_method</span> <span class="o">=</span> <span class="s2">&quot;adjust&quot;</span>   <span class="c1"># &quot;adjust&quot; or None; adjust=shift mu so that the current GF meets the occupancy goal</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>               <span class="c1"># mixing parameter from both linear and Broyden mixing</span>
<span class="n">max_mu_adjust</span> <span class="o">=</span> <span class="mi">10</span>        <span class="c1"># number of cycles for adjusting the value of the chemical potential</span>
<span class="n">mesh_max</span> <span class="o">=</span> <span class="mf">10.0</span>           <span class="c1"># logarithmic mesh: maximum frequency (should be large enough to contain the full spectrum)</span>
<span class="n">mesh_min</span> <span class="o">=</span> <span class="mf">1e-5</span>           <span class="c1"># logarithmic mesh: minimum frequency (should be smaller than the temperature T)</span>
<span class="n">mesh_ratio</span> <span class="o">=</span> <span class="mf">1.01</span>         <span class="c1"># logarithmic mesh: common ratio of the mesh (1.01 is usually a good choice)</span>
<span class="n">Delta_min</span> <span class="o">=</span> <span class="mf">1e-5</span>          <span class="c1"># minimal value for the hybridisation function; if too large, it produces incorrect spectral distribution,</span>
                          <span class="c1"># if too small, it leads to discretization problems (1e-5 is usually a good and rather safe choice)</span>
<span class="n">normalize_to_one</span> <span class="o">=</span> <span class="kc">True</span>   <span class="c1"># scaling of the spectral function (relevant in the case of block structure and/or matrix structure of GF)</span>
<span class="n">solution_filename</span> <span class="o">=</span> <span class="s2">&quot;solution.h5&quot;</span>
<span class="n">checkpoint_filename</span> <span class="o">=</span> <span class="s2">&quot;checkpoint.h5&quot;</span>

<span class="c1"># Additional quantities of interest</span>
<span class="n">observables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_d&quot;</span><span class="p">,</span> <span class="s2">&quot;n_d^2&quot;</span><span class="p">]</span>
<span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
  <span class="n">observables</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;SZd&quot;</span><span class="p">])</span>
<span class="k">if</span> <span class="s2">&quot;Holstein&quot;</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
  <span class="n">observables</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;nph&quot;</span><span class="p">,</span> <span class="s2">&quot;displ&quot;</span><span class="p">,</span> <span class="s2">&quot;displ^2&quot;</span><span class="p">])</span>

<span class="c1"># Run-time global variables</span>
<span class="n">itern</span> <span class="o">=</span> <span class="mi">0</span>                                          <span class="c1"># iteration counter</span>
<span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()</span>         <span class="c1"># output is only produced by the master node</span>
<span class="n">store_steps</span> <span class="o">=</span> <span class="n">store_steps</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()</span> <span class="c1"># output is only produced by the master node</span>
<span class="n">symtype</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;QS&quot;</span> <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;QSZ&quot;</span><span class="p">)</span>

<span class="c1"># Set up the Solver</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">symtype</span><span class="o">=</span><span class="n">symtype</span><span class="p">,</span> <span class="n">mesh_max</span><span class="o">=</span><span class="n">mesh_max</span><span class="p">,</span> <span class="n">mesh_min</span><span class="o">=</span><span class="n">mesh_min</span><span class="p">,</span> <span class="n">mesh_ratio</span><span class="o">=</span><span class="n">mesh_ratio</span><span class="p">)</span>
<span class="n">S</span><span class="o">.</span><span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbose_nrg</span><span class="p">)</span>

<span class="n">newG</span> <span class="o">=</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">G_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>                             <span class="c1"># Creates a BlockGf object of appropriate structure</span>
<span class="n">nr_blocks</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bgf</span> <span class="p">:</span> <span class="nb">len</span><span class="p">([</span><span class="n">bl</span> <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span> <span class="c1"># Returns the number of blocks in a BlockGf object</span>
<span class="n">block_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bl</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_w</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>       <span class="c1"># Matrix size of Green&#39;s functions in block &#39;bl&#39;</span>
<span class="n">identity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bl</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">))</span>       <span class="c1"># Returns the identity matrix in block &#39;bl&#39;</span>

<span class="c1"># Solve Parameters</span>
<span class="n">sp</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="s2">&quot;Lambda&quot;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s2">&quot;Nz&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;Tmin&quot;</span><span class="p">:</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span> <span class="mi">10000</span><span class="p">,</span> <span class="s2">&quot;keepenergy&quot;</span><span class="p">:</span> <span class="mf">10.0</span> <span class="p">}</span>

<span class="c1"># Model Parameters</span>
<span class="n">mp</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;U1&quot;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span> <span class="s2">&quot;B1&quot;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span> <span class="s2">&quot;omega&quot;</span><span class="p">:</span> <span class="n">omega</span><span class="p">,</span> <span class="s2">&quot;g1&quot;</span><span class="p">:</span> <span class="n">g1</span><span class="p">,</span> <span class="s2">&quot;n1&quot;</span><span class="p">:</span> <span class="n">n1</span> <span class="p">}</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">del</span> <span class="n">mp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># Remove undefined parameters from the dictionary</span>
<span class="n">sp</span><span class="p">[</span><span class="s2">&quot;model_parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span>

<span class="c1"># Update the chemical potential</span>
<span class="k">def</span> <span class="nf">set_mu</span><span class="p">(</span><span class="n">new_mu</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">mu</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">new_mu</span>
    <span class="n">sp</span><span class="p">[</span><span class="s2">&quot;model_parameters&quot;</span><span class="p">][</span><span class="s2">&quot;eps1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">mu</span>


<span class="c1"># Low-level NRG Parameters (optional tweaks)</span>
<span class="n">nrgp</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1">#nrgp[&quot;bandrescale&quot;] = 5.0</span>
<span class="n">S</span><span class="o">.</span><span class="n">set_nrg_params</span><span class="p">(</span><span class="o">**</span><span class="n">nrgp</span><span class="p">)</span>


<span class="c1"># Initialize a function ht0 for calculating the Hilbert transform of the DOS</span>
<span class="k">if</span> <span class="p">(</span><span class="n">dos</span> <span class="o">==</span> <span class="s2">&quot;Bethe&quot;</span><span class="p">):</span>
  <span class="n">ht1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Analytical expression for Hilbert transform of Bethe lattice DOS</span>
  <span class="k">global</span> <span class="n">ht0</span>
  <span class="n">ht0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">ht1</span><span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">Bethe_unit</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">dos</span><span class="p">)</span>
  <span class="k">global</span> <span class="n">dosA</span>
  <span class="n">dosA</span> <span class="o">=</span> <span class="n">Gf</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">MeshReFreqPts</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_shape</span><span class="o">=</span><span class="p">[])</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dosA</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
      <span class="n">dosA</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]])</span>
  <span class="n">ht0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">hilbert_transform_refreq</span><span class="p">(</span><span class="n">dosA</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

<span class="c1"># Wrapper for ht0 that ensures that the imaginary part of Sigma is negative</span>
<span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-20</span> <span class="c1"># Cut-off parameter for fixing causality violation</span>
<span class="n">ht</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">ht0</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span> <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="k">else</span> <span class="n">EPS</span><span class="p">))</span> <span class="c1"># Fix problems due to causality violation</span>

<span class="c1"># Calculate a GF from hybridisation and self-energy</span>
<span class="k">def</span> <span class="nf">calc_G</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
  <span class="n">G</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">identity</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">-</span> <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="p">)</span> <span class="c1"># !!!</span>
  <span class="k">return</span> <span class="n">G</span>

<span class="c1"># Index range of a GF</span>
<span class="n">index_range</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">G</span> <span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

<span class="c1"># Return an interpolation-object representation of a spectral function for GF G</span>
<span class="k">def</span> <span class="nf">interp_A</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
  <span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
  <span class="n">ly</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="nb">sum</span><span class="p">(</span> <span class="o">-</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_range</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span> <span class="p">)</span> <span class="c1"># matrix trace</span>
    <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span> <span class="p">)</span>                                                                      <span class="c1"># sum over blocks</span>
  <span class="k">if</span> <span class="n">normalize_to_one</span><span class="p">:</span>
    <span class="n">nr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="nb">sum</span><span class="p">(</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_range</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span> <span class="p">)</span>                       <span class="c1"># number of contributions</span>
    <span class="n">ly</span> <span class="o">=</span> <span class="n">ly</span><span class="o">/</span><span class="n">nr</span>                                                                                 <span class="c1"># rescale</span>
  <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Calculate occupancy for given hybridisation, self-energy and chemical potential</span>
<span class="k">def</span> <span class="nf">calc_occupancy</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
  <span class="n">Gtrial</span> <span class="o">=</span> <span class="n">calc_G</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">interp_A</span><span class="p">(</span><span class="n">Gtrial</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">special</span><span class="o">.</span><span class="n">expit</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">T</span><span class="p">),</span> <span class="o">-</span><span class="n">mesh_max</span><span class="p">,</span> <span class="n">mesh_max</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Update mu towards reaching the occupancy goal</span>
<span class="k">def</span> <span class="nf">update_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">):</span>
  <span class="n">sol</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root_scalar</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">calc_occupancy</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">occupancy_goal</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">mu</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)</span>
  <span class="n">set_mu</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>

<span class="c1"># Calculate the local lattice GF and the hybridisation function for the effective impurity model</span>
<span class="c1"># for a given self-energy function</span>
<span class="k">def</span> <span class="nf">self_consistency</span><span class="p">(</span><span class="n">Sigma</span><span class="p">):</span>
  <span class="n">Gloc</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">)):</span> <span class="c1"># assuming square matrix</span>
          <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">Gloc</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ht</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="c1"># Hilbert-transform</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-10</span><span class="p">,</span> <span class="s2">&quot;This implementation only supports diagonal self-energy&quot;</span>
            <span class="n">Gloc</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">Glocinv</span> <span class="o">=</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
  <span class="n">Delta</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">identity</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">-</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">-</span> <span class="n">Glocinv</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="c1"># !!!</span>
  <span class="k">return</span> <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span>

<span class="c1"># Iteratively adjust mu, taking into account the self-consistency equation.</span>
<span class="c1"># Returns an improved estimate for the hybridisation function.</span>
<span class="k">def</span> <span class="nf">adjust_mu</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">):</span>
  <span class="n">old_mu</span> <span class="o">=</span> <span class="n">mu</span>
  <span class="n">Delta</span> <span class="o">=</span> <span class="n">Delta_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_mu_adjust</span><span class="p">):</span>
    <span class="n">update_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">)</span>
    <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">self_consistency</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>
  <span class="n">new_mu</span> <span class="o">=</span> <span class="n">mu</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adjusted mu from </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old_mu</span><span class="p">,</span><span class="n">new_mu</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span>

<span class="c1"># Difference between two Green&#39;s functions evaluated as the integrated squared difference between the</span>
<span class="c1"># corresponding spectral functions.</span>
<span class="k">def</span> <span class="nf">gf_diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
  <span class="n">f_a</span> <span class="o">=</span> <span class="n">interp_A</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">f_b</span> <span class="o">=</span> <span class="n">interp_A</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">f_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">f_b</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">mesh_max</span><span class="p">,</span> <span class="n">mesh_max</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Save a Green&#39;s function to a tabulated ASCII file</span>
<span class="k">def</span> <span class="nf">save_Gf</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">gf</span><span class="p">):</span>
  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>

<span class="c1"># Save all blocks for a block GF to tabulated ASCII files</span>
<span class="k">def</span> <span class="nf">save_BlockGf</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">bgf</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">save_Gf</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">bl</span> <span class="o">+</span> <span class="s2">&quot;.dat&quot;</span><span class="p">,</span> <span class="n">bgf</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span>

<span class="c1"># Save a spectral function (-1/Pi Im GF) to a tabulated ASCII file</span>
<span class="k">def</span> <span class="nf">save_A</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">gf</span><span class="p">):</span>
  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>

<span class="c1"># Save spectral functions for all blocks of the block GF</span>
<span class="k">def</span> <span class="nf">save_BlockA</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">bgf</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">save_A</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">bl</span> <span class="o">+</span> <span class="s2">&quot;.dat&quot;</span><span class="p">,</span> <span class="n">bgf</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span>

<span class="c1"># Store the complete set of results</span>
<span class="k">def</span> <span class="nf">store_result</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">arch</span><span class="p">:</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
    <span class="c1"># Global variables</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;Gself&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Gself</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;Gloc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Gloc</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>


    
    
    
    

<span class="c1"># Load the minimal set of stored results for restarting the calculation</span>
<span class="k">def</span> <span class="nf">load_Sigma_mu</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">arch</span><span class="p">:</span>
    <span class="n">Sigma</span> <span class="o">=</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Sigma_w</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span>


<span class="c1"># Initial Sigma and mu from a file</span>
<span class="k">def</span> <span class="nf">restart_calculation</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting from stored results in file </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fn</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">load_Sigma_mu</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="c1"># Load data from an HDF5 archive</span>

<span class="c1"># Initial Sigma and mu when starting from scratch</span>
<span class="k">def</span> <span class="nf">new_calculation</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting from scratch</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">Sigma</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">*</span><span class="n">occupancy_goal</span><span class="o">/</span><span class="mf">2.0</span>  <span class="c1"># Initialize self-energy with the Hartree shift</span>
  <span class="n">mu</span> <span class="o">=</span> <span class="n">U</span><span class="o">/</span><span class="mf">2.0</span> <span class="c1"># initial approximaiton for the chemical potential</span>
  <span class="k">return</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span>

<span class="c1"># Provides the initial Sigma and mu</span>
<span class="k">def</span> <span class="nf">initial_Sigma_mu</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">solution_filename</span><span class="p">):</span>     <span class="c1"># continue DMFT iteration after failed convergence</span>
    <span class="k">return</span> <span class="n">restart_calculation</span><span class="p">(</span><span class="n">solution_filename</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">checkpoint_filename</span><span class="p">):</span> <span class="c1"># continue DMFT iteration after interruption</span>
    <span class="k">return</span> <span class="n">restart_calculation</span><span class="p">(</span><span class="n">checkpoint_filename</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>                                     <span class="c1"># start from scratch</span>
    <span class="k">return</span> <span class="n">new_calculation</span><span class="p">()</span>

<span class="c1"># Exception to raise when convergence is reached</span>
<span class="k">class</span> <span class="nc">Converged</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>

<span class="c1"># Exception to raise when convergence is not reached (e.g. maximum nr of iterations exceeded)</span>
<span class="k">class</span> <span class="nc">FailedToConverge</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>

<span class="c1"># Formatting of the header in stats.dat</span>
<span class="k">def</span> <span class="nf">fmt_str_header</span><span class="p">(</span><span class="n">nr_val</span><span class="p">):</span>
  <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:&gt;5}</span><span class="s2">&quot;</span> <span class="c1"># itern</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_val</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{:&gt;15}</span><span class="s2">&quot;</span>
  <span class="k">return</span> <span class="nb">str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="c1"># Formatting of the results in stats.dat</span>
<span class="k">def</span> <span class="nf">fmt_str</span><span class="p">(</span><span class="n">nr_val</span><span class="p">):</span>
  <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{:&gt;5}</span><span class="s2">&quot;</span> <span class="c1"># itern</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr_val</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="nb">str</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{:&gt;15.8g}</span><span class="s2">&quot;</span>
  <span class="k">return</span> <span class="nb">str</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

<span class="c1"># Adjust Im(Delta) so that the hybridisation strength is not too small for the NRG discretization</span>
<span class="c1"># scheme to break down.</span>
<span class="k">def</span> <span class="nf">fix_hyb_function</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Delta_min</span><span class="p">):</span>
  <span class="n">Delta_fixed</span> <span class="o">=</span> <span class="n">Delta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">)):</span> <span class="c1"># only diagonal parts</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">Delta_fixed</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span><span class="o">&lt;-</span><span class="n">Delta_min</span> <span class="k">else</span> <span class="o">-</span><span class="n">Delta_min</span><span class="p">)</span>
  <span class="c1"># Possible improvement: re-adjust the real part so that the Kramers-Kronig relation is maintained</span>
  <span class="k">return</span> <span class="n">Delta_fixed</span>

<span class="c1"># Perform a DMFT step. Input is the hybridization function for solving the effective impurity model,</span>
<span class="c1"># output is a new hybridization function resulting from the application of the DMFT self-consistency equation.</span>
<span class="k">def</span> <span class="nf">dmft_step</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">itern</span>
  <span class="n">itern</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration </span><span class="si">%i</span><span class="s2"> min_iter=</span><span class="si">%i</span><span class="s2"> max_iter=</span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">itern</span><span class="p">,</span> <span class="n">min_iter</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">))</span>
  <span class="n">Delta_in_fixed</span> <span class="o">=</span> <span class="n">fix_hyb_function</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">,</span> <span class="n">Delta_min</span><span class="p">)</span>
  <span class="n">S</span><span class="o">.</span><span class="n">Delta_w</span> <span class="o">&lt;&lt;</span> <span class="n">Delta_in_fixed</span>

  <span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="n">sp</span><span class="p">)</span> <span class="c1"># Solve the impurity model</span>
  <span class="k">global</span> <span class="n">Gself</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">,</span> <span class="n">Gloc_prev</span>
  <span class="n">Gself</span> <span class="o">=</span> <span class="n">calc_G</span><span class="p">(</span><span class="n">Delta_in_fixed</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span> <span class="c1"># impurity GF (&quot;self-energy-trick&quot; improved)</span>
  <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">self_consistency</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">)</span>     <span class="c1"># apply the DMFT self-consistency equation</span>

  <span class="n">diff_loc_imp</span> <span class="o">=</span> <span class="n">gf_diff</span><span class="p">(</span><span class="n">Gself</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>            <span class="c1"># difference between impurity and local lattice GF</span>
  <span class="n">diff_prev</span> <span class="o">=</span> <span class="n">gf_diff</span><span class="p">(</span><span class="n">Gloc</span><span class="p">,</span> <span class="n">Gloc_prev</span><span class="p">)</span>           <span class="c1"># difference between two consecutively computed local latice GFs</span>
  <span class="n">Gloc_prev</span> <span class="o">=</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="n">occupancy</span> <span class="o">=</span> <span class="n">calc_occupancy</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
  <span class="n">diff_occupancy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">occupancy</span><span class="o">-</span><span class="n">occupancy_goal</span><span class="p">)</span> <span class="c1"># this difference is used as the measure of deviation</span>

  <span class="n">stats</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s2">&quot;itern&quot;</span><span class="p">,</span> <span class="n">itern</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;diff_loc_imp&quot;</span><span class="p">,</span> <span class="n">diff_loc_imp</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;diff_prev&quot;</span><span class="p">,</span> <span class="n">diff_prev</span><span class="p">),</span>
                       <span class="p">(</span><span class="s2">&quot;diff_occupancy&quot;</span><span class="p">,</span> <span class="n">diff_occupancy</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;occupancy&quot;</span><span class="p">,</span> <span class="n">occupancy</span><span class="p">)])</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">expv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="n">header_string</span> <span class="o">=</span> <span class="n">fmt_str_header</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
  <span class="n">stats_string</span>  <span class="o">=</span> <span class="n">fmt_str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">itern</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">stats_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header_string</span><span class="p">)</span>
    <span class="n">stats_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stats_string</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;stats: </span><span class="si">%s</span><span class="s2">stats: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">header_string</span><span class="p">,</span> <span class="n">stats_string</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">store_steps</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">))</span> <span class="c1"># one subdirectory per iteration</span>
    <span class="n">save_BlockGf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/Delta&quot;</span><span class="p">,</span> <span class="n">Delta_in_fixed</span><span class="p">)</span>
    <span class="n">save_BlockGf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/Sigma&quot;</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">)</span> <span class="c1"># self-energy</span>
    <span class="n">save_BlockGf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/G&quot;</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>          <span class="c1"># local lattice Green&#39;s function</span>
    <span class="n">save_BlockA</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/A&quot;</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>           <span class="c1"># spectral function of local lattice GF</span>
    <span class="n">store_result</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">solution_filename</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="n">store_result</span><span class="p">(</span><span class="n">checkpoint_filename</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="c1"># for checkpoint/restart functionality</span>

  <span class="c1"># Check for convergence. The only way to exit the DMFT loop is by generating exceptions.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">diff_loc_imp</span>   <span class="o">&lt;</span> <span class="n">eps_loc_imp</span>   <span class="ow">and</span>
      <span class="n">diff_prev</span>      <span class="o">&lt;</span> <span class="n">eps_prev</span>      <span class="ow">and</span>
      <span class="n">diff_occupancy</span> <span class="o">&lt;</span> <span class="n">eps_occupancy</span> <span class="ow">and</span>
      <span class="n">itern</span> <span class="o">&gt;=</span> <span class="n">min_iter</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">Converged</span><span class="p">(</span><span class="n">stats_string</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">itern</span> <span class="o">==</span> <span class="n">max_iter</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">FailedToConverge</span><span class="p">(</span><span class="n">stats_string</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">occup_method</span> <span class="o">==</span> <span class="s2">&quot;adjust&quot;</span><span class="p">:</span>
    <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">adjust_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">)</span> <span class="c1"># here we update mu to get closer to target occupancy</span>

  <span class="k">return</span> <span class="n">Delta</span>

<span class="c1"># DMFT driver routine with linear mixing</span>
<span class="k">def</span> <span class="nf">solve_with_linear_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
  <span class="n">Delta_in</span> <span class="o">=</span> <span class="n">Delta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">Delta_out</span> <span class="o">=</span> <span class="n">dmft_step</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">)</span>
    <span class="n">newDelta</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">Delta_out</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">Delta_in</span>
    <span class="n">Delta_in</span> <span class="o">&lt;&lt;</span> <span class="n">newDelta</span>

<span class="c1"># Convert GF object to a linear nparray</span>
<span class="k">def</span> <span class="nf">gf_to_nparray</span><span class="p">(</span><span class="n">gf</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># Stack elements from all blocks in a block BF</span>
<span class="k">def</span> <span class="nf">bgf_to_nparray</span><span class="p">(</span><span class="n">bgf</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">bgf</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>

<span class="c1"># Convert a linear numpy array to a single GF object</span>
<span class="k">def</span> <span class="nf">nparray_to_gf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gf</span><span class="p">):</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:,:,:]</span>

<span class="c1"># Extract blocks from linear numpy array to a block GF</span>
<span class="k">def</span> <span class="nf">nparray_to_bgf</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="n">G</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nr_blocks</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="c1"># Here we assume all blocks are equally large</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">nparray_to_gf</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">G</span>

<span class="c1"># DMFT driver routine with Broyden mixing: the goal is to find a root of the function F(Delta)=dmft_step(Delta)-Delta.</span>
<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">Delta</span> <span class="p">:</span> <span class="n">dmft_step</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span><span class="o">-</span><span class="n">Delta</span>
<span class="n">npF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">bgf_to_nparray</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">nparray_to_bgf</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="k">def</span> <span class="nf">solve_with_broyden_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
  <span class="n">xin</span> <span class="o">=</span> <span class="n">bgf_to_nparray</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span>
  <span class="n">optimize</span><span class="o">.</span><span class="n">broyden1</span><span class="p">(</span><span class="n">npF</span><span class="p">,</span> <span class="n">xin</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">reduction_method</span><span class="o">=</span><span class="s2">&quot;svd&quot;</span><span class="p">,</span> <span class="n">max_rank</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">f_tol</span><span class="o">=</span><span class="mf">1e-99</span><span class="p">)</span> <span class="c1"># Loop forever (small f_tol!)</span>

<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">Delta</span><span class="p">):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mixing_method</span><span class="o">==</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
      <span class="n">solve_with_linear_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mixing_method</span><span class="o">==</span><span class="s2">&quot;broyden&quot;</span><span class="p">):</span>
      <span class="n">solve_with_broyden_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>

<span class="c1"># Initialization</span>
<span class="n">Sigma0</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="n">initial_Sigma_mu</span><span class="p">()</span>       <span class="c1"># Get initial self-energy and chemical potential</span>
<span class="n">set_mu</span><span class="p">(</span><span class="n">mu0</span><span class="p">)</span>                            <span class="c1"># Set global variable mu and update the impurity level (epsilon_d = -mu)</span>
<span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">self_consistency</span><span class="p">(</span><span class="n">Sigma0</span><span class="p">)</span> <span class="c1"># Initialize local GF Gloc and hybridization function Delta</span>
<span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">adjust_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma0</span><span class="p">)</span> <span class="c1"># Adjust mu (and return updated Glocal and Delta as well)</span>
<span class="n">Gloc_prev</span> <span class="o">=</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>                <span class="c1"># Store copy for checking convergence</span>

<span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
  <span class="k">global</span> <span class="n">stats_file</span>
  <span class="n">stats_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;stats.dat&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">buffering</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># line buffered</span>

<span class="k">try</span><span class="p">:</span>
  <span class="n">solve</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span>

<span class="k">except</span> <span class="n">Converged</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converged: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">c</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="n">store_result</span><span class="p">(</span><span class="n">solution_filename</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="c1"># full converged results as an HDF5 file</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">checkpoint_filename</span><span class="p">)</span>     <span class="c1"># checkpoint file is no longer needed</span>
    <span class="n">save_BlockA</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>             <span class="c1"># converged spectral function for quick plotting</span>

<span class="k">except</span> <span class="n">FailedToConverge</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to converge: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">c</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="c1"># ... but restart is possible from the checkpoint file</span>

<span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span> <span class="c1"># Synchronized exit</span>
</pre></div>
</div>
<p>Running this script takes between an hour or several hours, depending on the
degree of parallelization that is enabled and the available computing resources.
During the run, some basic information about the DMFT iteration is stored in the file <code class="docutils literal"><span class="pre">stats.dat</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">itern</span>              <span class="n">mu</span>    <span class="n">diff_loc_imp</span>       <span class="n">diff_prev</span>  <span class="n">diff_occupancy</span>       <span class="n">occupancy</span>             <span class="n">n_d</span>           <span class="n">n_d</span><span class="o">^</span><span class="mi">2</span>
    <span class="mi">1</span>      <span class="mf">0.64216213</span>     <span class="mf">0.008410854</span>       <span class="mf">0.1639845</span>     <span class="mf">0.065470795</span>      <span class="mf">0.86547079</span>      <span class="mf">0.88853941</span>       <span class="mf">1.0170551</span>
    <span class="mi">2</span>      <span class="mf">0.57416456</span>    <span class="mf">0.0030978054</span>    <span class="mf">0.0033493961</span>     <span class="mf">0.048255692</span>      <span class="mf">0.84825569</span>      <span class="mf">0.86718719</span>      <span class="mf">0.97416922</span>
    <span class="mi">3</span>      <span class="mf">0.52350142</span>   <span class="mf">0.00032006683</span>    <span class="mf">0.0045037239</span>     <span class="mf">0.044544862</span>      <span class="mf">0.84454486</span>      <span class="mf">0.85230857</span>      <span class="mf">0.94144344</span>
    <span class="mi">4</span>      <span class="mf">0.47628807</span>   <span class="mf">0.00017268295</span>   <span class="mf">0.00071735455</span>     <span class="mf">0.027302305</span>      <span class="mf">0.82730231</span>       <span class="mf">0.8329584</span>       <span class="mf">0.9156406</span>
    <span class="mi">5</span>      <span class="mf">0.44771388</span>   <span class="mf">5.3787042e-05</span>    <span class="mf">0.0006119636</span>     <span class="mf">0.015770286</span>      <span class="mf">0.81577029</span>      <span class="mf">0.81874584</span>      <span class="mf">0.89894272</span>
    <span class="mi">6</span>       <span class="mf">0.4314115</span>     <span class="mf">3.43912e-05</span>   <span class="mf">9.5803891e-05</span>    <span class="mf">0.0092612995</span>       <span class="mf">0.8092613</span>      <span class="mf">0.81131439</span>      <span class="mf">0.88949259</span>
    <span class="mi">7</span>      <span class="mf">0.42188467</span>   <span class="mf">3.6268579e-05</span>   <span class="mf">7.0325948e-05</span>    <span class="mf">0.0066369482</span>      <span class="mf">0.80663695</span>      <span class="mf">0.80579098</span>      <span class="mf">0.88292743</span>
    <span class="mi">8</span>      <span class="mf">0.41508851</span>   <span class="mf">4.5411105e-05</span>   <span class="mf">1.8109524e-05</span>    <span class="mf">0.0033722505</span>      <span class="mf">0.80337225</span>      <span class="mf">0.80338313</span>      <span class="mf">0.87950144</span>
    <span class="mi">9</span>      <span class="mf">0.41163793</span>   <span class="mf">5.8842502e-05</span>   <span class="mf">3.9934759e-06</span>    <span class="mf">0.0018214352</span>      <span class="mf">0.80182144</span>      <span class="mf">0.80201381</span>      <span class="mf">0.87764421</span>
   <span class="mi">10</span>       <span class="mf">0.4097753</span>   <span class="mf">6.3801883e-05</span>   <span class="mf">1.2231238e-06</span>    <span class="mf">0.0010891672</span>      <span class="mf">0.80108917</span>      <span class="mf">0.80114589</span>       <span class="mf">0.8765355</span>
   <span class="mi">11</span>      <span class="mf">0.40866208</span>   <span class="mf">6.6673362e-05</span>   <span class="mf">4.6656617e-07</span>   <span class="mf">0.00065926119</span>      <span class="mf">0.80065926</span>      <span class="mf">0.80061656</span>      <span class="mf">0.87586398</span>
   <span class="mi">12</span>      <span class="mf">0.40798848</span>   <span class="mf">6.8445133e-05</span>   <span class="mf">1.7684942e-07</span>   <span class="mf">0.00039989342</span>      <span class="mf">0.80039989</span>      <span class="mf">0.80029503</span>      <span class="mf">0.87545665</span>
   <span class="mi">13</span>      <span class="mf">0.40757997</span>   <span class="mf">6.9588067e-05</span>   <span class="mf">6.2929404e-08</span>   <span class="mf">0.00024353334</span>      <span class="mf">0.80024353</span>       <span class="mf">0.8000997</span>      <span class="mf">0.87520934</span>
   <span class="mi">14</span>      <span class="mf">0.40733122</span>   <span class="mf">6.6379215e-05</span>   <span class="mf">1.9177454e-05</span>    <span class="mf">0.0011155475</span>      <span class="mf">0.80111555</span>      <span class="mf">0.79886188</span>      <span class="mf">0.87412851</span>
   <span class="mi">15</span>      <span class="mf">0.40619387</span>   <span class="mf">4.4607833e-05</span>   <span class="mf">3.3092449e-05</span>    <span class="mf">0.0015344904</span>      <span class="mf">0.79846551</span>      <span class="mf">0.79964663</span>      <span class="mf">0.87487525</span>
   <span class="mi">16</span>      <span class="mf">0.40776042</span>   <span class="mf">9.3749908e-07</span>   <span class="mf">2.8603095e-05</span>   <span class="mf">0.00053041152</span>      <span class="mf">0.79946959</span>      <span class="mf">0.79906779</span>      <span class="mf">0.87497248</span>
   <span class="mi">17</span>      <span class="mf">0.40830088</span>   <span class="mf">2.4812637e-07</span>   <span class="mf">1.0216056e-07</span>   <span class="mf">0.00028239426</span>      <span class="mf">0.79971761</span>      <span class="mf">0.79922373</span>      <span class="mf">0.87523217</span>
   <span class="mi">18</span>      <span class="mf">0.40858862</span>   <span class="mf">1.3398751e-07</span>   <span class="mf">1.5633394e-07</span>   <span class="mf">0.00031811496</span>      <span class="mf">0.79968189</span>      <span class="mf">0.79939042</span>      <span class="mf">0.87547037</span>
   <span class="mi">19</span>      <span class="mf">0.40891278</span>   <span class="mf">4.8884804e-09</span>   <span class="mf">6.2918295e-08</span>   <span class="mf">0.00011984463</span>      <span class="mf">0.79988016</span>      <span class="mf">0.79949007</span>      <span class="mf">0.87561332</span>
   <span class="mi">20</span>       <span class="mf">0.4090349</span>   <span class="mf">1.3450417e-09</span>   <span class="mf">1.0571106e-08</span>   <span class="mf">6.0784735e-05</span>      <span class="mf">0.79993922</span>      <span class="mf">0.79955157</span>      <span class="mf">0.87568519</span>
</pre></div>
</div>
<p>The first column is the iteration number, the second the current estimate of the chemical potential,
the following three columns provide information about the convergence (difference between local lattice
and impurity Green’s functions, difference between two consecutive local lattice Green’s function, and
the difference between target and current band occupancy). This is followed by the occupancy calculed from
the spectral function and by the expectation values of a range of local operators (the set depends on the
model considered and on the symmetry type).</p>
<p>Note: NRG impurity solver produces big temporary files during the calculation. By default, these are
stored in the working directory that is created in the current directory. To override this behavior,
set the environment variable NRG_WORKDIR. A suitable choice is a local scratch hard drive or SSD,
or a global scratch mount on a high-performance filesystem.</p>
<p>When convergence is reached, the final results are stored in an HDF5 archive file called <code class="file docutils literal"><span class="pre">solution.h5</span></code>.
This file contains all quantities of interest. Let us plot the spectral function:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="kn">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="kn">from</span> <span class="nn">pytriqs.gf</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">nrgljubljana_interface</span> <span class="kn">import</span> <span class="n">MeshReFreqPts</span>

<span class="k">def</span> <span class="nf">GF_to_nparrays</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">ly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span>

<span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="s1">&#39;solution.h5&#39;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
    <span class="c1"># Expectation values</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&lt;n&gt;=&quot;</span><span class="p">,</span><span class="n">ar</span><span class="p">[</span><span class="s1">&#39;expv&#39;</span><span class="p">][</span><span class="s1">&#39;n_d&#39;</span><span class="p">])</span>
    <span class="k">print</span><span class="p">(</span><span class="s2">&quot;&lt;n^2&gt;=&quot;</span><span class="p">,</span><span class="n">ar</span><span class="p">[</span><span class="s1">&#39;expv&#39;</span><span class="p">][</span><span class="s1">&#39;n_d^2&#39;</span><span class="p">])</span>

    <span class="c1"># Spectral function (of local lattice GF)</span>
    <span class="n">A_w</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;Gloc&#39;</span><span class="p">][</span><span class="s1">&#39;imp&#39;</span><span class="p">]</span>
    <span class="n">lx</span><span class="p">,</span> <span class="n">ly</span> <span class="o">=</span> <span class="n">GF_to_nparrays</span><span class="p">(</span><span class="n">A_w</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../guide/hubbard_plot.py">Source code</a>, <a class="reference external" href="../guide/hubbard_plot.png">png</a>, <a class="reference external" href="../guide/hubbard_plot.hires.png">hires.png</a>, <a class="reference external" href="../guide/hubbard_plot.pdf">pdf</a>)</p>
<div class="figure">
<a class="reference internal image-reference" href="../_images/hubbard_plot.png"><img alt="../_images/hubbard_plot.png" src="../_images/hubbard_plot.png" style="width: 512.0px; height: 384.0px;" /></a>
</div>
<p>Let us now go through the script in some more detail. We first import a number of useful modules:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pytriqs.gf</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.operators</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pytriqs.utility</span> <span class="k">import</span> <span class="n">mpi</span>
<span class="kn">from</span> <span class="nn">nrgljubljana_interface</span> <span class="k">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">MeshReFreqPts</span><span class="p">,</span> <span class="n">hilbert_transform_refreq</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">integrate</span><span class="p">,</span> <span class="n">special</span><span class="p">,</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
</pre></div>
</div>
<p>We make use of scipy interpolation and integration routines to obtain highly accurate results based on
the real-frequency spectra, and we make use of the Broyden solver from <code class="docutils literal"><span class="pre">scipy.optimize</span></code>.</p>
<p>The model name is a full path to the model definition in the template library, except the symmetry part
(e.g. “SIAM”, “Holstein/Nph=10”, etc.).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="s2">&quot;SIAM&quot;</span>            <span class="c1"># impurity model (from the template library)</span>
</pre></div>
</div>
<p>The code comes with a built-in support for the Bethe lattice (with half-bandwidth set by the parameter <code class="docutils literal"><span class="pre">Bethe_unit</span></code>),
or one can use tabulated DOS (example <a class="reference download internal" href="../_downloads/dos.py" download=""><code class="xref download docutils literal"><span class="pre">script</span></code></a> for generating the DOS file).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">dos</span> <span class="o">=</span> <span class="s2">&quot;Bethe&quot;</span>             <span class="c1"># &quot;Bethe&quot; for a Bethe lattice (semicircular) DOS or a file name for reading tabulated DOS data from a file;</span>
                          <span class="c1"># format of the DOS file: lines with &quot;eps rho(eps)&quot; pairs; arbitrary bandwidth, but should be within the NRG mesh</span>
<span class="n">Bethe_unit</span> <span class="o">=</span> <span class="mf">1.0</span>          <span class="c1"># half-bandwidth in the Bethe lattice DOS for dos=&quot;Bethe&quot;; 1.0 for D=1 units, 2.0 for t=1 units</span>
</pre></div>
</div>
<p>We then set key parameters, such as Hubbard <span class="math">\(U\)</span>, the occupancy, the temperature, and optionally the magnetic field.
The parameters that are not used should be set to <code class="docutils literal"><span class="pre">None</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="mf">2.0</span>                   <span class="c1"># Hubbard electron-electron repulsion</span>
<span class="n">occupancy_goal</span> <span class="o">=</span> <span class="mf">0.8</span>      <span class="c1"># band occupancy (summed over spin)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">1e-4</span>                  <span class="c1"># temperature</span>
<span class="n">B</span> <span class="o">=</span> <span class="kc">None</span>                  <span class="c1"># magnetic field for spin-polarized calculation with U(1) symmetry;</span>
                          <span class="c1"># None = non-spin-polarized calculation with SU(2) symmetry</span>
</pre></div>
</div>
<p>One can control the level of verbosity and the amount of intermediate results that are stored to disk:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>            <span class="c1"># show info messages during the iteration</span>
<span class="n">verbose_nrg</span> <span class="o">=</span> <span class="kc">False</span>       <span class="c1"># show detailed output from the NRG solver</span>
<span class="n">store_steps</span> <span class="o">=</span> <span class="kc">True</span>        <span class="c1"># store intermediate results to files (one subdirectory per iteration)</span>
</pre></div>
</div>
<p>The DMFT iteration parameters are set next. Note that there are several convergence criteria: they must all
be satisfied.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">min_iter</span> <span class="o">=</span> <span class="mi">5</span>              <span class="c1"># minimum number of iterations (prevents premature exit from the DMFT loop)</span>
<span class="n">max_iter</span> <span class="o">=</span> <span class="mi">50</span>             <span class="c1"># maximum number of iterations (signals convergence failure)</span>
<span class="n">eps_prev</span> <span class="o">=</span> <span class="mf">1e-5</span>           <span class="c1"># convergence criterium: integrated diff between two consecutive local spectral functions</span>
<span class="n">eps_loc_imp</span> <span class="o">=</span> <span class="mf">1e-5</span>        <span class="c1"># convergence criterium: integrated diff between local and impurity spectral function</span>
<span class="n">eps_occupancy</span> <span class="o">=</span> <span class="mf">1e-4</span>      <span class="c1"># convergence criterium: difference from the target occupancy (occupancy_goal)</span>
</pre></div>
</div>
<p>To accelerate the convergence to the converged result, one can make use of two different mixing schemes: linear mixing
(with parameter <span class="math">\(\alpha\)</span>) or Broyden mixing (with initial Jacobian <span class="math">\(J=-1/\alpha\)</span>). The direct
DMFT iteration corresponds to linear mixing with <span class="math">\(\alpha=1\)</span> which actually corresponds to no mixing at all.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mixing_method</span> <span class="o">=</span> <span class="s2">&quot;broyden&quot;</span> <span class="c1"># &quot;linear&quot; or &quot;broyden&quot; mixing; the quantity being mixed is the hybridisation function</span>
<span class="n">occup_method</span> <span class="o">=</span> <span class="s2">&quot;adjust&quot;</span>   <span class="c1"># &quot;adjust&quot; or None; adjust=shift mu so that the current GF meets the occupancy goal</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span>               <span class="c1"># mixing parameter from both linear and Broyden mixing</span>
</pre></div>
</div>
<p>For adjusting the chemical potential, it is useful to go through several DMFT self-consistency cycles (using the
same self-energy obtained in the last NRG run) to obtain an improved estimate. In practice order 10 cycles are quite sufficient in all cases.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">max_mu_adjust</span> <span class="o">=</span> <span class="mi">10</span>        <span class="c1"># number of cycles for adjusting the value of the chemical potential</span>
</pre></div>
</div>
<p>The logarithmic discretization mesh should span the full frequency range where the spectral function has non-negligible
value. The common ratio should be sufficiently small to produce a fine discretization mesh.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mesh_max</span> <span class="o">=</span> <span class="mf">10.0</span>           <span class="c1"># logarithmic mesh: maximum frequency (should be large enough to contain the full spectrum)</span>
<span class="n">mesh_min</span> <span class="o">=</span> <span class="mf">1e-5</span>           <span class="c1"># logarithmic mesh: minimum frequency (should be smaller than the temperature T)</span>
<span class="n">mesh_ratio</span> <span class="o">=</span> <span class="mf">1.01</span>         <span class="c1"># logarithmic mesh: common ratio of the mesh (1.01 is usually a good choice)</span>
</pre></div>
</div>
<p>The NRG has issues with regions of very low density of states in the band. To control those we define a minimal
value of the hybridisation strenth <span class="math">\(\Gamma=-\mathrm{Im}(\Delta)\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Delta_min</span> <span class="o">=</span> <span class="mf">1e-5</span>          <span class="c1"># minimal value for the hybridisation function; if too large, it produces incorrect spectral distribution,</span>
                          <span class="c1"># if too small, it leads to discretization problems (1e-5 is usually a good and rather safe choice)</span>
</pre></div>
</div>
<p>The Python dictionary <code class="docutils literal"><span class="pre">observables</span></code> contains the list of all operators whose expectation values we want to evaluate.
Some standard choices are the impurity occupancy and impurity occupancy squared, in the presence of magnetic field
also the impurity magnetization, and in the presence of phonon modes we might be interested in the phonon number
and oscillator displacement operators.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">observables</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;n_d&quot;</span><span class="p">,</span> <span class="s2">&quot;n_d^2&quot;</span><span class="p">]</span>
<span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
  <span class="n">observables</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;SZd&quot;</span><span class="p">])</span>
<span class="k">if</span> <span class="s2">&quot;Holstein&quot;</span> <span class="ow">in</span> <span class="n">model</span><span class="p">:</span>
  <span class="n">observables</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s2">&quot;nph&quot;</span><span class="p">,</span> <span class="s2">&quot;displ&quot;</span><span class="p">,</span> <span class="s2">&quot;displ^2&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>We then set some further global variables that are used in the DMFT iteration:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">itern</span> <span class="o">=</span> <span class="mi">0</span>                                          <span class="c1"># iteration counter</span>
<span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()</span>         <span class="c1"># output is only produced by the master node</span>
<span class="n">store_steps</span> <span class="o">=</span> <span class="n">store_steps</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()</span> <span class="c1"># output is only produced by the master node</span>
<span class="n">symtype</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;QS&quot;</span> <span class="k">if</span> <span class="n">B</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;QSZ&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>One may notice that in the presence of the magnetic field, the code automatically switches to the appropriate
symmetry type (<code class="docutils literal"><span class="pre">QSZ</span></code>, meaning conserved total charge and the z-component of total spin).</p>
<p>We are now ready to construct the impurity solver object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="n">model</span><span class="p">,</span> <span class="n">symtype</span><span class="o">=</span><span class="n">symtype</span><span class="p">,</span> <span class="n">mesh_max</span><span class="o">=</span><span class="n">mesh_max</span><span class="p">,</span> <span class="n">mesh_min</span><span class="o">=</span><span class="n">mesh_min</span><span class="p">,</span> <span class="n">mesh_ratio</span><span class="o">=</span><span class="n">mesh_ratio</span><span class="p">)</span>
<span class="n">S</span><span class="o">.</span><span class="n">set_verbosity</span><span class="p">(</span><span class="n">verbose_nrg</span><span class="p">)</span>
</pre></div>
</div>
<p>We usually want to suppress the detailed output from the NRG by setting <code class="docutils literal"><span class="pre">verbose_nrg</span></code> to False. (In fact,
what this does is to redirect the output to a file named <code class="docutils literal"><span class="pre">log</span></code> in the temporary directory, so that
the calculation can still be monitored.)</p>
<p>We extract the mesh and the structure of Green’s function objects for creating new objects where needed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">newG</span> <span class="o">=</span> <span class="k">lambda</span> <span class="p">:</span> <span class="n">S</span><span class="o">.</span><span class="n">G_w</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>                             <span class="c1"># Creates a BlockGf object of appropriate structure</span>
<span class="n">nr_blocks</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bgf</span> <span class="p">:</span> <span class="nb">len</span><span class="p">([</span><span class="n">bl</span> <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">])</span> <span class="c1"># Returns the number of blocks in a BlockGf object</span>
<span class="n">block_size</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bl</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_w</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>       <span class="c1"># Matrix size of Green&#39;s functions in block &#39;bl&#39;</span>
<span class="n">identity</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">bl</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">))</span>       <span class="c1"># Returns the identity matrix in block &#39;bl&#39;</span>
</pre></div>
</div>
<p>The key NRG solver parameters that control the discretization and the truncation are set here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Solve Parameters</span>
<span class="n">sp</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="s2">&quot;Lambda&quot;</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="s2">&quot;Nz&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;Tmin&quot;</span><span class="p">:</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="s2">&quot;keep&quot;</span><span class="p">:</span> <span class="mi">10000</span><span class="p">,</span> <span class="s2">&quot;keepenergy&quot;</span><span class="p">:</span> <span class="mf">10.0</span> <span class="p">}</span>
</pre></div>
</div>
<p>The default value of the discretization parameter <span class="math">\(\Lambda=2\)</span> is an excellent choice for most cases, as long as the calculation remains
feasible in reasonable time with the given computing resources; if not, one should increase <span class="math">\(\Lambda\)</span>.
We average over <code class="docutils literal"><span class="pre">Nz=4</span></code> interleaves discretization grids; this is a good number for <span class="math">\(\Lambda=2\)</span>, but should be
increased for coarses discretization to reduce the artifacts. Furthermore, it needs to be increased for high-resolution calculations
where the broadening parameters are lower.
The parameter <code class="docutils literal"><span class="pre">Tmin</span></code> controls the length of the Wilson chain and it has to be smaller than the physical temperature
<span class="math">\(T\)</span>. The truncation at rescaled energy 10 is sufficient to achieve good convergence of the spectral functions,
while beyond 12 there are hardly any improvements. <code class="docutils literal"><span class="pre">keep</span></code> (the maximum number of multiplets kept) should
be some large number and it is basically constrained by the available memory.</p>
<p>Model parameters are contained as a separate Python dictionary. We set it here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">mp</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;U1&quot;</span><span class="p">:</span> <span class="n">U</span><span class="p">,</span> <span class="s2">&quot;B1&quot;</span><span class="p">:</span> <span class="n">B</span><span class="p">,</span> <span class="s2">&quot;omega&quot;</span><span class="p">:</span> <span class="n">omega</span><span class="p">,</span> <span class="s2">&quot;g1&quot;</span><span class="p">:</span> <span class="n">g1</span><span class="p">,</span> <span class="s2">&quot;n1&quot;</span><span class="p">:</span> <span class="n">n1</span> <span class="p">}</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">mp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">del</span> <span class="n">mp</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="c1"># Remove undefined parameters from the dictionary</span>
<span class="n">sp</span><span class="p">[</span><span class="s2">&quot;model_parameters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mp</span>
</pre></div>
</div>
<p>We remove parameters that are not relevant (those set to <code class="docutils literal"><span class="pre">None</span></code>). Furthermore, the interface checks if
all required parameters for a given template are in fact defined, to prevent user errors that are
difficult to detect (e.g. typos).</p>
<p>We provide a function for updating the chemical potential. It sets the global variable <code class="docutils literal"><span class="pre">mu</span></code>, as well
as updates the impurity level to <span class="math">\(\epsilon_d=-\mu\)</span>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">set_mu</span><span class="p">(</span><span class="n">new_mu</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">mu</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">new_mu</span>
    <span class="n">sp</span><span class="p">[</span><span class="s2">&quot;model_parameters&quot;</span><span class="p">][</span><span class="s2">&quot;eps1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">mu</span>
</pre></div>
</div>
<p>If some details of the NRG calculation need to be tweaked, this can be achieve by setting the appropriate
parameters in <code class="docutils literal"><span class="pre">nrg_params</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">nrgp</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1">#nrgp[&quot;bandrescale&quot;] = 5.0</span>
<span class="n">S</span><span class="o">.</span><span class="n">set_nrg_params</span><span class="p">(</span><span class="o">**</span><span class="n">nrgp</span><span class="p">)</span>
</pre></div>
</div>
<p>Now we define the function <code class="docutils literal"><span class="pre">ht0</span></code> which evaluates the Hilbert transform of the density of states for
a given complex value <span class="math">\(z\)</span>. The analytical expression for the Bethe lattice is hard-coded, while the
generic case is handled by reading the DOS from a file and doing the Hilbert transform numerically.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">dos</span> <span class="o">==</span> <span class="s2">&quot;Bethe&quot;</span><span class="p">):</span>
  <span class="n">ht1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># Analytical expression for Hilbert transform of Bethe lattice DOS</span>
  <span class="k">global</span> <span class="n">ht0</span>
  <span class="n">ht0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">ht1</span><span class="p">(</span><span class="n">z</span><span class="o">/</span><span class="n">Bethe_unit</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
  <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">dos</span><span class="p">)</span>
  <span class="k">global</span> <span class="n">dosA</span>
  <span class="n">dosA</span> <span class="o">=</span> <span class="n">Gf</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">MeshReFreqPts</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">target_shape</span><span class="o">=</span><span class="p">[])</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dosA</span><span class="o">.</span><span class="n">mesh</span><span class="p">):</span>
      <span class="n">dosA</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]])</span>
  <span class="n">ht0</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">hilbert_transform_refreq</span><span class="p">(</span><span class="n">dosA</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>We wrap this in another function <code class="docutils literal"><span class="pre">ht</span></code> which ensures that in cases of causality violation (imaginary
part of the self-energy being positive) things do no go terribly wrong. Tiny causality violations in NRG
commonly occur at very low temperatures close to the Fermi level, where <span class="math">\(\mathrm{Im}\Sigma\)</span>
overshoots zero. This problem is well understood and, while annoying, it is usually not an issue, unless
one is explicitly interested in the low-temperature asymptotics.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">EPS</span> <span class="o">=</span> <span class="mf">1e-20</span> <span class="c1"># Cut-off parameter for fixing causality violation</span>
<span class="n">ht</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">ht0</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span> <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="o">&gt;</span><span class="mf">0.0</span> <span class="k">else</span> <span class="n">EPS</span><span class="p">))</span> <span class="c1"># Fix problems due to causality violation</span>
</pre></div>
</div>
<p>In addition, another potential problem in NRG calculation is the artifacts arising from regions of very low DOS.
We alleviate this problem by providing a minimal cutoff value <code class="docutils literal"><span class="pre">Delta_min</span></code> for the hybridisation function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">fix_hyb_function</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Delta_min</span><span class="p">):</span>
  <span class="n">Delta_fixed</span> <span class="o">=</span> <span class="n">Delta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">)):</span> <span class="c1"># only diagonal parts</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
        <span class="n">Delta_fixed</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="k">if</span> <span class="n">i</span><span class="o">&lt;-</span><span class="n">Delta_min</span> <span class="k">else</span> <span class="o">-</span><span class="n">Delta_min</span><span class="p">)</span>
  <span class="c1"># Possible improvement: re-adjust the real part so that the Kramers-Kronig relation is maintained</span>
  <span class="k">return</span> <span class="n">Delta_fixed</span>
</pre></div>
</div>
<p>In the following we will make use of a function which calculates a Green’s function given hybridisation, self-energy and
chemical potential:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_G</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
  <span class="n">G</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">identity</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">-</span> <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">-</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="p">)</span> <span class="c1"># !!!</span>
  <span class="k">return</span> <span class="n">G</span>
</pre></div>
</div>
<p>For accurate integration over spectral functions, we make use of cubic interpolation. Note that for
frequencies outside the mesh range, the spectral function is assummed to be strictly zero.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">interp_A</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
  <span class="n">lx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
  <span class="n">ly</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="nb">sum</span><span class="p">(</span> <span class="o">-</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_range</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span> <span class="p">)</span> <span class="c1"># matrix trace</span>
    <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span> <span class="p">)</span>                                                                      <span class="c1"># sum over blocks</span>
  <span class="k">if</span> <span class="n">normalize_to_one</span><span class="p">:</span>
    <span class="n">nr</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span> <span class="nb">sum</span><span class="p">(</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_range</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span> <span class="p">)</span> <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span> <span class="p">)</span>                       <span class="c1"># number of contributions</span>
    <span class="n">ly</span> <span class="o">=</span> <span class="n">ly</span><span class="o">/</span><span class="n">nr</span>                                                                                 <span class="c1"># rescale</span>
  <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">lx</span><span class="p">,</span> <span class="n">ly</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>This interpolation object is then used e.g. to compute the occupancy given hybridisation, self-energy and
chemical potential:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calc_occupancy</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
  <span class="n">Gtrial</span> <span class="o">=</span> <span class="n">calc_G</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">interp_A</span><span class="p">(</span><span class="n">Gtrial</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">special</span><span class="o">.</span><span class="n">expit</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">/</span><span class="n">T</span><span class="p">),</span> <span class="o">-</span><span class="n">mesh_max</span><span class="p">,</span> <span class="n">mesh_max</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>And this, in turn, is used for occupancy control. The following function determines the optimal value of the
chemical potential for given hybridisation and self-energy. It makes use of <code class="docutils literal"><span class="pre">root_scalar</span></code>, which implements
the secant method with initial values shifted by 0.1. This seems to be robust and works quite well in practice.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">update_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">):</span>
  <span class="n">sol</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">root_scalar</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">calc_occupancy</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">occupancy_goal</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="n">mu</span><span class="o">-</span><span class="mf">0.1</span><span class="p">)</span>
  <span class="n">set_mu</span><span class="p">(</span><span class="n">sol</span><span class="o">.</span><span class="n">root</span><span class="p">)</span>
</pre></div>
</div>
<p>Now comes the key function which calculates the lattice Green’s function, and from this a new
hybridisation function for the effective impurity model. The input is the self-energy (and implicitly the
chemical potential <code class="docutils literal"><span class="pre">mu</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">self_consistency</span><span class="p">(</span><span class="n">Sigma</span><span class="p">):</span>
  <span class="n">Gloc</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_size</span><span class="p">(</span><span class="n">bl</span><span class="p">)):</span> <span class="c1"># assuming square matrix</span>
          <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="n">Gloc</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ht</span><span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">])</span> <span class="c1"># Hilbert-transform</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">1e-10</span><span class="p">,</span> <span class="s2">&quot;This implementation only supports diagonal self-energy&quot;</span>
            <span class="n">Gloc</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
  <span class="n">Glocinv</span> <span class="o">=</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">inverse</span><span class="p">()</span>
  <span class="n">Delta</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Delta</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="n">Delta</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">+</span><span class="n">mu</span><span class="p">)</span><span class="o">*</span><span class="n">identity</span><span class="p">(</span><span class="n">bl</span><span class="p">)</span> <span class="o">-</span> <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">-</span> <span class="n">Glocinv</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="c1"># !!!</span>
  <span class="k">return</span> <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span>
</pre></div>
</div>
<p>Note that this implementation is limited to problems with diagonal self-energy (and we test for this
explicitly, as a precaution). This means that this code is only suitable for channel/orbital conserving models.</p>
<p>Now we are in position to provide an improved method for adjusting the chemical potential, which
repeatedly recalculates the hybridisation function and readjust the chemical potential. We do this
for <code class="docutils literal"><span class="pre">max_mu_adjust</span></code> cycles, with 10 being a good choice.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">adjust_mu</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">):</span>
  <span class="n">old_mu</span> <span class="o">=</span> <span class="n">mu</span>
  <span class="n">Delta</span> <span class="o">=</span> <span class="n">Delta_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_mu_adjust</span><span class="p">):</span>
    <span class="n">update_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma</span><span class="p">)</span>
    <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">self_consistency</span><span class="p">(</span><span class="n">Sigma</span><span class="p">)</span>
  <span class="n">new_mu</span> <span class="o">=</span> <span class="n">mu</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adjusted mu from </span><span class="si">%f</span><span class="s2"> to </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">old_mu</span><span class="p">,</span><span class="n">new_mu</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span>
</pre></div>
</div>
<p>We now define some miscelaneous functions. First we need a way of estimating the difference between two
Green’s functions. This will be used in the following for convergence testing. Here we again make use
of interpolation, and we define the difference as the integral over all frequencies (within the discretization
mesh window) of the difference squared. We ignore possible warnings about loss of accuracy in integration.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gf_diff</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
  <span class="n">f_a</span> <span class="o">=</span> <span class="n">interp_A</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">f_b</span> <span class="o">=</span> <span class="n">interp_A</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="p">(</span><span class="n">f_a</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">f_b</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="n">mesh_max</span><span class="p">,</span> <span class="n">mesh_max</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">diff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>We now define some functions for saving Green’s function object to tabulated ASCII files. The filename is just
the prefix. To this we append the block name and the suffix <code class="docutils literal"><span class="pre">dat</span></code>.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Save a Green&#39;s function to a tabulated ASCII file</span>
<span class="k">def</span> <span class="nf">save_Gf</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">gf</span><span class="p">):</span>
  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>

<span class="c1"># Save all blocks for a block GF to tabulated ASCII files</span>
<span class="k">def</span> <span class="nf">save_BlockGf</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">bgf</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">save_Gf</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">bl</span> <span class="o">+</span> <span class="s2">&quot;.dat&quot;</span><span class="p">,</span> <span class="n">bgf</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span>

<span class="c1"># Save a spectral function (-1/Pi Im GF) to a tabulated ASCII file</span>
<span class="k">def</span> <span class="nf">save_A</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">gf</span><span class="p">):</span>
  <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">w</span><span class="p">]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%f</span><span class="s2"> </span><span class="si">%f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">z</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>

<span class="c1"># Save spectral functions for all blocks of the block GF</span>
<span class="k">def</span> <span class="nf">save_BlockA</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">bgf</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="n">save_A</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">bl</span> <span class="o">+</span> <span class="s2">&quot;.dat&quot;</span><span class="p">,</span> <span class="n">bgf</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span>
</pre></div>
</div>
<p>In addition, the full set of results is stores as an HDF5 file. We store the relevant items from the solver
object, as well as some additional quantities (self-energy-improved impurity Green’s function, local lattice Green’s function,
chemical potential).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">store_result</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">S</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">arch</span><span class="p">:</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span>
    <span class="c1"># Global variables</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;Gself&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Gself</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;Gloc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Gloc</span>
    <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
</pre></div>
</div>
<p>When restarting from stored results, we only need to read in the self-energy and the chemical potential, since this
is sufficient to initialize the DMFT calculation.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">load_Sigma_mu</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
  <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">arch</span><span class="p">:</span>
    <span class="n">Sigma</span> <span class="o">=</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;S&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">Sigma_w</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">arch</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">restart_calculation</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting from stored results in file </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fn</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">load_Sigma_mu</span><span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="c1"># Load data from an HDF5 archive</span>
</pre></div>
</div>
<p>If not starting from a file, the initial self-energy includes the Hartree term, and the chemical potential is set to
<span class="math">\(U/2\)</span>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">new_calculation</span><span class="p">():</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting from scratch</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">Sigma</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">Sigma</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
      <span class="n">Sigma</span><span class="p">[</span><span class="n">bl</span><span class="p">][</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">*</span><span class="n">occupancy_goal</span><span class="o">/</span><span class="mf">2.0</span>  <span class="c1"># Initialize self-energy with the Hartree shift</span>
  <span class="n">mu</span> <span class="o">=</span> <span class="n">U</span><span class="o">/</span><span class="mf">2.0</span> <span class="c1"># initial approximaiton for the chemical potential</span>
  <span class="k">return</span> <span class="n">Sigma</span><span class="p">,</span> <span class="n">mu</span>
</pre></div>
</div>
<p>The DMFT loop is terminated by raising exceptions. We define them here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Exception to raise when convergence is reached</span>
<span class="k">class</span> <span class="nc">Converged</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>

<span class="c1"># Exception to raise when convergence is not reached (e.g. maximum nr of iterations exceeded)</span>
<span class="k">class</span> <span class="nc">FailedToConverge</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
</pre></div>
</div>
<p>Now comes the main part, the function which performs a DMFT step. Let us disect it. First we update the iteration counter and
initialize the hybridisation function in the impurity solver object after fixing it to a minimal value.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dmft_step</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">):</span>
  <span class="k">global</span> <span class="n">itern</span>
  <span class="n">itern</span> <span class="o">+=</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration </span><span class="si">%i</span><span class="s2"> min_iter=</span><span class="si">%i</span><span class="s2"> max_iter=</span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">itern</span><span class="p">,</span> <span class="n">min_iter</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">))</span>
  <span class="n">Delta_in_fixed</span> <span class="o">=</span> <span class="n">fix_hyb_function</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">,</span> <span class="n">Delta_min</span><span class="p">)</span>
  <span class="n">S</span><span class="o">.</span><span class="n">Delta_w</span> <span class="o">&lt;&lt;</span> <span class="n">Delta_in_fixed</span>
</pre></div>
</div>
<p>We now solve the impurity model, calculate an improved estimate of the impurity GF using the “self-energy trick”, and
apply the self-consistency equation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="o">**</span><span class="n">sp</span><span class="p">)</span> <span class="c1"># Solve the impurity model</span>
  <span class="k">global</span> <span class="n">Gself</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">,</span> <span class="n">Gloc_prev</span>
  <span class="n">Gself</span> <span class="o">=</span> <span class="n">calc_G</span><span class="p">(</span><span class="n">Delta_in_fixed</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span> <span class="c1"># impurity GF (&quot;self-energy-trick&quot; improved)</span>
  <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">self_consistency</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">)</span>     <span class="c1"># apply the DMFT self-consistency equation</span>
</pre></div>
</div>
<p>We calculate some quantities for estimating the degree of convergence:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">diff_loc_imp</span> <span class="o">=</span> <span class="n">gf_diff</span><span class="p">(</span><span class="n">Gself</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>            <span class="c1"># difference between impurity and local lattice GF</span>
  <span class="n">diff_prev</span> <span class="o">=</span> <span class="n">gf_diff</span><span class="p">(</span><span class="n">Gloc</span><span class="p">,</span> <span class="n">Gloc_prev</span><span class="p">)</span>           <span class="c1"># difference between two consecutively computed local latice GFs</span>
  <span class="n">Gloc_prev</span> <span class="o">=</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="n">occupancy</span> <span class="o">=</span> <span class="n">calc_occupancy</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
  <span class="n">diff_occupancy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">occupancy</span><span class="o">-</span><span class="n">occupancy_goal</span><span class="p">)</span> <span class="c1"># this difference is used as the measure of deviation</span>
</pre></div>
</div>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="n">stats</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s2">&quot;itern&quot;</span><span class="p">,</span> <span class="n">itern</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;mu&quot;</span><span class="p">,</span> <span class="n">mu</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;diff_loc_imp&quot;</span><span class="p">,</span> <span class="n">diff_loc_imp</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;diff_prev&quot;</span><span class="p">,</span> <span class="n">diff_prev</span><span class="p">),</span>
                       <span class="p">(</span><span class="s2">&quot;diff_occupancy&quot;</span><span class="p">,</span> <span class="n">diff_occupancy</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;occupancy&quot;</span><span class="p">,</span> <span class="n">occupancy</span><span class="p">)])</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">observables</span><span class="p">:</span>
    <span class="n">stats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">expv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="n">header_string</span> <span class="o">=</span> <span class="n">fmt_str_header</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
  <span class="n">stats_string</span>  <span class="o">=</span> <span class="n">fmt_str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">))</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">itern</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="n">stats_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header_string</span><span class="p">)</span>
    <span class="n">stats_file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">stats_string</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;stats: </span><span class="si">%s</span><span class="s2">stats: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">header_string</span><span class="p">,</span> <span class="n">stats_string</span><span class="p">))</span>
</pre></div>
</div>
<p>Furthermore, if <code class="docutils literal"><span class="pre">store_steps=True</span></code>, we save the information about each DMFT step in a separate subdirectory:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="n">store_steps</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">))</span> <span class="c1"># one subdirectory per iteration</span>
    <span class="n">save_BlockGf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/Delta&quot;</span><span class="p">,</span> <span class="n">Delta_in_fixed</span><span class="p">)</span>
    <span class="n">save_BlockGf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/Sigma&quot;</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">)</span> <span class="c1"># self-energy</span>
    <span class="n">save_BlockGf</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/G&quot;</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>          <span class="c1"># local lattice Green&#39;s function</span>
    <span class="n">save_BlockA</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/A&quot;</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>           <span class="c1"># spectral function of local lattice GF</span>
    <span class="n">store_result</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">itern</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="n">solution_filename</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span>
</pre></div>
</div>
<p>At each step, we also store the HDF5 to permit the checkpoint/restart functionality:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="n">store_result</span><span class="p">(</span><span class="n">checkpoint_filename</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="c1"># for checkpoint/restart functionality</span>
</pre></div>
</div>
<p>We now test for convergence (and for failure to reach the convergence within the maximal number of iterations):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="p">(</span><span class="n">diff_loc_imp</span>   <span class="o">&lt;</span> <span class="n">eps_loc_imp</span>   <span class="ow">and</span>
      <span class="n">diff_prev</span>      <span class="o">&lt;</span> <span class="n">eps_prev</span>      <span class="ow">and</span>
      <span class="n">diff_occupancy</span> <span class="o">&lt;</span> <span class="n">eps_occupancy</span> <span class="ow">and</span>
      <span class="n">itern</span> <span class="o">&gt;=</span> <span class="n">min_iter</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">Converged</span><span class="p">(</span><span class="n">stats_string</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">itern</span> <span class="o">==</span> <span class="n">max_iter</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">FailedToConverge</span><span class="p">(</span><span class="n">stats_string</span><span class="p">)</span>
</pre></div>
</div>
<p>We are nearly done now. We adjust the chemical potential and return the optimized hybridisation function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>  <span class="k">if</span> <span class="n">occup_method</span> <span class="o">==</span> <span class="s2">&quot;adjust&quot;</span><span class="p">:</span>
    <span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">adjust_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_w</span><span class="p">)</span> <span class="c1"># here we update mu to get closer to target occupancy</span>

  <span class="k">return</span> <span class="n">Delta</span>
</pre></div>
</div>
<p>There are two types of driving routines for the full DMFT iteration. The first is based on linear mixing:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve_with_linear_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
  <span class="n">Delta_in</span> <span class="o">=</span> <span class="n">Delta</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">Delta_out</span> <span class="o">=</span> <span class="n">dmft_step</span><span class="p">(</span><span class="n">Delta_in</span><span class="p">)</span>
    <span class="n">newDelta</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">Delta_out</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">Delta_in</span>
    <span class="n">Delta_in</span> <span class="o">&lt;&lt;</span> <span class="n">newDelta</span>
</pre></div>
</div>
<p>The second one is based on Broyden mixing. The idea is that the DMFT iteration can be thought of as a
procedure for finding the fixed point of the mutli-dimensional function <span class="math">\(F(\Delta_\mathrm{in}) = \Delta_\mathrm{out}[\Delta_\mathrm{in}]  - \Delta_\mathrm{in}\)</span>,
where <span class="math">\(\Delta_\mathrm{in}\)</span> is the input while <span class="math">\(\Delta_\mathrm{out}\)</span> the output of one DMFT step.
For ths purpose we make use of <code class="docutils literal"><span class="pre">optimize.broyden1</span></code> from scipy, but in order to do so, we
need to wrap/unwrap the Green’s function objects to/from numpy arrays, which adds a degree of complexity:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># Convert GF object to a linear nparray</span>
<span class="k">def</span> <span class="nf">gf_to_nparray</span><span class="p">(</span><span class="n">gf</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

<span class="c1"># Stack elements from all blocks in a block BF</span>
<span class="k">def</span> <span class="nf">bgf_to_nparray</span><span class="p">(</span><span class="n">bgf</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">bgf</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="k">for</span> <span class="n">bl</span> <span class="ow">in</span> <span class="n">bgf</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span>

<span class="c1"># Convert a linear numpy array to a single GF object</span>
<span class="k">def</span> <span class="nf">nparray_to_gf</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gf</span><span class="p">):</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,:]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:,:,:]</span>

<span class="c1"># Extract blocks from linear numpy array to a block GF</span>
<span class="k">def</span> <span class="nf">nparray_to_bgf</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
  <span class="n">G</span> <span class="o">=</span> <span class="n">newG</span><span class="p">()</span>
  <span class="n">split</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nr_blocks</span><span class="p">(</span><span class="n">G</span><span class="p">))</span> <span class="c1"># Here we assume all blocks are equally large</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">nparray_to_gf</span><span class="p">(</span><span class="n">split</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">G</span><span class="p">[</span><span class="n">bl</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">G</span>

<span class="c1"># DMFT driver routine with Broyden mixing: the goal is to find a root of the function F(Delta)=dmft_step(Delta)-Delta.</span>
<span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">Delta</span> <span class="p">:</span> <span class="n">dmft_step</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span><span class="o">-</span><span class="n">Delta</span>
<span class="n">npF</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="n">bgf_to_nparray</span><span class="p">(</span><span class="n">F</span><span class="p">(</span><span class="n">nparray_to_bgf</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<span class="k">def</span> <span class="nf">solve_with_broyden_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
  <span class="n">xin</span> <span class="o">=</span> <span class="n">bgf_to_nparray</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span>
  <span class="n">optimize</span><span class="o">.</span><span class="n">broyden1</span><span class="p">(</span><span class="n">npF</span><span class="p">,</span> <span class="n">xin</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span> <span class="n">reduction_method</span><span class="o">=</span><span class="s2">&quot;svd&quot;</span><span class="p">,</span> <span class="n">max_rank</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">f_tol</span><span class="o">=</span><span class="mf">1e-99</span><span class="p">)</span> <span class="c1"># Loop forever (small f_tol!)</span>
</pre></div>
</div>
<p>Here we pick the method:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">Delta</span><span class="p">):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mixing_method</span><span class="o">==</span><span class="s2">&quot;linear&quot;</span><span class="p">):</span>
      <span class="n">solve_with_linear_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mixing_method</span><span class="o">==</span><span class="s2">&quot;broyden&quot;</span><span class="p">):</span>
      <span class="n">solve_with_broyden_mixing</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">alpha</span><span class="p">)</span>
</pre></div>
</div>
<p>The problem is initialized here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Sigma0</span><span class="p">,</span> <span class="n">mu0</span> <span class="o">=</span> <span class="n">initial_Sigma_mu</span><span class="p">()</span>       <span class="c1"># Get initial self-energy and chemical potential</span>
<span class="n">set_mu</span><span class="p">(</span><span class="n">mu0</span><span class="p">)</span>                            <span class="c1"># Set global variable mu and update the impurity level (epsilon_d = -mu)</span>
<span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">self_consistency</span><span class="p">(</span><span class="n">Sigma0</span><span class="p">)</span> <span class="c1"># Initialize local GF Gloc and hybridization function Delta</span>
<span class="n">Gloc</span><span class="p">,</span> <span class="n">Delta</span> <span class="o">=</span> <span class="n">adjust_mu</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span> <span class="n">Sigma0</span><span class="p">)</span> <span class="c1"># Adjust mu (and return updated Glocal and Delta as well)</span>
<span class="n">Gloc_prev</span> <span class="o">=</span> <span class="n">Gloc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>                <span class="c1"># Store copy for checking convergence</span>
</pre></div>
</div>
<p>And the solver is started here:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
  <span class="n">solve</span><span class="p">(</span><span class="n">Delta</span><span class="p">)</span>

<span class="k">except</span> <span class="n">Converged</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Converged: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">c</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="n">store_result</span><span class="p">(</span><span class="n">solution_filename</span><span class="p">,</span> <span class="n">S</span><span class="p">)</span> <span class="c1"># full converged results as an HDF5 file</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">checkpoint_filename</span><span class="p">)</span>     <span class="c1"># checkpoint file is no longer needed</span>
    <span class="n">save_BlockA</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="n">Gloc</span><span class="p">)</span>             <span class="c1"># converged spectral function for quick plotting</span>

<span class="k">except</span> <span class="n">FailedToConverge</span> <span class="k">as</span> <span class="n">c</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Failed to converge: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">c</span><span class="o">.</span><span class="n">message</span><span class="p">)</span> <span class="c1"># ... but restart is possible from the checkpoint file</span>
</pre></div>
</div>
<p>This completes the exposition. Have fun running DMFT(NRG) calculations!</p>
<p>Note: this script has not yet been tested for the case of matrix-valued Green’s functions.</p>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="../templates/SIAM_QS.html" title="SIAM (QS)"
             >next</a> |</li>
        <li class="right" >
          <a href="holstein.html" title="Anderson-Holstein impurity model"
             >previous</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019 R. Žitko, N. Wentzell.
    </div>
  </body>
</html>