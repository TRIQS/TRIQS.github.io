<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>triqs_dft_tools.sumk_dft &mdash; TRIQS DFTTools  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=f7f783a0" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../_static/triqs_favicon.ico"/>
  
        <script src="../../_static/jquery.js?v=8dae8fb0"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #7E588A" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TRIQS DFTTools
          </a>
              <div class="version">
                3.3.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#packaged-versions-of-dfttools">Packaged Versions of DFTTools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#ubuntu-debian-packages">Ubuntu Debian packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#anaconda-experimental">Anaconda (experimental)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#docker">Docker</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#compiling-dfttools-from-source">Compiling DFTTools from source</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#installation-steps">Installation steps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#important-note-for-fcsc-dft-dmft-calculations">Important note for FCSC DFT+DMFT calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#installation-steps-for-the-use-with-wien2k-version-14-2-and-older">Installation steps for the use with WIEN2K version 14.2 and older</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#version-compatibility">Version compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#custom-cmake-options">Custom CMake options</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#basic-notions">Basic notions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../basicnotions/first.html">What you should know</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#what-is-dfttools">What is <strong class="program">DFTTools</strong>?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#understand-the-philosophy-of-dfttools">Understand the philosophy of <strong class="program">DFTTools</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#learn-how-to-use-triqs-library-and-the-cthyb-solver">Learn how to use TRIQS library (and the CTHYB solver)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#analytic-continuation">Analytic Continuation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../basicnotions/dft_dmft.html">Introduction to DFT+DMFT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#density-functional-theory-in-a-very-small-nutshell">Density-functional theory in a (very small) nutshell</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#from-dft-to-dmft">From DFT to DMFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#using-projective-wannier-functions-for-dmft">Using projective Wannier functions for DMFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#full-charge-self-consistency">Full charge self-consistency</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../basicnotions/structure.html">Structure of <strong class="program">DFTTools</strong></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#the-interface-layer">The interface layer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#the-dmft-calculation">The DMFT calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#full-charge-self-consistency">Full charge self consistency</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#post-processing">Post-processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#executing-your-python-scripts">Executing your python scripts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#construction-of-local-orbitals-from-dft">Construction of local orbitals from DFT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/conversion.html">Supported interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_wien2k.html">Interface with Wien2k</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_vasp.html">Interface with VASP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_elk.html">Interface with Elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_W90.html">Interface with Wannier90</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_generalhk.html">A general H(k)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/conversion.html#mpi-issues">MPI issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/conversion.html#interfaces-to-other-packages">Interfaces to other packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../h5structure.html">standardized hdf5 structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../h5structure.html#groups-and-their-formats">groups and their formats</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../h5structure.html#general-and-simple-h-k-converter">General and simple H(k) Converter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#dft-dmft">DFT+DMFT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/dftdmft_singleshot.html">Single-shot DFT+DMFT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#initialization-of-the-calculation">Initialization of the calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#setting-up-the-impurity-solver">Setting up the impurity solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#doing-the-dmft-loop">Doing the DMFT loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#restarting-a-calculation">Restarting a calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#mixing">Mixing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/dftdmft_selfcons.html">Full charge self-consistency</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#wien2k-dmftproj">Wien2k + dmftproj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#vasp-plovasp">VASP + PLOVasp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#elk">Elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#other-dft-codes">Other DFT codes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#advanced-topics">Advanced Topics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/blockstructure.html">Manipulating the Green’s functions block structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#creating-a-block-structure-and-green-s-function">Creating a block structure and Green’s function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#the-solver-structure">The <em>solver</em> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#picking-orbitals">Picking orbitals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#basis-rotations">Basis rotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#diagonal-approximation">Diagonal approximation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/BasisRotation.html">Automatic basis rotations in DFT+DMFT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/BasisRotation.html#setting-up-the-initial-solver-structure-from-dft">Setting up the initial solver structure from DFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/BasisRotation.html#finding-the-transformation-matrix">Finding the transformation matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/BasisRotation.html#automatic-transformation-during-the-dmft-loop">Automatic transformation during the DMFT loop</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/soc.html">Spin-orbit coupled calculations (single-shot)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#treatment-of-soc-in-dft">Treatment of SOC in DFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#treatment-of-soc-in-wien2k">Treatment of SOC in Wien2k</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#treatment-of-soc-in-elk">Treatment of SOC in Elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#after-generating-the-projectors">After generating the projectors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#postprocessing">Postprocessing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/analysis.html">Tools for analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#initialisation">Initialisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#density-of-states">Density of states</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#band-resolved-density-matrices">Band resolved density matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#momentum-resolved-spectral-function-with-real-frequency-self-energy">Momentum resolved spectral function (with real-frequency self energy)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#energy-contours-of-the-k-resolved-spectral-function">Energy contours of the k-resolved Spectral function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#partial-charges">Partial charges</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/transport.html">Transport calculations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#formalism">Formalism</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#using-the-transport-code">Using the transport code</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#reference-manual">Reference manual</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.block_structure.html">block_structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.block_structure.BlockStructure.html">triqs_dft_tools.block_structure.BlockStructure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.html">converters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.converter_tools.html">converter_tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.elk.html">elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.elktools.html">elktools</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.hk.html">hk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.plovasp.html">plovasp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.vasp.html">vasp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.wannier90.html">wannier90</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.wien2k.html">wien2k</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft.html">sumk_dft</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.html">triqs_dft_tools.sumk_dft.SumkDFT</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_tools.html">sumk_dft_tools</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_tools.SumkDFTTools.html">triqs_dft_tools.sumk_dft_tools.SumkDFTTools</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.symmetry.html">symmetry</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.symmetry.Symmetry.html">triqs_dft_tools.symmetry.Symmetry</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.trans_basis.html">trans_basis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.trans_basis.TransBasis.html">triqs_dft_tools.trans_basis.TransBasis</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.util.html">util</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.util.compute_DC_from_density.html">triqs_dft_tools.util.compute_DC_from_density</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#faqs">FAQs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faqs/faqs.html">Frequently-Asked Questions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#wien2k-fermi-error-when-running-x-lapw2-almd-band">wien2k: FERMI ERROR when running <cite>x lapw2 -almd -band</cite></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#how-do-i-plot-the-output-of-spaghettis">How do I plot the output of <cite>spaghettis</cite>?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#x-optic-does-not-write-a-case-pmat-file">x optic does not write a case.pmat file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#how-do-i-get-real-frequency-quantities">How do I get real-frequency quantities?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#a-simple-example-srvo3">A simple example: SrVO3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/srvo3.html">DFT (Wien2k) and Wannier orbitals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#dft-setup">DFT setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#wannier-orbitals">Wannier orbitals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/srvo3.html#the-dmft-calculation">The DMFT calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#loading-modules">Loading modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#initializing-sumkdft">Initializing SumkDFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#initializing-the-solver">Initializing the solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#dmft-cycle">DMFT cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#tail-fit-parameters">Tail fit parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#basis-rotations-sr2mgoso6-without-soc">Basis rotations: Sr2MgOsO6 without SOC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html">DFT (Wien2k) and Wannier orbitals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#dft-setup">DFT setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#wannier-orbitals">Wannier orbitals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#the-dmft-calculation">The DMFT calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#rotating-the-basis">Rotating the basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#the-interaction-hamiltonian">The interaction Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#the-dmft-loop-with-automatic-basis-rotations">The DMFT loop with automatic basis rotations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#sr2mgoso6-with-soc-non-magnetic">Sr2MgOsO6 with SOC (non-magnetic)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html">DFT (Wien2k) and Wannier orbitals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#dft-setup">DFT setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#wannier-orbitals">Wannier orbitals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#the-dmft-calculation">The DMFT calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#rotating-the-basis">Rotating the basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#the-interaction-hamiltonian">The interaction Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#the-dmft-loop-with-automatic-basis-rotations">The DMFT loop with automatic basis rotations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#full-charge-self-consistency-with-wien2k-gamma-ce">Full charge self consistency with Wien2k: <span class="math notranslate nohighlight">\(\gamma\)</span>-Ce</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html">DFT+DMFT tutorial: Ce with Hubbard-I approximation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#wien2k-setup">Wien2k setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#wannier-orbitals-dmftproj">Wannier orbitals: dmftproj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#dmft-setup-hubbard-i-calculations-in-triqs">DMFT setup: Hubbard-I calculations in TRIQS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#fully-charge-self-consistent-dft-dmft-calculation">Fully charge self-consistent DFT+DMFT calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#post-processing-and-data-analysis">Post-processing and data analysis</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#vasp-interface-examples">VASP interface examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials.html#simple-converter-example-srvo3">Simple Converter example: SrVO3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_vasp/svo_notebook.html">VASP setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_vasp/svo_notebook.html#PLOVASP">PLOVASP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_vasp/svo_notebook.html#Converting-to-hdf5-file">Converting to hdf5 file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials.html#complex-example-nio">Complex example: NiO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/nio_csc_vasp/nio_csc.html">DFT and projections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/nio_csc_vasp/nio_csc.html#dmft">DMFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/nio_csc_vasp/nio_csc.html#charge-self-consistent-dmft">Charge self-consistent DMFT</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#elk-interface-examples">Elk interface examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials.html#converter-example-srvo3">Converter example: SrVO3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_elk/srvo3.html">Elk to TRIQS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_elk/srvo3.html#the-dmft-calculation">The DMFT calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_elk/srvo3.html#triqs-to-elk-fully-charge-self-consistent-dft-dmft">TRIQS to Elk (Fully Charge Self-Consistent DFT+DMFT)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ChangeLog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-3-0">Version 3.3.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#general">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#feat">feat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#build">build</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#doc">doc</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-2-1">Version 3.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-2-0">Version 3.2.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id2">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#elk">Elk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#vasp">Vasp</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#w90-qe">w90 + QE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#clean">clean</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-1-1">Version 3.1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id3">General</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-1-0">Version 3.1.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#wannier90-converter">Wannier90 Converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#change-in-gf-struct">Change in gf_struct</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#documentation">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#cmake">Cmake</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#other-changes">Other changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-0-0">Version 3.0.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#restructuring">Restructuring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#dependency-management">Dependency Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id4">Other Changes:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-2-2-1">Version 2.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-2-2-0">Version 2.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-2-1-x-changes-since-1-4">Version 2.1.x (changes since 1.4)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../about.html#license">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../about.html#authors-quotation">Authors &amp; Quotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../about.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #7E588A" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TRIQS DFTTools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">triqs_dft_tools.sumk_dft</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for triqs_dft_tools.sumk_dft</h1><div class="highlight"><pre>
<span></span>
<span class="c1">##########################################################################</span>
<span class="c1">#</span>
<span class="c1"># TRIQS: a Toolbox for Research in Interacting Quantum Systems</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2018 by G. J. Kraberger</span>
<span class="c1"># Copyright (C) 2011 by M. Aichhorn, L. Pourovskii, V. Vildosola</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is free software: you can redistribute it and/or modify it under the</span>
<span class="c1"># terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation, either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="c1"># WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># TRIQS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">##########################################################################</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">General SumK class and helper functions for combining ab-initio code and triqs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">triqs.utility.dichotomy</span> <span class="k">as</span> <span class="nn">dichotomy</span>
<span class="kn">from</span> <span class="nn">triqs.gf</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">triqs.utility.mpi</span> <span class="k">as</span> <span class="nn">mpi</span>
<span class="kn">from</span> <span class="nn">triqs.utility.comparison_tests</span> <span class="kn">import</span> <span class="n">assert_arrays_are_close</span>
<span class="kn">from</span> <span class="nn">h5</span> <span class="kn">import</span> <span class="n">HDFArchive</span>
<span class="kn">from</span> <span class="nn">.symmetry</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.block_structure</span> <span class="kn">import</span> <span class="n">BlockStructure</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">compute_DC_from_density</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">compress</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">newton</span><span class="p">,</span> <span class="n">brenth</span>


<div class="viewcode-block" id="SumkDFT">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.html#triqs_dft_tools.sumk_dft.SumkDFT">[docs]</a>
<span class="k">class</span> <span class="nc">SumkDFT</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This class provides a general SumK method for combining ab-initio code and triqs.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SumkDFT.__init__">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.__init__.html#triqs_dft_tools.sumk_dft.SumkDFT.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf_file</span><span class="p">,</span> <span class="n">h_field</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">n_iw</span><span class="o">=</span><span class="mi">1025</span><span class="p">,</span> <span class="n">use_dft_blocks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">dft_data</span><span class="o">=</span><span class="s1">&#39;dft_input&#39;</span><span class="p">,</span> <span class="n">symmcorr_data</span><span class="o">=</span><span class="s1">&#39;dft_symmcorr_input&#39;</span><span class="p">,</span> <span class="n">parproj_data</span><span class="o">=</span><span class="s1">&#39;dft_parproj_input&#39;</span><span class="p">,</span>
                 <span class="n">symmpar_data</span><span class="o">=</span><span class="s1">&#39;dft_symmpar_input&#39;</span><span class="p">,</span> <span class="n">bands_data</span><span class="o">=</span><span class="s1">&#39;dft_bands_input&#39;</span><span class="p">,</span> <span class="n">transp_data</span><span class="o">=</span><span class="s1">&#39;dft_transp_input&#39;</span><span class="p">,</span>
                 <span class="n">misc_data</span><span class="o">=</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">,</span><span class="n">bc_data</span><span class="o">=</span><span class="s1">&#39;dft_bandchar_input&#39;</span><span class="p">,</span><span class="n">cont_data</span><span class="o">=</span><span class="s1">&#39;dft_contours_input&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises the class from data previously stored into an hdf5 archive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hdf_file : string</span>
<span class="sd">                   Name of hdf5 containing the data.</span>
<span class="sd">        h_field : scalar, optional</span>
<span class="sd">                  The value of magnetic field to add to the DFT Hamiltonian.</span>
<span class="sd">                  The contribution -h_field*sigma is added to diagonal elements of the Hamiltonian.</span>
<span class="sd">                  It cannot be used with the spin-orbit coupling on; namely h_field is set to 0 if self.SO=True.</span>
<span class="sd">        mesh: MeshImFreq or MeshReFreq, optional. Frequency mesh of Sigma.</span>
<span class="sd">        beta : real, optional</span>
<span class="sd">               Inverse temperature. Used to construct imaginary frequency if mesh is not given.</span>
<span class="sd">        n_iw : integer, optional</span>
<span class="sd">               Number of Matsubara frequencies. Used to construct imaginary frequency if mesh is not given.</span>
<span class="sd">        use_dft_blocks : boolean, optional</span>
<span class="sd">                         If True, the local Green&#39;s function matrix for each spin is divided into smaller blocks</span>
<span class="sd">                          with the block structure determined from the DFT density matrix of the corresponding correlated shell.</span>

<span class="sd">                         Alternatively and additionally, the block structure can be analysed using :meth:`analyse_block_structure &lt;dft.sumk_dft.SumkDFT.analyse_block_structure&gt;`</span>
<span class="sd">                         and manipulated using the SumkDFT.block_structre attribute (see :class:`BlockStructure &lt;dft.block_structure.BlockStructure&gt;`).</span>
<span class="sd">        dft_data : string, optional</span>
<span class="sd">                   Name of hdf5 subgroup in which DFT data for projector and lattice Green&#39;s function construction are stored.</span>
<span class="sd">        symmcorr_data : string, optional</span>
<span class="sd">                        Name of hdf5 subgroup in which DFT data on symmetries of correlated shells</span>
<span class="sd">                        (symmetry operations, permutaion matrices etc.) are stored.</span>
<span class="sd">        parproj_data : string, optional</span>
<span class="sd">                       Name of hdf5 subgroup in which DFT data on non-normalized projectors for non-correlated</span>
<span class="sd">                       states (used in the partial density of states calculations) are stored.</span>
<span class="sd">        symmpar_data : string, optional</span>
<span class="sd">                       Name of hdf5 subgroup in which DFT data on symmetries of the non-normalized projectors</span>
<span class="sd">                       are stored.</span>
<span class="sd">        bands_data : string, optional</span>
<span class="sd">                     Name of hdf5 subgroup in which DFT data necessary for band-structure/k-resolved spectral</span>
<span class="sd">                     function calculations (projectors, DFT Hamiltonian for a chosen path in the Brillouin zone etc.)</span>
<span class="sd">                     are stored.</span>
<span class="sd">        transp_data : string, optional</span>
<span class="sd">                      Name of hdf5 subgroup in which DFT data necessary for transport calculations are stored.</span>
<span class="sd">        misc_data : string, optional</span>
<span class="sd">                    Name of hdf5 subgroup in which miscellaneous DFT data are stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdf_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Give a string for the hdf5 filename to read the input!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span> <span class="o">=</span> <span class="n">hdf_file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span> <span class="o">=</span> <span class="n">dft_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span> <span class="o">=</span> <span class="n">symmcorr_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parproj_data</span> <span class="o">=</span> <span class="n">parproj_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmpar_data</span> <span class="o">=</span> <span class="n">symmpar_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands_data</span> <span class="o">=</span> <span class="n">bands_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transp_data</span> <span class="o">=</span> <span class="n">transp_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">misc_data</span> <span class="o">=</span> <span class="n">misc_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bc_data</span> <span class="o">=</span> <span class="n">bc_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cont_data</span> <span class="o">=</span> <span class="n">cont_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">=</span> <span class="n">h_field</span>

            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">MeshImFreq</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="s1">&#39;Fermion&#39;</span><span class="p">,</span> <span class="n">n_max</span><span class="o">=</span><span class="n">n_iw</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">first_index</span><span class="p">()),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">last_index</span><span class="p">()),</span>
                                               <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">first_index</span><span class="p">()),</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">last_index</span><span class="p">()),</span>
                                               <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mesh must be a triqs mesh of type MeshImFreq or MeshReFreq&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span> <span class="o">=</span> <span class="n">BlockStructure</span><span class="p">()</span>

            <span class="c1"># Read input from HDF:</span>
            <span class="n">req_things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;energy_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;n_k&#39;</span><span class="p">,</span> <span class="s1">&#39;k_dep_projection&#39;</span><span class="p">,</span> <span class="s1">&#39;SP&#39;</span><span class="p">,</span> <span class="s1">&#39;SO&#39;</span><span class="p">,</span> <span class="s1">&#39;charge_below&#39;</span><span class="p">,</span> <span class="s1">&#39;density_required&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;symm_op&#39;</span><span class="p">,</span> <span class="s1">&#39;n_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;shells&#39;</span><span class="p">,</span> <span class="s1">&#39;n_corr_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;corr_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;use_rotations&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;rot_mat_time_inv&#39;</span><span class="p">,</span> <span class="s1">&#39;n_reps&#39;</span><span class="p">,</span> <span class="s1">&#39;dim_reps&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;n_orbitals&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_mat&#39;</span><span class="p">,</span> <span class="s1">&#39;bz_weights&#39;</span><span class="p">,</span> <span class="s1">&#39;hopping&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;n_inequiv_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;corr_to_inequiv&#39;</span><span class="p">,</span> <span class="s1">&#39;inequiv_to_corr&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subgroup_present</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values_not_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
                <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">req_things_to_read</span><span class="p">)</span>

            <span class="c1"># test if all required properties have been found</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">values_not_read</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;ERROR: One or more necessary SumK input properties have not been found in the given h5 archive:&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values_not_read</span><span class="p">)</span>

            <span class="c1"># optional properties to load</span>
            <span class="c1"># soon bz_weights is depraced and replaced by kpt_weights, kpts_basis and kpts will become required to read soon</span>
            <span class="n">optional_things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;proj_mat_csc&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_or_hk&#39;</span><span class="p">,</span> <span class="s1">&#39;kpt_basis&#39;</span><span class="p">,</span> <span class="s1">&#39;kpts&#39;</span><span class="p">,</span> <span class="s1">&#39;kpt_weights&#39;</span><span class="p">,</span> <span class="s1">&#39;dft_code&#39;</span><span class="p">]</span>
            <span class="n">subgroup_present</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">optional_values_not_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span><span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">optional_things_to_read</span><span class="p">)</span>

            <span class="c1"># warning if dft_code was not read (old h5 structure)</span>
            <span class="k">if</span> <span class="s1">&#39;dft_code&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">optional_values_not_read</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dft_code</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Warning: old h5 archive without dft_code input flag detected. Please specify sumk.dft_code manually!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span> <span class="o">=</span> <span class="n">Symmetry</span><span class="p">(</span><span class="n">hdf_file</span><span class="p">,</span> <span class="n">subgroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_field</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.000001</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s2">&quot;For SO, the external magnetic field is not implemented, setting it to 0!&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;ud&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Convert spin_block_names to indices -- if spin polarized,</span>
            <span class="c1"># differentiate up and down blocks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{}]</span>
            <span class="k">for</span> <span class="n">iso</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># SO = 0 or 1</span>
                <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="n">iso</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="n">iso</span><span class="p">][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="n">iso</span><span class="p">][</span><span class="n">isp</span><span class="p">]]</span> <span class="o">=</span> <span class="n">isp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span>

            <span class="c1"># GF structure used for the local things in the k sums</span>
            <span class="c1"># Most general form allowing for all hybridisation, i.e. largest</span>
            <span class="c1"># blocks possible</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">])</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]]</span>
                                   <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="c1"># First set a standard gf_struct solver (add _0 here for consistency with analyse_block_structure):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">([(</span><span class="n">sp</span><span class="o">+</span><span class="s1">&#39;_0&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">])</span>
                                           <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]])</span>
                                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="c1"># Set standard (identity) maps from gf_struct_sumk &lt;-&gt;</span>
            <span class="c1"># gf_struct_solver</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="p">[{}</span>
                                         <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner_dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="o">+</span><span class="s1">&#39;_0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
                    <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">inner_dim</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="o">+</span><span class="s1">&#39;_0&#39;</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="p">(</span><span class="n">block</span><span class="o">+</span><span class="s1">&#39;_0&#39;</span><span class="p">,</span> <span class="n">inner</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span>
            <span class="c1"># assume no shells are degenerate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># initialise mu</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_dc</span><span class="p">()</span>  <span class="c1"># initialise the double counting</span>

            <span class="c1"># charge mixing parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_mixing</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># defaults from PRB 90 235103 (&quot;... slow but stable convergence ...&quot;)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_mixing_alpha</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_mixing_gamma</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deltaNOld</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Analyse the block structure and determine the smallest gf_struct</span>
            <span class="c1"># blocks and maps, if desired</span>
            <span class="k">if</span> <span class="n">use_dft_blocks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analyse_block_structure</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">min_band_energy</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_band_energy</span> <span class="o">=</span> <span class="kc">None</span></div>


<span class="c1">################</span>
<span class="c1"># hdf5 FUNCTIONS</span>
<span class="c1">################</span>

<div class="viewcode-block" id="SumkDFT.read_input_from_hdf">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.read_input_from_hdf.html#triqs_dft_tools.sumk_dft.SumkDFT.read_input_from_hdf">[docs]</a>
    <span class="k">def</span> <span class="nf">read_input_from_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgrp</span><span class="p">,</span> <span class="n">things_to_read</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads data from the HDF file. Prints a warning if a requested dataset is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subgrp : string</span>
<span class="sd">                 Name of hdf5 file subgroup from which the data are to be read.</span>
<span class="sd">        things_to_read : list of strings</span>
<span class="sd">                         List of datasets to be read from the hdf5 file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subgroup_present : boolean</span>
<span class="sd">                           Is the subgrp is present in hdf5 file?</span>
<span class="sd">        values_not_read : list of strings</span>
<span class="sd">                           List of things that could not be read</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">values_not_read</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># initialise variables on all nodes to ensure mpi broadcast works at</span>
        <span class="c1"># the end</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">subgroup_present</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
                    <span class="n">subgroup_present</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># first read the necessary things:</span>
                    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">]:</span>
                            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">values_not_read</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">things_to_read</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s2">&quot;Loading failed: No </span><span class="si">%s</span><span class="s2"> subgroup in hdf5!&quot;</span> <span class="o">%</span> <span class="n">subgrp</span><span class="p">)</span>
                    <span class="n">subgroup_present</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">values_not_read</span> <span class="o">=</span> <span class="n">things_to_read</span>

        <span class="c1"># now do the broadcasting:</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)))</span>
        <span class="n">subgroup_present</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">subgroup_present</span><span class="p">)</span>
        <span class="n">values_not_read</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">values_not_read</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">subgroup_present</span><span class="p">,</span> <span class="n">values_not_read</span></div>


<div class="viewcode-block" id="SumkDFT.save">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.save.html#triqs_dft_tools.sumk_dft.SumkDFT.save">[docs]</a>
    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">things_to_save</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s1">&#39;user_data&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves data from a list into the HDF file. Prints a warning if a requested data is not found in SumkDFT object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        things_to_save : list of strings</span>
<span class="sd">                         List of datasets to be saved into the hdf5 file.</span>
<span class="sd">        subgrp : string, optional</span>
<span class="sd">                 Name of hdf5 file subgroup in which the data are to be stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>  <span class="c1"># do nothing on nodes</span>
        <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span> <span class="n">ar</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_save</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="p">[</span> <span class="s2">&quot;gf_struct_sumk&quot;</span><span class="p">,</span> <span class="s2">&quot;gf_struct_solver&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;solver_to_sumk&quot;</span><span class="p">,</span> <span class="s2">&quot;sumk_to_solver&quot;</span><span class="p">,</span> <span class="s2">&quot;solver_to_sumk_block&quot;</span><span class="p">]:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;It is not recommended to save &#39;</span><span class="si">{}</span><span class="s2">&#39; individually. Save &#39;block_structure&#39; instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> not found, and so not saved.&quot;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span></div>


<div class="viewcode-block" id="SumkDFT.load">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.load.html#triqs_dft_tools.sumk_dft.SumkDFT.load">[docs]</a>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">things_to_load</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s1">&#39;user_data&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads user data from the HDF file. Raises an exeption if a requested dataset is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        things_to_read : list of strings</span>
<span class="sd">                         List of datasets to be read from the hdf5 file.</span>
<span class="sd">        subgrp : string, optional</span>
<span class="sd">                 Name of hdf5 file subgroup from which the data are to be read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list_to_return : list</span>
<span class="sd">                         A list containing data read from hdf5.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>  <span class="c1"># do nothing on nodes</span>
        <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Loading </span><span class="si">%s</span><span class="s2"> failed!&quot;</span> <span class="o">%</span> <span class="n">subgrp</span><span class="p">)</span>
            <span class="n">list_to_return</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_load</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">list_to_return</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">])</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;load: </span><span class="si">%s</span><span class="s2"> not found, and so not loaded.&quot;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_to_return</span></div>


<span class="c1">################</span>
<span class="c1"># CORE FUNCTIONS</span>
<span class="c1">################</span>

<div class="viewcode-block" id="SumkDFT.downfold">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.downfold.html#triqs_dft_tools.sumk_dft.SumkDFT.downfold">[docs]</a>
    <span class="k">def</span> <span class="nf">downfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf_to_downfold</span><span class="p">,</span> <span class="n">gf_inp</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downfolds a block of the Green&#39;s function for a given shell and k-point using the corresponding projector matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index for which the downfolding is to be done.</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be downfolded.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        bname : string</span>
<span class="sd">                Block name of the target block of the lattice Green&#39;s function.</span>
<span class="sd">        gf_to_downfold : Gf</span>
<span class="sd">                       Block of the Green&#39;s function that is to be downfolded.</span>
<span class="sd">        gf_inp : Gf</span>
<span class="sd">                 FIXME</span>
<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: orthonormalized projectors for correlated shells are used for the downfolding.</span>
<span class="sd">                 - if shells=&#39;all&#39;: non-normalized projectors for all included shells are used for the downfolding.</span>
<span class="sd">                 - if shells=&#39;csc&#39;: orthonormalized projectors for all shells are used for the downfolding. Used for H(k).</span>

<span class="sd">        ir : integer, optional</span>
<span class="sd">             Index of equivalent site in the non-correlated shell &#39;ish&#39;, only used if shells=&#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_downfolded : Gf</span>
<span class="sd">                      Downfolded block of the lattice Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf_downfolded</span> <span class="o">=</span> <span class="n">gf_inp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get spin index for proj. matrices</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;downfold: provide ir if treating all shells.&quot;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_all</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;csc&#39;</span><span class="p">:</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_csc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>

        <span class="n">gf_downfolded</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span>
            <span class="n">projmat</span><span class="p">,</span> <span class="n">gf_to_downfold</span><span class="p">,</span> <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">gf_downfolded</span></div>


<div class="viewcode-block" id="SumkDFT.upfold">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.upfold.html#triqs_dft_tools.sumk_dft.SumkDFT.upfold">[docs]</a>
    <span class="k">def</span> <span class="nf">upfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf_to_upfold</span><span class="p">,</span> <span class="n">gf_inp</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Upfolds a block of the Green&#39;s function for a given shell and k-point using the corresponding projector matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index for which the upfolding is to be done.</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be upfolded.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        bname : string</span>
<span class="sd">                Block name of the target block of the lattice Green&#39;s function.</span>
<span class="sd">        gf_to_upfold : Gf</span>
<span class="sd">                       Block of the Green&#39;s function that is to be upfolded.</span>
<span class="sd">        gf_inp : Gf</span>
<span class="sd">                 FIXME</span>
<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: orthonormalized projectors for correlated shells are used for the upfolding.</span>
<span class="sd">                 - if shells=&#39;all&#39;: non-normalized projectors for all included shells are used for the upfolding.</span>
<span class="sd">                 - if shells=&#39;csc&#39;: orthonormalized projectors for all shells are used for the upfolding. Used for H(k).</span>

<span class="sd">        ir : integer, optional</span>
<span class="sd">             Index of equivalent site in the non-correlated shell &#39;ish&#39;, only used if shells=&#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_upfolded : Gf</span>
<span class="sd">                      Upfolded block of the lattice Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf_upfolded</span> <span class="o">=</span> <span class="n">gf_inp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get spin index for proj. matrices</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;upfold: provide ir if treating all shells.&quot;</span><span class="p">)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_all</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;csc&#39;</span><span class="p">:</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_csc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>

        <span class="n">gf_upfolded</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span>
            <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_to_upfold</span><span class="p">,</span> <span class="n">projmat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gf_upfolded</span></div>


<div class="viewcode-block" id="SumkDFT.rotloc">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.rotloc.html#triqs_dft_tools.sumk_dft.SumkDFT.rotloc">[docs]</a>
    <span class="k">def</span> <span class="nf">rotloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">gf_to_rotate</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates a block of the local Green&#39;s function from the local frame to the global frame and vice versa.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be rotated.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        gf_to_rotate : Gf</span>
<span class="sd">                       Block of the Green&#39;s function that is to be rotated.</span>
<span class="sd">        direction : string</span>
<span class="sd">                    The direction of rotation can be either</span>

<span class="sd">                    - &#39;toLocal&#39; : global -&gt; local transformation,</span>
<span class="sd">                    - &#39;toGlobal&#39; : local -&gt; global transformation.</span>

<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: the rotation matrix for the correlated shell &#39;ish&#39; is used,</span>
<span class="sd">                 - if shells=&#39;all&#39;: the rotation matrix for the generic (non-correlated) shell &#39;ish&#39; is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_rotated : Gf</span>
<span class="sd">                     Rotated block of the local Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">((</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toLocal&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toGlobal&#39;</span><span class="p">)</span>
                <span class="p">),</span> <span class="s2">&quot;rotloc: Give direction &#39;toLocal&#39; or &#39;toGlobal&#39;.&quot;</span>
        <span class="n">gf_rotated</span> <span class="o">=</span> <span class="n">gf_to_rotate</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">rot_mat_time_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">rot_mat_time_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_all_time_inv</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_all</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toGlobal&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">:</span>
                <span class="n">gf_rotated</span> <span class="o">&lt;&lt;</span> <span class="n">gf_rotated</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                <span class="p">),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span>
                                      <span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toLocal&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">:</span>
                <span class="n">gf_rotated</span> <span class="o">&lt;&lt;</span> <span class="n">gf_rotated</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="p">),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">gf_rotated</span></div>


<div class="viewcode-block" id="SumkDFT.lattice_gf">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.lattice_gf.html#triqs_dft_tools.sumk_dft.SumkDFT.lattice_gf">[docs]</a>
    <span class="k">def</span> <span class="nf">lattice_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the lattice Green function for a given k-point from the DFT Hamiltonian and the self energy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index.</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">             Chemical potential for which the Green&#39;s function is to be calculated.</span>
<span class="sd">             If not provided, self.chemical_potential is used for mu.</span>
<span class="sd">        broadening : real, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">        mesh : MeshReFreq or MeshImFreq, optional</span>
<span class="sd">                    Mesh to be used if with_Sigma=False. If with Sigma=False and mesh is none then self.mesh is used.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True the GF will be calculated with the self-energy stored in self.Sigmaimp_(w/iw), for real/Matsubara GF, respectively.</span>
<span class="sd">                     In this case the mesh is taken from the self.Sigma_imp object.</span>
<span class="sd">                     If with_Sigma=True but self.Sigmaimp_(w/iw) is not present, with_Sigma is reset to False.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  if True and with_Sigma=True, the dc correction is substracted from the self-energy before it is included into GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_latt : BlockGf</span>
<span class="sd">                 Lattice Green&#39;s function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp&quot;</span><span class="p">):</span>
            <span class="n">with_Sigma</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">broadening</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># broadening = 2 * \Delta omega, where \Delta omega is the spacing of omega points</span>
                <span class="n">broadening</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">((</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_max</span> <span class="o">-</span> <span class="n">mesh</span><span class="o">.</span><span class="n">w_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Check if G_latt is present</span>
        <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="kc">False</span>                       <span class="c1"># Assume not</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_latt&quot;</span> <span class="p">):</span>
            <span class="c1"># Need to create G_latt_(i)w</span>
            <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>                                       <span class="c1"># Check that existing GF is consistent</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">G_latt</span>
            <span class="n">GFsize</span> <span class="o">=</span> <span class="p">[</span><span class="n">gf</span><span class="o">.</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">]</span>
            <span class="n">unchangedsize</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">]]]</span> <span class="o">==</span> <span class="n">GFsize</span><span class="p">[</span>
                                <span class="n">isp</span><span class="p">]</span> <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">])])</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">unchangedsize</span><span class="p">):</span>
                <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Are we including Sigma?</span>
        <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
            <span class="n">Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span>
            <span class="k">if</span> <span class="n">with_dc</span><span class="p">:</span>
                <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_dc</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;lattice_gf called with Sigma and given mesh. Mesh will be taken from Sigma.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">!=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                    <span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">first_index</span><span class="p">()),</span> <span class="n">mesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">last_index</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_min</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">w_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
                <span class="n">mesh_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_values</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">),</span>  <span class="s2">&quot;mesh must be a triqs MeshReFreq or MeshImFreq&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                <span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">mesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">first_index</span><span class="p">()),</span> <span class="n">mesh</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">last_index</span><span class="p">()),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_min</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">w_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
            <span class="n">mesh_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh_values</span>

        <span class="c1"># Set up G_latt</span>
        <span class="k">if</span> <span class="n">set_up_G_latt</span><span class="p">:</span>
            <span class="n">block_structure</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
            <span class="n">gf_struct</span> <span class="o">=</span> <span class="p">[(</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">],</span> <span class="n">block_structure</span><span class="p">[</span><span class="n">isp</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">])]</span>
            <span class="n">block_ind_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">Gf</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">target_shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)])</span>
                                 <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">Gf</span><span class="p">(</span><span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">target_shape</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)])</span>
                                 <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_list</span><span class="o">=</span><span class="n">block_ind_list</span><span class="p">,</span>
                             <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">(),</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">G_latt</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="n">idmat</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="nb">complex</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>

        <span class="c1"># fill Glatt</span>
        <span class="k">for</span> <span class="n">ibl</span><span class="p">,</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">gf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G_latt</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">ibl</span><span class="p">]]</span>
            <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idmat</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">mesh_values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">ibl</span><span class="p">))</span>
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">idmat</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">*</span>
                                    <span class="p">(</span><span class="n">mesh_values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">ibl</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">broadening</span><span class="p">)</span>
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                    <span class="n">gf</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
                                      <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">block</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>

        <span class="n">G_latt</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G_latt</span> <span class="o">=</span> <span class="n">G_latt</span>

        <span class="k">return</span> <span class="n">G_latt</span></div>


<div class="viewcode-block" id="SumkDFT.set_Sigma">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.set_Sigma.html#triqs_dft_tools.sumk_dft.SumkDFT.set_Sigma">[docs]</a>
    <span class="k">def</span> <span class="nf">set_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">,</span> <span class="n">transform_to_sumk_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put_Sigma</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">,</span> <span class="n">transform_to_sumk_blocks</span><span class="p">)</span></div>


<div class="viewcode-block" id="SumkDFT.put_Sigma">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.put_Sigma.html#triqs_dft_tools.sumk_dft.SumkDFT.put_Sigma">[docs]</a>
    <span class="k">def</span> <span class="nf">put_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">,</span> <span class="n">transform_to_sumk_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert the impurity self-energies into the sumk_dft class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Sigma_imp : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">            List containing impurity self-energy for all (inequivalent) correlated shells.</span>
<span class="sd">            Self-energies for equivalent shells are then automatically set by this function.</span>
<span class="sd">            The self-energies can be of the real or imaginary-frequency type.</span>
<span class="sd">        transform_to_sumk_blocks : bool, optional</span>
<span class="sd">            If True (default), the input Sigma_imp will be transformed to the block structure ``gf_struct_sumk``,</span>
<span class="sd">            else it has to be given in ``gf_struct_sumk``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">transform_to_sumk_blocks</span><span class="p">:</span>
            <span class="n">Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_to_sumk_blocks</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>\
            <span class="s2">&quot;put_Sigma: Sigma_imp has to be a list of Sigmas for the correlated shells, even if it is of length 1!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">,</span>\
            <span class="s2">&quot;put_Sigma: give exactly one Sigma for each corr. shell!&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gf</span><span class="p">,</span> <span class="n">Gf</span><span class="p">)</span> <span class="ow">and</span> <span class="n">gf</span><span class="o">.</span><span class="n">mesh</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Imaginary frequency Sigma:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">create_gf</span><span class="p">(</span><span class="n">ish</span><span class="o">=</span><span class="n">icrsh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="n">SK_Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">gf</span><span class="p">,</span> <span class="n">Gf</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">)</span> <span class="ow">and</span> <span class="n">gf</span><span class="o">.</span><span class="n">mesh</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Real frequency Sigma:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">create_gf</span><span class="p">(</span><span class="n">ish</span><span class="o">=</span><span class="n">icrsh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">gf_function</span><span class="o">=</span><span class="n">Gf</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="n">SK_Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;put_Sigma: Sigma_imp must have the same mesh as SumKDFT.mesh.&quot;</span><span class="p">)</span>

        <span class="c1"># rotation from local to global coordinate system:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">SK_Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                    <span class="n">gf</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span><span class="n">icrsh</span><span class="p">,</span>
                                      <span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">],</span>
                                      <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toGlobal&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gf</span> <span class="o">&lt;&lt;</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>

        <span class="c1">#warning if real frequency self energy is within the bounds of the band energies</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_band_energy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_band_energy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">calculate_min_max_band_energies</span><span class="p">()</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">w_max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_band_energy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">)</span> <span class="ow">or</span> <span class="n">mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_band_energy</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The given Sigma is on a mesh which does not cover the band energy range. The Sigma MeshReFreq runs from </span><span class="si">%f</span><span class="s1"> to </span><span class="si">%f</span><span class="s1">, while the band energy (minus the chemical potential) runs from </span><span class="si">%f</span><span class="s1"> to </span><span class="si">%f</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_band_energy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_band_energy</span><span class="p">))</span></div>


<div class="viewcode-block" id="SumkDFT.transform_to_sumk_blocks">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.transform_to_sumk_blocks.html#triqs_dft_tools.sumk_dft.SumkDFT.transform_to_sumk_blocks">[docs]</a>
    <span class="k">def</span> <span class="nf">transform_to_sumk_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">,</span> <span class="n">Sigma_out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; transform Sigma from solver to sumk space</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Sigma_imp : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">            List containing impurity self-energy for all inequivalent correlated shells.</span>
<span class="sd">            The self-energies can be of the real or imaginary-frequency type.</span>
<span class="sd">        Sigma_out : list of BlockGf</span>
<span class="sd">            list of one BlockGf per correlated shell with the block structure</span>
<span class="sd">            according to ``gf_struct_sumk``; if None, it will be created</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>\
            <span class="s2">&quot;transform_to_sumk_blocks: Sigma_imp has to be a list of Sigmas for the inequivalent correlated shells, even if it is of length 1!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">,</span>\
            <span class="s2">&quot;transform_to_sumk_blocks: give exactly one Sigma for each inequivalent corr. shell!&quot;</span>

        <span class="k">if</span> <span class="n">Sigma_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Sigma_out</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">create_gf</span><span class="p">(</span><span class="n">ish</span><span class="o">=</span><span class="n">icrsh</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]]</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">check_gf</span><span class="p">(</span><span class="n">Sigma_out</span><span class="p">,</span>
                                              <span class="n">ish</span><span class="o">=</span><span class="n">icrsh</span><span class="p">,</span>
                                              <span class="n">space</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">)</span>

        <span class="c1"># transform the CTQMC blocks to the full matrix:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="c1"># ish is the index of the inequivalent shell corresponding to icrsh</span>
            <span class="n">ish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span>
                <span class="n">G</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span>
                <span class="n">G_struct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">,</span>
                <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span>
                <span class="n">ish_from</span><span class="o">=</span><span class="n">ish</span><span class="p">,</span>
                <span class="n">ish_to</span><span class="o">=</span><span class="n">icrsh</span><span class="p">,</span>
                <span class="n">G_out</span><span class="o">=</span><span class="n">Sigma_out</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Sigma_out</span></div>


<div class="viewcode-block" id="SumkDFT.extract_G_loc">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.extract_G_loc.html#triqs_dft_tools.sumk_dft.SumkDFT.extract_G_loc">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_G_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">transform_to_solver_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts the local downfolded Green function by the Brillouin-zone integration of the lattice Green&#39;s function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">            Input chemical potential. If not provided the value of self.chemical_potential is used as mu.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">            If True then the local GF is calculated with the self-energy self.Sigma_imp.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">            If True then the double-counting correction is subtracted from the self-energy in calculating the GF.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">            Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">            If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">            Only relevant for real-frequency GF.</span>
<span class="sd">        transform_to_solver_blocks : bool, optional</span>
<span class="sd">            If True (default), the returned G_loc will be transformed to the block structure ``gf_struct_solver``,</span>
<span class="sd">            else it will be in ``gf_struct_sumk``.</span>
<span class="sd">        show_warnings : bool, optional</span>
<span class="sd">            Displays warning messages during transformation</span>
<span class="sd">            (Only effective if transform_to_solver_blocks = True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_loc : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">            List of the local Green&#39;s functions for all (inequivalent) correlated shells,</span>
<span class="sd">            rotated into the corresponding local frames.</span>
<span class="sd">            If ``transform_to_solver_blocks`` is True, it will be one per inequivalent correlated shell, else one per</span>
<span class="sd">            correlated shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>

        <span class="k">if</span> <span class="n">with_Sigma</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp&quot;</span><span class="p">):</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;self.mesh and self.Sigma_imp[0].mesh are differen! Using mesh from Sigma&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">with_Sigma</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp&quot;</span><span class="p">):</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Warning: No Sigma set but parameter with_Sigma=True, calculating Gloc without Sigma.&#39;</span><span class="p">)</span>
            <span class="n">with_Sigma</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span>

        <span class="c1"># create G_loc to be returned in sumk space for all correlated shells. Trafo to solver block structure done later</span>
        <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">create_gf</span><span class="p">(</span><span class="n">ish</span><span class="o">=</span><span class="n">ish</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
            <span class="n">G_latt</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="c1"># init temporary storage</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">gf</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>

        <span class="c1"># Collect data from mpi</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># G_loc[:] is now the sum over k projected to the local orbitals.</span>
        <span class="c1"># here comes the symmetrisation, if needed:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">G_loc</span><span class="p">)</span>

        <span class="c1"># G_loc is rotated to the local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                        <span class="n">icrsh</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toLocal&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">transform_to_solver_blocks</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_to_solver_blocks</span><span class="p">(</span><span class="n">G_loc</span><span class="p">,</span> <span class="n">show_warnings</span><span class="o">=</span><span class="n">show_warnings</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G_loc</span></div>


<div class="viewcode-block" id="SumkDFT.transform_to_solver_blocks">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.transform_to_solver_blocks.html#triqs_dft_tools.sumk_dft.SumkDFT.transform_to_solver_blocks">[docs]</a>
    <span class="k">def</span> <span class="nf">transform_to_solver_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G_loc</span><span class="p">,</span> <span class="n">G_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_warnings</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; transform G_loc from sumk to solver space</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G_loc : list of BlockGf</span>
<span class="sd">            a list of one BlockGf per correlated shell with a structure</span>
<span class="sd">            according to ``gf_struct_sumk``, e.g. as returned by</span>
<span class="sd">            :py:meth:`.extract_G_loc` with ``transform_to_solver_blocks=False``.</span>
<span class="sd">        G_out : list of BlockGf</span>
<span class="sd">            a list of one BlockGf per *inequivalent* correlated shell</span>
<span class="sd">            with a structure according to ``gf_struct_solver``.</span>
<span class="sd">            The output Green&#39;s function (if not given, a new one is</span>
<span class="sd">            created)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_out</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G_loc</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;G_loc must be a list (with elements for each correlated shell)&quot;</span>

        <span class="k">if</span> <span class="n">G_out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">G_out</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">create_gf</span><span class="p">(</span><span class="n">ish</span><span class="o">=</span><span class="n">ish</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">G_loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">check_gf</span><span class="p">(</span><span class="n">G_out</span><span class="p">,</span> <span class="n">ish</span><span class="o">=</span><span class="n">ish</span><span class="p">)</span>

        <span class="c1"># transform to CTQMC blocks:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span>
                <span class="n">G</span><span class="o">=</span><span class="n">G_loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]],</span>
                <span class="n">G_struct</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">ish_from</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span>
                <span class="n">ish_to</span><span class="o">=</span><span class="n">ish</span><span class="p">,</span>
                <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span>
                <span class="n">G_out</span><span class="o">=</span><span class="n">G_out</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span>
                <span class="n">show_warnings</span> <span class="o">=</span> <span class="n">show_warnings</span><span class="p">)</span>

        <span class="c1"># return only the inequivalent shells:</span>
        <span class="k">return</span> <span class="n">G_out</span></div>


<div class="viewcode-block" id="SumkDFT.analyse_block_structure">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.analyse_block_structure.html#triqs_dft_tools.sumk_dft.SumkDFT.analyse_block_structure">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hloc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the block structure of local Green&#39;s functions by analysing the structure of</span>
<span class="sd">        the corresponding density matrices and the local Hamiltonian. The resulting block structures</span>
<span class="sd">        for correlated shells are stored in the :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between density matrix / hloc elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of inequivalent shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all inequivalent shells will be analysed.</span>
<span class="sd">        dm : list of dict, optional</span>
<span class="sd">             List of density matrices from which block stuctures are to be analysed.</span>
<span class="sd">             Each density matrix is a dict {block names: 2d numpy arrays} for each correlated shell.</span>
<span class="sd">             If not provided, dm will be calculated from the DFT Hamiltonian by a simple-point BZ integration.</span>
<span class="sd">        hloc : list of dict, optional</span>
<span class="sd">               List of local Hamiltonian matrices from which block stuctures are to be analysed</span>
<span class="sd">               Each Hamiltonian is a dict {block names: 2d numpy arrays} for each inequivalent shell.</span>
<span class="sd">               If not provided, it will be calculated using eff_atomic_levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: No density matrix given. Calculating density matrix with default parameters. This will be deprecated in future releases.&quot;</span><span class="p">)</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_matrix</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;using_gf&#39;</span><span class="p">,</span> <span class="n">transform_to_solver_blocks</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">,</span> <span class="s2">&quot;The number of density matrices must be equal to the number of correlated shells.&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">dm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">hloc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff_atomic_levels</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="k">assert</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;The density matrix does not contain the block </span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">. Is the input dm given in sumk block structure?&quot;</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="c1"># gives an index list of entries larger that threshold</span>
                <span class="n">dmbool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
                <span class="n">hlocbool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">hloc</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

                <span class="c1"># Determine off-diagonal entries in upper triangular part of</span>
                <span class="c1"># density matrix</span>
                <span class="n">offdiag</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">dmbool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hlocbool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="n">offdiag</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Determine the number of non-hybridising blocks in the gf</span>
                <span class="n">blocs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offdiag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pair</span> <span class="o">=</span> <span class="n">offdiag</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">blocs</span><span class="p">,</span> <span class="n">blocs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>     <span class="c1"># In separate blocks?</span>
                                <span class="c1"># Merge two blocks</span>
                                <span class="n">b1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">)))</span>
                                <span class="k">break</span>                                  <span class="c1"># Move on to next pair in offdiag</span>

                <span class="c1"># Set the gf_struct for the solver accordingly</span>
                <span class="n">num_blocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]))])</span>

                <span class="c1"># Construct sumk_to_solver taking (sumk_block, sumk_index) --&gt; (solver_block, solver_inner)</span>
                <span class="c1"># and solver_to_sumk taking (solver_block, solver_inner) --&gt;</span>
                <span class="c1"># (sumk_block, sumk_index)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">block_sumk</span> <span class="o">=</span> <span class="n">sp</span>
                        <span class="n">inner_sumk</span> <span class="o">=</span> <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">block_solv</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">inner_solv</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block_solv</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sumk</span>

            <span class="c1"># Now calculate degeneracies of orbitals</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">block_dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># get dm for the blocks:</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">block_dim</span><span class="p">,</span> <span class="n">block_dim</span><span class="p">],</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_dim</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block_dim</span><span class="p">):</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">dm</span><span class="p">[</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="n">block_sumk</span><span class="p">][</span><span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">block1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">block2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">dm</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">dm</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">dm</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dm</span><span class="p">[</span><span class="n">block2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">block1</span> <span class="o">!=</span> <span class="n">block2</span><span class="p">):</span>
                            <span class="n">ind1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="n">ind2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                            <span class="c1"># check if it was already there:</span>
                            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                                <span class="k">if</span> <span class="n">block1</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">n</span>
                                <span class="k">if</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                                    <span class="n">ind2</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block1</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block2</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span><span class="p">])</span></div>


    <span class="k">def</span> <span class="nf">_get_hermitian_quantity_from_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert G to a Hermitian quantity</span>

<span class="sd">        For G(tau) and G(iw), G(tau) is returned.</span>
<span class="sd">        For G(t) and G(w), the spectral function is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : list of BlockGf of GfImFreq, GfImTime, GfReFreq or GfReTime</span>
<span class="sd">            the input Green&#39;s function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf : list of BlockGf of GfImTime or GfReFreq</span>
<span class="sd">            the output G(tau) or A(w)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a GfImTime from the supplied GfImFreq</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">GfImTime</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
                <span class="n">indices</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span><span class="n">n_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">g_sh</span><span class="p">],</span>
                <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">set_from_fourier</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
        <span class="c1"># keep a GfImTime from the supplied GfImTime</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImTime</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="n">G</span>
        <span class="c1"># make a spectral function from the supplied GfReFreq</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="p">[</span><span class="n">g_sh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">g</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReTime</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">get_delta_from_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">w0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">w0</span> <span class="o">=</span> <span class="n">w</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">w</span><span class="o">-</span><span class="n">w0</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span>
                <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">get_delta_from_mesh</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">get_delta_from_mesh</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">))),</span>
                <span class="n">n_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">),</span> <span class="n">indices</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">g_sh</span><span class="p">],</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">set_from_fourier</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">g</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;G must be a list of BlockGf of either GfImFreq, GfImTime, GfReFreq or GfReTime&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gf</span>



<div class="viewcode-block" id="SumkDFT.analyse_block_structure_from_gf">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.analyse_block_structure_from_gf.html#triqs_dft_tools.sumk_dft.SumkDFT.analyse_block_structure_from_gf">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse_block_structure_from_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">analyse_deg_shells</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the block structure of local Green&#39;s functions by analysing</span>
<span class="sd">        the structure of the corresponding non-interacting Green&#39;s function.</span>
<span class="sd">        The resulting block structures for correlated shells are</span>
<span class="sd">        stored in the :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;`</span>
<span class="sd">        attribute.</span>

<span class="sd">        This is a safer alternative to analyse_block_structure, because</span>
<span class="sd">        the full non-interacting Green&#39;s function is taken into account</span>
<span class="sd">        and not just the density matrix and Hloc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : list of BlockGf of GfImFreq, GfImTime, GfReFreq or GfReTime</span>
<span class="sd">            the non-interacting Green&#39;s function for each inequivalent correlated shell</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between matrix elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of inequivalent shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all inequivalent shells will be analysed.</span>
<span class="sd">        analyse_deg_shells : bool</span>
<span class="sd">                             Whether to call the analyse_deg_shells function</span>
<span class="sd">                             after having finished the block structure analysis</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : list of BlockGf of GfImFreq or GfImTime</span>
<span class="sd">            the Green&#39;s function transformed into the new block structure</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;G must be a list (with elements for each correlated shell)&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">,</span> <span class="s2">&quot;G must have one element for each correlated shell, run extract_G_loc with transform_to_solver_blocks=False to get the correct G&quot;</span>

        <span class="n">gf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hermitian_quantity_from_gf</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># include all shells</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="k">assert</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;The Green&#39;s function does not contain the block </span><span class="si">{</span><span class="n">sp</span><span class="si">}</span><span class="s2">. Is the input G given in sumk block structure?&quot;</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>

                <span class="c1"># gives an index list of entries larger that threshold</span>
                <span class="n">max_gf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">maxgf_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_gf</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

                <span class="c1"># Determine off-diagonal entries in upper triangular part of the</span>
                <span class="c1"># Green&#39;s function</span>
                <span class="n">offdiag</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">maxgf_bool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="n">offdiag</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Determine the number of non-hybridising blocks in the gf</span>
                <span class="n">blocs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offdiag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pair</span> <span class="o">=</span> <span class="n">offdiag</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">blocs</span><span class="p">,</span> <span class="n">blocs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>     <span class="c1"># In separate blocks?</span>
                                <span class="c1"># Merge two blocks</span>
                                <span class="n">b1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">)))</span>
                                <span class="k">break</span>                                  <span class="c1"># Move on to next pair in offdiag</span>

                <span class="c1"># Set the gf_struct for the solver accordingly</span>
                <span class="n">num_blocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]))])</span>

                <span class="c1"># Construct sumk_to_solver taking (sumk_block, sumk_index) --&gt; (solver_block, solver_inner)</span>
                <span class="c1"># and solver_to_sumk taking (solver_block, solver_inner) --&gt;</span>
                <span class="c1"># (sumk_block, sumk_index)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">block_sumk</span> <span class="o">=</span> <span class="n">sp</span>
                        <span class="n">inner_sumk</span> <span class="o">=</span> <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">block_solv</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">inner_solv</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block_solv</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sumk</span>

        <span class="c1"># transform G to the new structure</span>
        <span class="n">full_structure</span> <span class="o">=</span> <span class="n">BlockStructure</span><span class="o">.</span><span class="n">full_structure</span><span class="p">(</span>
            <span class="p">[{</span><span class="n">sp</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]}</span>
                <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)],</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">)</span>
        <span class="n">G_transformed</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span>
                <span class="n">full_structure</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">show_warnings</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                <span class="n">gf_function</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">_first</span><span class="p">()),</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">analyse_deg_shells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyse_deg_shells</span><span class="p">(</span><span class="n">G_transformed</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">include_shells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G_transformed</span></div>


<div class="viewcode-block" id="SumkDFT.analyse_deg_shells">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.analyse_deg_shells.html#triqs_dft_tools.sumk_dft.SumkDFT.analyse_deg_shells">[docs]</a>
    <span class="k">def</span> <span class="nf">analyse_deg_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the degenerate shells of local Green&#39;s functions by analysing</span>
<span class="sd">        the structure of the corresponding non-interacting Green&#39;s function.</span>
<span class="sd">        The results are stored in the</span>
<span class="sd">        :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;`</span>
<span class="sd">        attribute.</span>

<span class="sd">        Due to the implementation and numerics, the maximum difference between</span>
<span class="sd">        two matrix elements that are detected as equal can be a bit higher</span>
<span class="sd">        (e.g. a factor of two) than the actual threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : list of BlockGf of GfImFreq or GfImTime</span>
<span class="sd">            the non-interacting Green&#39;s function for each inequivalent correlated shell</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between matrix elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of correlated shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all correlated shells will be analysed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="c1"># helper function</span>
        <span class="k">def</span> <span class="nf">null</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Calculate the null-space of matrix A &quot;&quot;&quot;</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">null_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">null_space</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">null_mask</span><span class="p">,</span> <span class="n">vh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">null_space</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">gf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hermitian_quantity_from_gf</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># include all shells</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">))</span>

        <span class="c1"># We consider two blocks equal, if their Green&#39;s functions obey</span>
        <span class="c1"># maybe_conjugate1( v1^dagger G1 v1 ) = maybe_conjugate2( v2^dagger G2 v2 )</span>
        <span class="c1"># where maybe_conjugate is a function that conjugates the Green&#39;s</span>
        <span class="c1"># function if the flag &#39;conjugate&#39; is set and the v are unitary</span>
        <span class="c1"># matrices</span>
        <span class="c1">#</span>
        <span class="c1"># for each pair of blocks, we check whether there is a transformation</span>
        <span class="c1"># maybe_conjugate( T G1 T^dagger ) = G2</span>
        <span class="c1"># where our goal is to find T</span>
        <span class="c1"># we just try whether there is such a T with and without conjugation</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">block2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">block1</span><span class="o">==</span><span class="n">block2</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="c1"># check if the blocks are already present in the deg_shells</span>
                    <span class="n">ind1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">ind2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">block1</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                            <span class="n">ind1</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="n">v1</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                            <span class="n">ind2</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="n">v2</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span>

                    <span class="c1"># if both are already present, go to the next pair of blocks</span>
                    <span class="k">if</span> <span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">gf1</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block1</span><span class="p">]</span>
                    <span class="n">gf2</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block2</span><span class="p">]</span>

                    <span class="c1"># the two blocks have to have the same shape</span>
                    <span class="k">if</span> <span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span> <span class="o">!=</span> <span class="n">gf2</span><span class="o">.</span><span class="n">target_shape</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Instead of directly comparing the two blocks, we</span>
                    <span class="c1"># compare its eigenvalues. As G(tau) is Hermitian,</span>
                    <span class="c1"># they are real and the eigenvector matrix is unitary.</span>
                    <span class="c1"># Thus, if the eigenvalues are equal we can transform</span>
                    <span class="c1"># one block to make it equal to the other (at least</span>
                    <span class="c1"># for tau=0).</span>

                    <span class="n">e1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">e2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">):</span> <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">conjugate</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span><span class="kc">True</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                            <span class="n">gf2</span> <span class="o">=</span> <span class="n">gf2</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>

                        <span class="c1"># we want T gf1 T^dagger = gf2</span>
                        <span class="c1"># while for a given tau, T could be calculated</span>
                        <span class="c1"># by diagonalizing gf1 and gf2, this does not</span>
                        <span class="c1"># work for all taus simultaneously because of</span>
                        <span class="c1"># numerical imprecisions</span>

                        <span class="c1"># rather, we rewrite the equation to</span>
                        <span class="c1"># T gf1 = gf2 T</span>
                        <span class="c1"># which is the Sylvester equation.</span>
                        <span class="c1"># For that equation, one can use the Kronecker</span>
                        <span class="c1"># product to get a linear problem, which consists</span>
                        <span class="c1"># of finding the null space of M vec T = 0.</span>

                        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">),</span><span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">))</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="n">null</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

                        <span class="c1"># now we get the intersection of the null spaces</span>
                        <span class="c1"># of all values of tau</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
                            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">),</span><span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">))</span>
                            <span class="c1"># transform M into current null space</span>
                            <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
                            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">null</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">break</span>

                        <span class="c1"># no intersection of the null spaces -&gt; no symmetry</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

                        <span class="c1"># reshape N: it then has the indices matrix, matrix, number of basis vectors of the null space</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

<span class="w">                        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        any matrix in the null space can now be constructed as</span>
<span class="sd">                        M = 0</span>
<span class="sd">                        for i in range(N.shape[-1]):</span>
<span class="sd">                            M += y[i]*N[:,:,i]</span>
<span class="sd">                        with coefficients (complex numbers) y[i].</span>

<span class="sd">                        We want to get a set of coefficients y so that M is unitary.</span>
<span class="sd">                        Unitary means M M^dagger = 1.</span>
<span class="sd">                        Thus,</span>
<span class="sd">                            sum  y[i] N[:,:,i] y[j].conjugate() N[:,:,j].conjugate().transpose() = eye.</span>
<span class="sd">                        The object N[:,:,i] N[:,:,j] is a four-index object which we call Z.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;aci,bcj-&gt;abij&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>

<span class="w">                        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        function chi2</span>
<span class="sd">                        This function takes a real parameter vector y and reinterprets it as complex.</span>
<span class="sd">                        Then, it calculates the chi2 of</span>
<span class="sd">                            sum  y[i] N[:,:,i] y[j].conjugate() N[:,:,j].conjugate().transpose() - eye.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                            <span class="c1"># reinterpret y as complex number</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="n">ret</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()))</span>
                                                  <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
                            <span class="k">return</span> <span class="n">ret</span>

                        <span class="c1"># use the minimization routine from scipy</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                        <span class="c1"># if the minimization fails, there is probably no symmetry</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span> <span class="k">continue</span>
                        <span class="c1"># check if the minimization returned zero within the tolerance</span>
                        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">fun</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span> <span class="k">continue</span>

                        <span class="c1"># reinterpret the solution as a complex number</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span>

                        <span class="c1"># reconstruct the T matrix</span>
                        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
                            <span class="n">T</span> <span class="o">+=</span> <span class="n">N</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="c1"># transform gf1 using T</span>
                        <span class="n">G_transformed</span> <span class="o">=</span> <span class="n">gf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">G_transformed</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">gf1</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

                        <span class="c1"># it does not make sense to check the tails for an</span>
                        <span class="c1"># absolute error because it will usually not hold;</span>
                        <span class="c1"># we could just check the relative error</span>
                        <span class="c1"># (here, we ignore it, reasoning that if the data</span>
                        <span class="c1"># is the same, the tails have to coincide as well)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">assert_arrays_are_close</span><span class="p">(</span><span class="n">G_transformed</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
                            <span class="c1"># the symmetry does not hold</span>
                            <span class="k">continue</span>

                        <span class="c1"># Now that we have found a valid T, we have to</span>
                        <span class="c1"># rewrite it to match the convention that</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2),</span>
                        <span class="c1"># where C conjugates if the flag is True</span>

                        <span class="c1"># For each group of degenerate shells, the list</span>
                        <span class="c1"># SK.deg_shells[ish] contains a dict. The keys</span>
                        <span class="c1"># of the dict are the block names, the values</span>
                        <span class="c1"># are tuples. The first entry of the tuple is</span>
                        <span class="c1"># the transformation matrix v, the second entry</span>
                        <span class="c1"># is the conjugation flag</span>

                        <span class="c1"># the second block is already present</span>
                        <span class="c1"># set v1 and C1 so that they are compatible with</span>
                        <span class="c1"># C(T gf1 T^dagger) = gf2</span>
                        <span class="c1"># and with</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">][</span><span class="n">block1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()),</span> <span class="ow">not</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">][</span><span class="n">block1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># the first block is already present</span>
                        <span class="c1"># set v2 and C2 so that they are compatible with</span>
                        <span class="c1"># C(T gf1 T^dagger) = gf2</span>
                        <span class="c1"># and with</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2)</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">][</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()),</span> <span class="ow">not</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">][</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># the blocks are not already present</span>
                        <span class="c1"># we arbitrarily choose v1=eye and C1=False and</span>
                        <span class="c1"># set v2 and C2 so that they are compatible with</span>
                        <span class="c1"># C(T gf1 T^dagger) = gf2</span>
                        <span class="c1"># and with</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2)</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                            <span class="n">d</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">),</span> <span class="kc">False</span>
                            <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="kc">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="kc">False</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

                        <span class="c1"># a block was found, break out of the loop</span>
                        <span class="k">break</span></div>


<div class="viewcode-block" id="SumkDFT.calculate_diagonalization_matrix">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.calculate_diagonalization_matrix.html#triqs_dft_tools.sumk_dft.SumkDFT.calculate_diagonalization_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_diagonalization_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop_to_be_diagonal</span><span class="o">=</span><span class="s1">&#39;eal&#39;</span><span class="p">,</span> <span class="n">calc_in_solver_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">write_to_blockstructure</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the diagonalisation matrix, and (optionally) stores it in the BlockStructure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prop_to_be_diagonal : string, optional</span>
<span class="sd">                              Defines the property to be diagonalized.</span>

<span class="sd">                              - &#39;eal&#39; : local hamiltonian (i.e. crystal field)</span>
<span class="sd">                              - &#39;dm&#39; : local density matrix</span>

<span class="sd">        calc_in_solver_blocks : bool, optional</span>
<span class="sd">                                Whether the property shall be diagonalized in the</span>
<span class="sd">                                full sumk structure, or just in the solver structure.</span>

<span class="sd">        write_to_blockstructure : bool, optional</span>
<span class="sd">                                Whether the diagonalization matrix shall be written to</span>
<span class="sd">                                the BlockStructure directly.</span>
<span class="sd">        shells : list of int, optional</span>
<span class="sd">              Indices of correlated shells to be diagonalized.</span>
<span class="sd">              None: all shells</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        trafo : dict</span>
<span class="sd">               The transformation matrix for each spin-block in the correlated shell</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">transformation</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s2">&quot;calculate_diagonalization_matrix: requires block_structure.transformation = None.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># Use all shells</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">shells</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="n">shells</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">:</span> <span class="c1"># Check if the shell indices are present</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;calculate_diagonalization_matrix: shells not correct.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">prop_to_be_diagonal</span> <span class="o">==</span> <span class="s1">&#39;eal&#39;</span><span class="p">:</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">eff_atomic_levels</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">prop_to_be_diagonal</span> <span class="o">==</span> <span class="s1">&#39;dm&#39;</span><span class="p">:</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_matrix</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;using_point_integration&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                <span class="s2">&quot;calculate_diagonalization_matrix: Choices for prop_to_be_diagonal are &#39;eal&#39; or &#39;dm&#39;.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="p">[{</span><span class="n">block</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">block_dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">block_dim</span> <span class="ow">in</span> <span class="n">gfs</span><span class="p">}</span> <span class="k">for</span> <span class="n">gfs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">shells</span><span class="p">:</span>
            <span class="n">trafo</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1"># Transform to solver basis if desired, blocks of prop change in this step!</span>
            <span class="k">if</span> <span class="n">calc_in_solver_blocks</span><span class="p">:</span>
                <span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">convert_matrix</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">)</span>
            <span class="c1"># Get diagonalisation matrix, if not already diagonal</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">]))))</span> <span class="o">&gt;</span> <span class="mf">1e-13</span><span class="p">:</span>
                    <span class="n">trafo</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">])[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">trafo</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">prop</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Transform back to sumk if necessay, blocks change in this step!</span>
            <span class="k">if</span> <span class="n">calc_in_solver_blocks</span><span class="p">:</span>
                <span class="n">trafo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">convert_matrix</span><span class="p">(</span><span class="n">trafo</span><span class="p">,</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">)</span>
            <span class="n">trans</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="n">trafo</span>

        <span class="c1"># Write to block_structure object</span>

        <span class="k">if</span> <span class="n">write_to_blockstructure</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="n">trans</span>

        <span class="k">return</span> <span class="n">trans</span></div>


<div class="viewcode-block" id="SumkDFT.density_matrix_using_point_integration">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.density_matrix_using_point_integration.html#triqs_dft_tools.sumk_dft.SumkDFT.density_matrix_using_point_integration">[docs]</a>
    <span class="k">def</span> <span class="nf">density_matrix_using_point_integration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate density matrices using point integration: Only works for</span>
<span class="sd">        diagonal hopping matrix (true in wien2k). Consider using extract_G_loc</span>
<span class="sd">        together with [G.density() for G in Gloc] instead. Returned density</span>
<span class="sd">        matrix is always given in SumK block structure.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens_mat : list of dicts</span>
<span class="sd">                   Density matrix for each spin in each correlated shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]],</span> <span class="nb">complex</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
            <span class="n">MMat</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="nb">complex</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spn</span><span class="p">):</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]):</span>
                    <span class="c1"># only works for diagonal hopping matrix (true in</span>
                    <span class="c1"># wien2k)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">isp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                    <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
                    <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">]),</span>
                                                                               <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>

        <span class="c1"># get data from nodes:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">)</span>

        <span class="c1"># Rotate to local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]),</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>



<div class="viewcode-block" id="SumkDFT.density_matrix">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.density_matrix.html#triqs_dft_tools.sumk_dft.SumkDFT.density_matrix">[docs]</a>
    <span class="k">def</span> <span class="nf">density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;using_gf&#39;</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">transform_to_solver_blocks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_warnings</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate density matrices in one of two ways.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string, optional</span>

<span class="sd">                 - if &#39;using_gf&#39;: First get lattice gf (g_loc is not set up), then density matrix.</span>
<span class="sd">                                  It is useful for Hubbard I, and very quick.</span>
<span class="sd">                                  No assumption on the hopping structure is made (ie diagonal or not).</span>
<span class="sd">                 - if &#39;using_point_integration&#39;: Only works for diagonal hopping matrix (true in wien2k).</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">            Input chemical potential. If not provided the value of self.chemical_potential is used as mu.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">            If True then the local GF is calculated with the self-energy self.Sigma_imp.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">            If True then the double-counting correction is subtracted from the self-energy in calculating the GF.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">            Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">            If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">            Only relevant for real-frequency GF.</span>
<span class="sd">        transform_to_solver_blocks : bool, optional</span>
<span class="sd">            If True (default), the returned G_loc will be transformed to the block structure ``gf_struct_solver``,</span>
<span class="sd">            else it will be in ``gf_struct_sumk``.</span>
<span class="sd">        show_warnings : bool, optional</span>
<span class="sd">            Displays warning messages during transformation</span>
<span class="sd">            (Only effective if transform_to_solver_blocks = True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens_mat : list of dicts</span>
<span class="sd">                   Density matrix for each spin in each correlated shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;using_gf&quot;</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: density_matrix: method &#39;using_gf&#39; is deprecated. Use &#39;extract_G_loc&#39; instead.&quot;</span><span class="p">)</span>
            <span class="n">Gloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_G_loc</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="p">,</span>
                                      <span class="n">transform_to_solver_blocks</span><span class="p">,</span> <span class="n">show_warnings</span><span class="p">)</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">density</span><span class="p">()</span> <span class="k">for</span> <span class="n">G</span> <span class="ow">in</span> <span class="n">Gloc</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;using_point_integration&quot;</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;WARNING: density_matrix: method &#39;using_point_integration&#39; is deprecated. Use &#39;density_matrix_using_point_integration&#39; instead. All additionally provided arguments are ignored.&quot;</span><span class="p">)</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_matrix_using_point_integration</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;density_matrix: the method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not supported.&quot;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>


    <span class="c1"># For simple dft input, get crystal field splittings.</span>
<div class="viewcode-block" id="SumkDFT.eff_atomic_levels">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.eff_atomic_levels.html#triqs_dft_tools.sumk_dft.SumkDFT.eff_atomic_levels">[docs]</a>
    <span class="k">def</span> <span class="nf">eff_atomic_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the effective local Hamiltonian required as an input for</span>
<span class="sd">        the Hubbard I Solver.</span>
<span class="sd">        The local Hamiltonian (effective atomic levels) is calculated by</span>
<span class="sd">        projecting the on-site Bloch Hamiltonian:</span>

<span class="sd">        .. math:: H^{loc}_{m m&#39;} = \sum_{k} P_{m \nu}(k) H_{\nu\nu&#39;}(k) P^{*}_{\nu&#39; m&#39;}(k),</span>

<span class="sd">        where</span>

<span class="sd">        .. math:: H_{\nu\nu&#39;}(k) = [\epsilon_{\nu k} - h_{z} \sigma_{z}] \delta_{\nu\nu&#39;}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eff_atlevels : gf_struct_sumk like</span>
<span class="sd">                       Effective local Hamiltonian :math:`H^{loc}_{m m&#39;}` for each</span>
<span class="sd">                       inequivalent correlated shell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define matrices for inequivalent shells:</span>
        <span class="n">eff_atlevels</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                    <span class="n">sp</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>

        <span class="c1"># sum over k:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Hsumk&quot;</span><span class="p">):</span>
            <span class="c1"># calculate the sum over k. Does not depend on mu, so do it only</span>
            <span class="c1"># once:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="nb">complex</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
                        <span class="n">MMat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n_orb</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)</span>
                        <span class="n">MMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">isp</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="n">MMat</span>
                        <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">),</span>
                                                                                 <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="c1"># symmetrisation:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">)</span>

            <span class="c1"># Rotate to local coordinate system:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span>
                                <span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]),</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="c1"># add to matrix:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                    <span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">eff_atlevels</span></div>


<div class="viewcode-block" id="SumkDFT.init_dc">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.init_dc.html#triqs_dft_tools.sumk_dft.SumkDFT.init_dc">[docs]</a>
    <span class="k">def</span> <span class="nf">init_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the double counting terms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp_dyn</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="nb">float</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp_dyn</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span></div>


<div class="viewcode-block" id="SumkDFT.set_dc">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.set_dc.html#triqs_dft_tools.sumk_dft.SumkDFT.set_dc">[docs]</a>
    <span class="k">def</span> <span class="nf">set_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dc_imp</span><span class="p">,</span> <span class="n">dc_energ</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets double counting corrections to given values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dc_imp : gf_struct_sumk like</span>
<span class="sd">                 Double-counting self-energy term.</span>
<span class="sd">        dc_energ : list of floats</span>
<span class="sd">                   Double-counting energy corrections for each correlated shell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span> <span class="o">=</span> <span class="n">dc_imp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="n">dc_energ</span></div>


<div class="viewcode-block" id="SumkDFT.calc_dc">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.calc_dc.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_dc">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_interact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">J_hund</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">use_dc_formula</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and set the double counting corrections.</span>

<span class="sd">        If &#39;use_dc_value&#39; is provided the double-counting term is uniformly initialized</span>
<span class="sd">        with this constant and &#39;U_interact&#39; and &#39;J_hund&#39; are ignored.</span>

<span class="sd">        If &#39;use_dc_value&#39; is None the correction is evaluated according to</span>
<span class="sd">        one of the following formulae:</span>

<span class="sd">        * use_dc_formula = 0: fully-localised limit (FLL)</span>
<span class="sd">        * use_dc_formula = 1: Held&#39;s formula, i.e. mean-field formula for the Kanamori</span>
<span class="sd">                              type of the interaction Hamiltonian</span>
<span class="sd">        * use_dc_formula = 2: around mean-field (AMF)</span>

<span class="sd">        Note that FLL and AMF formulae were derived assuming a full Slater-type interaction</span>
<span class="sd">        term and should be thus used accordingly. For the Kanamori-type interaction</span>
<span class="sd">        one should use formula 1.</span>

<span class="sd">        The double-counting self-energy term is stored in `self.dc_imp` and the energy</span>
<span class="sd">        correction in `self.dc_energ`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dens_mat : gf_struct_solver like</span>
<span class="sd">            Density matrix for the specified correlated shell.</span>
<span class="sd">        orb : int, optional</span>
<span class="sd">            Index of an inequivalent shell.</span>
<span class="sd">        U_interact : float, optional</span>
<span class="sd">            Value of interaction parameter `U`.</span>
<span class="sd">        J_hund : float, optional</span>
<span class="sd">            Value of interaction parameter `J`.</span>
<span class="sd">        use_dc_formula : int or string, optional</span>
<span class="sd">            Type of double-counting correction (see description of `compute_DC_from_density` above).</span>
<span class="sd">            There is an interface with the legacy implementation which allows for the old convention:</span>
<span class="sd">            * 0 -&gt; &#39;sFLL&#39;  spin dependent fully localized limit</span>
<span class="sd">            * 1 -&gt; &#39;cHeld&#39; spin independent Held formula</span>
<span class="sd">            * 2 -&gt; &#39;sAMF&#39;  spin dependent around-mean field approximation</span>

<span class="sd">        use_dc_value : float, optional</span>
<span class="sd">            Value of the double-counting correction. If specified</span>
<span class="sd">            `U_interact`, `J_hund` and `use_dc_formula` are ignored.</span>
<span class="sd">        transform : bool</span>
<span class="sd">            whether or not to use the transformation in block_structure</span>
<span class="sd">            to transform the dc</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>

            <span class="c1"># ish is the index of the inequivalent shell corresponding to icrsh</span>
            <span class="n">ish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ish</span> <span class="o">!=</span> <span class="n">orb</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># ignore this orbital</span>
            <span class="c1"># *(1+self.corr_shells[icrsh][&#39;SO&#39;])</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>

            <span class="n">Ncr</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">]</span>
                <span class="n">Ncr</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
            <span class="n">Ncrtot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ncr</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># average the densities if there is no SP:</span>
                    <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncrtot</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">spn</span><span class="p">)</span>
                <span class="c1"># correction for SO: we have only one block in this case, but</span>
                <span class="c1"># in DC we need N/2</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncrtot</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="c1"># Uses &quot;orbital&quot; dimension with SO for double counting</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">dim</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">dim</span> <span class="o">//=</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">use_dc_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#For legacy compatibility</span>
                <span class="k">if</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="n">use_dc_formula</span><span class="si">=}</span><span class="s2">, changing to sFLL&quot;</span><span class="p">)</span>
                    <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="s2">&quot;sFLL&quot;</span>
                <span class="k">if</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="n">use_dc_formula</span><span class="si">=}</span><span class="s2">, changing to cHeld&quot;</span><span class="p">)</span>
                    <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="s2">&quot;cHeld&quot;</span>
                <span class="k">if</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detected </span><span class="si">{</span><span class="n">use_dc_formula</span><span class="si">=}</span><span class="s2">, changing to sAMF&quot;</span><span class="p">)</span>
                    <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="s2">&quot;sAMF&quot;</span>

                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                    <span class="n">DC_val</span><span class="p">,</span> <span class="n">E_val</span> <span class="o">=</span> <span class="n">compute_DC_from_density</span><span class="p">(</span><span class="n">N_tot</span><span class="o">=</span><span class="n">Ncrtot</span><span class="p">,</span><span class="n">U</span><span class="o">=</span><span class="n">U_interact</span><span class="p">,</span> <span class="n">J</span><span class="o">=</span><span class="n">J_hund</span><span class="p">,</span> <span class="n">n_orbitals</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">N_spin</span><span class="o">=</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="n">use_dc_formula</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">DC_val</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">E_val</span>




            <span class="k">else</span><span class="p">:</span>  <span class="c1"># use value provided for user to determine dc_energ and dc_imp</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">use_dc_value</span> <span class="o">*</span> <span class="n">Ncrtot</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">use_dc_value</span>

                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s2">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s2"> = </span><span class="si">%(use_dc_value)f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;DC energy = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">transform</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                    <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">effective_transformation_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">],</span> <span class="n">T</span><span class="p">))</span></div>


<div class="viewcode-block" id="SumkDFT.add_dc">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.add_dc.html#triqs_dft_tools.sumk_dft.SumkDFT.add_dc">[docs]</a>
    <span class="k">def</span> <span class="nf">add_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtracts the double counting term from the impurity self energy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sigma_minus_dc : gf_struct_sumk like</span>
<span class="sd">                         Self-energy with a subtracted double-counting term.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Be careful: Sigma_imp is already in the global coordinate system!!</span>
        <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="c1"># Transform dc_imp to global coordinate system</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                    <span class="n">gf</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gf</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp_dyn</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                        <span class="n">gf</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span><span class="n">icrsh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp_dyn</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">],</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toGlobal&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">gf</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp_dyn</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sigma_minus_dc</span></div>


<div class="viewcode-block" id="SumkDFT.symm_deg_gf">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.symm_deg_gf.html#triqs_dft_tools.sumk_dft.SumkDFT.symm_deg_gf">[docs]</a>
    <span class="k">def</span> <span class="nf">symm_deg_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gf_to_symm</span><span class="p">,</span> <span class="n">ish</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Averages a GF or a dict of np.ndarrays over degenerate shells.</span>

<span class="sd">        Degenerate shells of an inequivalent correlated shell are defined by</span>
<span class="sd">        `self.deg_shells`. This function enforces corresponding degeneracies</span>
<span class="sd">        in the input GF.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gf_to_symm : gf_struct_solver like</span>
<span class="sd">                     Input and output GF (i.e., it gets overwritten)</span>
<span class="sd">                     or dict of np.ndarrays.</span>
<span class="sd">        ish : int</span>
<span class="sd">              Index of an inequivalent shell. (default value 0)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># when reading block_structures written with older versions from</span>
        <span class="c1"># an h5 file, self.deg_shells might be None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="p">,</span> <span class="n">BlockGf</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">blockgf</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="p">,</span> <span class="n">BlockGf</span><span class="p">):</span>
            <span class="n">blockgf</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;gf_to_symm should be either a BlockGf or a dict of numpy arrays&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">degsh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
            <span class="c1"># ss will hold the averaged orbitals in the basis where the</span>
            <span class="c1"># blocks are all equal</span>
            <span class="c1"># i.e. maybe_conjugate(v^dagger gf v)</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">n_deg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degsh</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">degsh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ss</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">blockgf</span><span class="p">:</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">ss</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
                        <span class="n">helper</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                        <span class="n">helper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

                <span class="c1"># get the transformation matrix</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degsh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">degsh</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># for backward compatibility, allow degsh to be a list</span>
                    <span class="k">if</span> <span class="n">blockgf</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">target_shape</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># the helper is in the basis where the blocks are all equal</span>
                <span class="k">if</span> <span class="n">blockgf</span><span class="p">:</span>
                    <span class="n">helper</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">helper</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">v</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">helper</span> <span class="o">&lt;&lt;</span> <span class="n">helper</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="c1"># average over all shells</span>
                <span class="n">ss</span> <span class="o">+=</span> <span class="n">helper</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">n_deg</span><span class="p">)</span>
            <span class="c1"># now put back the averaged gf to all shells</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">degsh</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degsh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">degsh</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># for backward compatibility, allow degsh to be a list</span>
                    <span class="k">if</span> <span class="n">blockgf</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">target_shape</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">blockgf</span> <span class="ow">and</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="k">elif</span> <span class="n">blockgf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">blockgf</span> <span class="ow">and</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">blockgf</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span></div>


<div class="viewcode-block" id="SumkDFT.total_density">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.total_density.html#triqs_dft_tools.sumk_dft.SumkDFT.total_density">[docs]</a>
    <span class="k">def</span> <span class="nf">total_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the total charge within the energy window for a given chemical potential.</span>
<span class="sd">        The chemical potential is either given by parameter `mu` or, if it is not specified,</span>
<span class="sd">        taken from `self.chemical_potential`.</span>

<span class="sd">        The total charge is calculated from the trace of the GF in the Bloch basis.</span>
<span class="sd">        By default, a full interacting GF is used. To use the non-interacting GF, set</span>
<span class="sd">        parameter `with_Sigma = False`.</span>

<span class="sd">        The number of bands within the energy windows generally depends on `k`. The trace is</span>
<span class="sd">        therefore calculated separately for each `k`-point.</span>

<span class="sd">        Since in general n_orbitals depends on k, the calculation is done in the following order:</span>

<span class="sd">        .. math:: n_{tot} = \sum_{k} n(k),</span>

<span class="sd">        with</span>

<span class="sd">        .. math:: n(k) = Tr G_{\nu\nu&#39;}(k, i\omega_{n}).</span>

<span class="sd">        The calculation is done in the global coordinate system, if distinction is made between local/global.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">             Input chemical potential. If not specified, `self.chemical_potential` is used instead.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">             If `True` the full interacing GF is evaluated, otherwise the self-energy is not</span>
<span class="sd">             included and the charge would correspond to a non-interacting system.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">             Whether or not to subtract the double-counting term from the self-energy.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>
<span class="sd">        beta : float, optional, default = broadening</span>
<span class="sd">                when using MeshReFreq this determines the temperature for the Fermi function</span>
<span class="sd">                smearing when integrating G(w). If not given broadening will be used</span>
<span class="sd">                (converted to beta)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens : float</span>
<span class="sd">               Total charge :math:`n_{tot}`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">)</span> <span class="ow">and</span> <span class="n">beta</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">broadening</span> <span class="ow">and</span> <span class="n">broadening</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s1">&#39;beta and broadening were not specified. Aborting. Specifiy at least broadening (or better both) to correctly call density(beta) for MeshReFreq&#39;</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">broadening</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">tot_den</span><span class="p">(</span><span class="n">bgf</span><span class="p">):</span> <span class="k">return</span> <span class="n">bgf</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">tot_den</span><span class="p">(</span><span class="n">bgf</span><span class="p">):</span> <span class="k">return</span> <span class="n">bgf</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>

        <span class="n">dens</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
            <span class="n">dens</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">tot_den</span><span class="p">(</span><span class="n">G_latt</span><span class="p">)</span>
        <span class="c1"># collect data from mpi:</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">dens</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dens</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-20</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Warning: Imaginary part in density will be ignored (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dens</span><span class="o">.</span><span class="n">imag</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">dens</span><span class="o">.</span><span class="n">real</span></div>


<div class="viewcode-block" id="SumkDFT.set_mu">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.set_mu.html#triqs_dft_tools.sumk_dft.SumkDFT.set_mu">[docs]</a>
    <span class="k">def</span> <span class="nf">set_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a new chemical potential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : float</span>
<span class="sd">             New value of the chemical potential.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">mu</span></div>


<div class="viewcode-block" id="SumkDFT.calc_mu">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.calc_mu.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_mu">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">max_loops</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;dichotomy&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Searches for the chemical potential that gives the DFT total charge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : float, optional</span>
<span class="sd">                    A desired precision of the resulting total charge.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>
<span class="sd">        max_loops : int, optional</span>
<span class="sd">                    Number of dichotomy loops maximally performed.</span>

<span class="sd">        method : string, optional</span>
<span class="sd">                    Type of optimization used:</span>
<span class="sd">                        * dichotomy: usual bisection algorithm from the TRIQS library</span>
<span class="sd">                        * newton: newton method, faster convergence but more unstable</span>
<span class="sd">                        * brent: finds bounds and proceeds with hyperbolic brent method, a compromise between speed and ensuring convergence</span>
<span class="sd">        beta : float, optional, default = broadening</span>
<span class="sd">                when using MeshReFreq this determines the temperature for the Fermi function</span>
<span class="sd">                smearing when integrating G(w). If not given broadening will be used</span>
<span class="sd">                (converted to beta)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu : float</span>
<span class="sd">             Value of the chemical potential giving the DFT total charge</span>
<span class="sd">             within specified precision.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">find_bounds</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">x_init</span><span class="p">,</span> <span class="n">delta_x</span><span class="p">,</span> <span class="n">max_loops</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Finding bounds on chemical potential&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x_init</span>
            <span class="c1"># First find the bounds</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">x1</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">y1</span>

            <span class="n">nbre_loop</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># abort the loop after maxiter is reached or when y1 and y2 have different sign</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">nbre_loop</span> <span class="o">&lt;=</span> <span class="n">max_loops</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">y2</span><span class="o">*</span><span class="n">y1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">nbre_loop</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">x1</span> <span class="o">=</span> <span class="n">x2</span>
                <span class="n">y1</span> <span class="o">=</span> <span class="n">y2</span>

                <span class="n">x2</span> <span class="o">-=</span> <span class="n">eps</span><span class="o">*</span><span class="n">delta_x</span>
                <span class="n">y2</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nbre_loop</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">max_loops</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The bounds could not be found&quot;</span><span class="p">)</span>

            <span class="c1"># Make sure that x2 &gt; x1</span>
            <span class="k">if</span> <span class="n">x1</span> <span class="o">&gt;</span> <span class="n">x2</span><span class="p">:</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span>
                <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">y2</span><span class="p">,</span> <span class="n">y1</span>

            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mu_interval: [  </span><span class="si">{</span><span class="n">x1</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">  ; </span><span class="si">{</span><span class="n">x2</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ]&quot;</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;delta to target density interval: [ </span><span class="si">{</span><span class="n">y1</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ; </span><span class="si">{</span><span class="n">y2</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> ]&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span>

        <span class="c1"># previous implementation</span>

        <span class="k">def</span> <span class="nf">F_bisection</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_required</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_below</span>
        <span class="c1"># using scipy.optimize</span>

        <span class="k">def</span> <span class="nf">F_optimize</span><span class="p">(</span><span class="n">mu</span><span class="p">):</span>

            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Trying out mu = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mu</span><span class="p">)))</span>
            <span class="n">calc_dens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">density</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target density = </span><span class="si">{</span><span class="n">density</span><span class="si">}</span><span class="s2">; Delta to target = </span><span class="si">{</span><span class="n">calc_dens</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">calc_dens</span>

        <span class="c1"># check for lowercase matching for the method variable</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;dichotomy&quot;</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sumk calc_mu: Using dichtomy adjustment to find chemical potential</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">dichotomy</span><span class="o">.</span><span class="n">dichotomy</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">F_bisection</span><span class="p">,</span>
                                                          <span class="n">x_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">y_value</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
                                                          <span class="n">precision_on_y</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">delta_x</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">max_loops</span><span class="o">=</span><span class="n">max_loops</span><span class="p">,</span>
                                                          <span class="n">x_name</span><span class="o">=</span><span class="s2">&quot;Chemical Potential&quot;</span><span class="p">,</span> <span class="n">y_name</span><span class="o">=</span><span class="s2">&quot;Total Density&quot;</span><span class="p">,</span>
                                                          <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;newton&quot;</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sumk calc_mu: Using Newton method to find chemical potential</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">newton</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">F_optimize</span><span class="p">,</span>
                                             <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span>
                                             <span class="n">tol</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">max_loops</span><span class="p">,</span>
                                             <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;brent&quot;</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sumk calc_mu: Using Brent method to find chemical potential&quot;</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;sumk calc_mu: Finding bounds </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">mu_guess_0</span><span class="p">,</span> <span class="n">mu_guess_1</span> <span class="o">=</span> <span class="n">find_bounds</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">F_optimize</span><span class="p">,</span>
                                                 <span class="n">x_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span>
                                                 <span class="n">delta_x</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">max_loops</span><span class="o">=</span><span class="n">max_loops</span><span class="p">,</span>
                                                 <span class="p">)</span>
            <span class="n">mu_guess_1</span> <span class="o">+=</span> <span class="mf">0.01</span>  <span class="c1"># scrambles higher lying interval to avoid getting stuck</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">sumk calc_mu: Searching root with Brent method</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">brenth</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="n">F_optimize</span><span class="p">,</span>
                                             <span class="n">a</span><span class="o">=</span><span class="n">mu_guess_0</span><span class="p">,</span>
                                             <span class="n">b</span><span class="o">=</span><span class="n">mu_guess_1</span><span class="p">,</span>
                                             <span class="n">xtol</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="n">max_loops</span><span class="p">,</span>
                                             <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;sumk calc_mu: The selected method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">, is not implemented</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                    Please check for typos or select one of the following:</span>
<span class="sd">                        * dichotomy: usual bisection algorithm from the TRIQS library</span>
<span class="sd">                        * newton: newton method, fastest convergence but more unstable</span>
<span class="sd">                        * brent: finds bounds and proceeds with hyperbolic brent method, a compromise between speed and ensuring convergence</span>
<span class="sd">                    &quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span></div>


<div class="viewcode-block" id="SumkDFT.calc_density_correction">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.calc_density_correction.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_density_correction">[docs]</a>
    <span class="k">def</span> <span class="nf">calc_density_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dm_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spinave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kpts_to_write</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the charge density correction and stores it into a file.</span>

<span class="sd">        The charge density correction is needed for charge-self-consistent DFT+DMFT calculations.</span>
<span class="sd">        It represents a density matrix of the interacting system defined in Bloch basis</span>
<span class="sd">        and it is calculated from the sum over Matsubara frequecies of the full GF,</span>

<span class="sd">        ..math:: N_{\nu\nu&#39;}(k) = \sum_{i\omega_{n}} G_{\nu\nu&#39;}(k, i\omega_{n})</span>

<span class="sd">        The density matrix for every `k`-point is stored into a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">                   Name of the file to store the charge density correction.</span>
<span class="sd">        dm_type : string</span>
<span class="sd">                   DFT code to write the density correction for. Options:</span>
<span class="sd">                   &#39;vasp&#39;, &#39;wien2k&#39;, &#39;elk&#39; or &#39;qe&#39;. Needs to be set for &#39;qe&#39;</span>
<span class="sd">        spinave : logical</span>
<span class="sd">                   Elk specific and for magnetic calculations in DMFT only.</span>
<span class="sd">                   It averages the spin to keep the DFT part non-magnetic.</span>
<span class="sd">        kpts_to_write : iterable of int</span>
<span class="sd">                   Indices of k points that are written to file. If None (default),</span>
<span class="sd">                   all k points are written. Only implemented for dm_type &#39;vasp&#39;</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>
<span class="sd">        beta : float, optional, default = broadening</span>
<span class="sd">                when using MeshReFreq this determines the temperature for the Fermi function</span>
<span class="sd">                smearing when integrating G(w). If not given broadening will be used</span>
<span class="sd">                (converted to beta)</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (deltaN, dens) : tuple</span>
<span class="sd">                         Returns a tuple containing the density matrix `deltaN` and</span>
<span class="sd">                         the corresponing total charge `dens`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#automatically set dm_type if required</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dm_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dft_code</span>

        <span class="k">assert</span> <span class="n">dm_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;vasp&#39;</span><span class="p">,</span> <span class="s1">&#39;wien2k&#39;</span><span class="p">,</span><span class="s1">&#39;elk&#39;</span><span class="p">,</span> <span class="s1">&#39;qe&#39;</span><span class="p">),</span> <span class="s2">&quot;&#39;dm_type&#39; must be either &#39;vasp&#39;, &#39;wienk&#39;, &#39;elk&#39; or &#39;qe&#39;&quot;</span>
        <span class="c1">#default file names</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;wien2k&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;dens_mat.dat&#39;</span>
            <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;GAMMA&#39;</span>
            <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;elk&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;DMATDMFT.OUT&#39;</span>
            <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;qe&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span>


        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;calc_density_correction: &quot;</span>
                                              <span class="s2">&quot;filename has to be a string!&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">kpts_to_write</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Selecting k-points only&#39;</span>
                                                            <span class="o">+</span><span class="s1">&#39;implemented for vasp&#39;</span><span class="p">)</span>

        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
        <span class="n">band_en_correction</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1"># Fetch Fermi weights and energy window band indices</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;vasp&#39;</span><span class="p">,</span><span class="s1">&#39;qe&#39;</span><span class="p">]:</span>
            <span class="n">fermi_weights</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">band_window</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
                    <span class="n">fermi_weights</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">][</span><span class="s1">&#39;dft_fermi_weights&#39;</span><span class="p">]</span>
                    <span class="n">band_window</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">][</span><span class="s1">&#39;band_window&#39;</span><span class="p">]</span>
            <span class="n">fermi_weights</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">fermi_weights</span><span class="p">)</span>
            <span class="n">band_window</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">band_window</span><span class="p">)</span>

<span class="c1"># Convert Fermi weights to a density matrix</span>
            <span class="n">dens_mat_dft</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fermi_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">complex</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)]</span>


        <span class="c1"># Set up deltaN:</span>
        <span class="n">deltaN</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
            <span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span>
                                      <span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]],</span> <span class="nb">complex</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)]</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_or_hk</span> <span class="o">==</span> <span class="s1">&#39;hk&#39;</span><span class="p">:</span>
                <span class="c1"># rotate the Green function into the DFT band basis</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">:</span>
                    <span class="n">G_latt_rot</span> <span class="o">=</span> <span class="n">gf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">G_latt_rot</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">upfold</span><span class="p">(</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">,</span><span class="n">shells</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>

                    <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_latt_rot</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">:</span>
                <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">):</span>
                    <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dm_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;vasp&#39;</span><span class="p">,</span><span class="s1">&#39;qe&#39;</span><span class="p">]:</span>
<span class="c1"># In &#39;vasp&#39;-mode subtract the DFT density matrix</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]]</span>
                    <span class="n">diag_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
                    <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">diag_inds</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][:</span><span class="n">nb</span><span class="p">]</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_mixing</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaNOld</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">G2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">kpts_cart</span><span class="p">[</span><span class="n">ik</span><span class="p">,:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="c1"># Kerker mixing</span>
                        <span class="n">mix_fac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_mixing_alpha</span> <span class="o">*</span> <span class="n">G2</span> <span class="o">/</span> <span class="p">(</span><span class="n">G2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_mixing_gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                        <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">diag_inds</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">mix_fac</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltaNOld</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">diag_inds</span><span class="p">]</span> <span class="o">+</span> <span class="n">mix_fac</span> <span class="o">*</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">diag_inds</span><span class="p">]</span>
                    <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
                    <span class="n">isp</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="n">nb</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]],</span> <span class="s2">&quot;Number of bands is inconsistent at ik = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
                    <span class="n">band_en_correction</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="p">:</span><span class="n">nb</span><span class="p">,</span> <span class="p">:</span><span class="n">nb</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="c1"># mpi reduce:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">deltaN</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">])</span>
            <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltaNOld</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deltaN</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>



        <span class="n">band_en_correction</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">band_en_correction</span><span class="p">)</span>

        <span class="c1"># now save to file:</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;wien2k&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="n">f1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;dn&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="c1"># write chemical potential (in Rydberg):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="c1"># write beta in rydberg-1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no spin-polarization</span>

                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                                <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                         <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                         <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># with spin-polarization</span>

                    <span class="c1"># dict of filename: (spin index, block_name)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">to_write</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;up&#39;</span><span class="p">),</span> <span class="n">f1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">)}</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">to_write</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ud&#39;</span><span class="p">),</span> <span class="n">f1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ud&#39;</span><span class="p">)}</span>
                    <span class="k">for</span> <span class="n">fout</span> <span class="ow">in</span> <span class="n">to_write</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">to_write</span><span class="p">[</span><span class="n">fout</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]):</span>
                                <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]):</span>
                                    <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                               <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kpts_to_write</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">kpts_to_write</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">kpts_to_write</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">kpts_to_write</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_k</span>

            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Spin-polarized density matrix is not implemented&quot;</span>

            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%i</span><span class="s2">  -1  ! Number of k-points, default number of bands</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">kpts_to_write</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">kpts_to_write</span><span class="p">):</span>
                        <span class="n">ib1</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">ib2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%i</span><span class="s2">  </span><span class="si">%i</span><span class="s2">  </span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ib1</span><span class="p">,</span> <span class="n">ib2</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                                <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;elk&#39;</span><span class="p">:</span>
        <span class="c1"># output each k-point density matrix for Elk</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
        <span class="c1"># read in misc data from .h5 file</span>
                <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window&#39;</span><span class="p">,</span><span class="s1">&#39;vkl&#39;</span><span class="p">,</span><span class="s1">&#39;nstsv&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">subgroup_present</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
                             <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">misc_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
        <span class="c1"># open file</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1"># determine the number of spin blocks</span>
                    <span class="n">n_spin_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span>
                    <span class="n">nbmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">)</span>
        <span class="c1"># output beta and mu in Hartrees</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span>
        <span class="c1"># ouput n_k, nspin and max orbitals - a check</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%d</span><span class="s2">  </span><span class="si">%d</span><span class="s2">  </span><span class="si">%d</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2"> </span><span class="si">%.14f</span><span class="s2"> ! nkpt, nspin, nstmax, beta, mu</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">,</span> <span class="n">n_spin_blocks</span><span class="p">,</span> <span class="n">nbmax</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">mu</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                      <span class="k">for</span> <span class="n">ispn</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_spin_blocks</span><span class="p">):</span>
                        <span class="c1">#Determine the SO density matrix band indices from the spinor band indices</span>
                        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
                          <span class="n">band0</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
                          <span class="n">band1</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
                          <span class="n">ib1</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">band0</span><span class="p">))</span>
                          <span class="n">ib2</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">band1</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                        <span class="c1">#Determine the density matrix band indices from the spinor band indices</span>
                          <span class="n">ib1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">ispn</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                          <span class="n">ib2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">ispn</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%d</span><span class="s2">  </span><span class="si">%d</span><span class="s2">  </span><span class="si">%d</span><span class="s2">  </span><span class="si">%d</span><span class="s2"> ! ik, ispn, minist, maxist</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ispn</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ib1</span><span class="p">,</span> <span class="n">ib2</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ispn</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ispn</span><span class="p">]):</span>
                                <span class="c1">#output non-magnetic or spin-averaged density matrix</span>
                                <span class="k">if</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">SP</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">spinave</span><span class="p">)):</span>
                                  <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                  <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="k">else</span><span class="p">:</span>
                                  <span class="n">valre</span> <span class="o">=</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">ispn</span><span class="p">]][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
                                  <span class="n">valim</span> <span class="o">=</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">ispn</span><span class="p">]][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;qe&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;SUMK calc_density_correction: WARNING! Averaging out spin-polarized correction in the density channel&quot;</span><span class="p">)</span>

            <span class="n">subgrp</span> <span class="o">=</span> <span class="s1">&#39;dft_update&#39;</span>
            <span class="n">delta_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%i</span><span class="s2">  -1  ! Number of k-points, default number of bands</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                <span class="n">ib1</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">ib2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                        <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                        <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                        <span class="c1"># write into delta_N</span>
                        <span class="n">delta_N</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span> <span class="o">=</span> <span class="n">valre</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">valim</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">subgrp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
                        <span class="n">ar</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
                    <span class="n">things_to_save</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;delta_N&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_save</span><span class="p">:</span>
                        <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">it</span><span class="p">]</span>


        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unknown density matrix type: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">dm_type</span><span class="p">))</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">deltaN</span><span class="p">,</span> <span class="n">dens</span>

        <span class="k">if</span> <span class="n">dm_type</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;vasp&#39;</span><span class="p">,</span> <span class="s1">&#39;qe&#39;</span><span class="p">]:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="n">band_en_correction</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="SumkDFT.calculate_min_max_band_energies">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.calculate_min_max_band_energies.html#triqs_dft_tools.sumk_dft.SumkDFT.calculate_min_max_band_energies">[docs]</a>
    <span class="k">def</span> <span class="nf">calculate_min_max_band_energies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">hop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span>
        <span class="n">diag_hop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">hop</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">hop_slice</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">hop</span><span class="p">)</span>
        <span class="n">diag_hop_slice</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">diag_hop</span><span class="p">)</span>
        <span class="n">diag_hop_slice</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">hop_slice</span><span class="p">)</span>
        <span class="n">diag_hop</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">diag_hop</span><span class="p">)</span>
        <span class="n">min_band_energy</span> <span class="o">=</span> <span class="n">diag_hop</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
        <span class="n">max_band_energy</span> <span class="o">=</span> <span class="n">diag_hop</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_band_energy</span> <span class="o">=</span> <span class="n">min_band_energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_band_energy</span> <span class="o">=</span> <span class="n">max_band_energy</span>
        <span class="k">return</span> <span class="n">min_band_energy</span><span class="p">,</span> <span class="n">max_band_energy</span></div>


<span class="c1">################</span>
<span class="c1"># FIXME LEAVE UNDOCUMENTED</span>
<span class="c1">################</span>

<div class="viewcode-block" id="SumkDFT.check_projectors">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.check_projectors.html#triqs_dft_tools.sumk_dft.SumkDFT.check_projectors">[docs]</a>
    <span class="k">def</span> <span class="nf">check_projectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculated the density matrix from projectors (DM = P Pdagger) to check that it is correct and</span>
<span class="sd">           specifically that it matches DFT.&quot;&quot;&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]],</span> <span class="nb">complex</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span>
                    <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">)</span>

        <span class="c1"># Rotate to local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]),</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>


<div class="viewcode-block" id="SumkDFT.sorts_of_atoms">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.sorts_of_atoms.html#triqs_dft_tools.sumk_dft.SumkDFT.sorts_of_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">sorts_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shells</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the number of inequivalent sorts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;sort&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))]</span>
        <span class="n">n_sorts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sortlst</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_sorts</span></div>


<div class="viewcode-block" id="SumkDFT.number_of_atoms">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.number_of_atoms.html#triqs_dft_tools.sumk_dft.SumkDFT.number_of_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">number_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shells</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the number of inequivalent atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))]</span>
        <span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atomlst</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_atoms</span></div>


    <span class="c1"># The following methods are here to ensure backward-compatibility</span>
    <span class="c1"># after introducing the block_structure class</span>
    <span class="k">def</span> <span class="nf">__get_gf_struct_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk</span>
    <span class="k">def</span> <span class="nf">__set_gf_struct_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_gf_struct_sumk</span><span class="p">,</span><span class="n">__set_gf_struct_sumk</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_gf_struct_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver</span>
    <span class="k">def</span> <span class="nf">__set_gf_struct_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_gf_struct_solver</span><span class="p">,</span><span class="n">__set_gf_struct_solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_solver_to_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk</span>
    <span class="k">def</span> <span class="nf">__set_solver_to_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_solver_to_sumk</span><span class="p">,</span><span class="n">__set_solver_to_sumk</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_sumk_to_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">sumk_to_solver</span>
    <span class="k">def</span> <span class="nf">__set_sumk_to_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_sumk_to_solver</span><span class="p">,</span><span class="n">__set_sumk_to_solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_solver_to_sumk_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk_block</span>
    <span class="k">def</span> <span class="nf">__set_solver_to_sumk_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_solver_to_sumk_block</span><span class="p">,</span><span class="n">__set_solver_to_sumk_block</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_deg_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">deg_shells</span>
    <span class="k">def</span> <span class="nf">__set_deg_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">deg_shells</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_deg_shells</span><span class="p">,</span><span class="n">__set_deg_shells</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gf_struct_solver_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gf_struct_sumk_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gf_struct_solver_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver_dict</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gf_struct_sumk_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk_dict</span>

    <span class="k">def</span> <span class="nf">__get_corr_to_inequiv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">corr_to_inequiv</span>
    <span class="k">def</span> <span class="nf">__set_corr_to_inequiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">corr_to_inequiv</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">corr_to_inequiv</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_corr_to_inequiv</span><span class="p">,</span> <span class="n">__set_corr_to_inequiv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_inequiv_to_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">inequiv_to_corr</span>
    <span class="k">def</span> <span class="nf">__set_inequiv_to_corr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">inequiv_to_corr</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">inequiv_to_corr</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_inequiv_to_corr</span><span class="p">,</span> <span class="n">__set_inequiv_to_corr</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011-2021.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>