
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Manipulating the Green’s functions block structure &#8212; triqs_dft_tools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/triqs.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=default"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head><body>
<div class="pageheader">
  <ul>
    
    <li><a href="../install.html">Install</a></li>
    
    <li><a href="../documentation.html">Documentation</a></li>
    
    <li><a href="../tutorials.html">Tutorials</a></li>
    
    <li><a href="../issues.html">Issues</a></li>
    
    <li><a href="../about.html">About DFTTools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../index.html">dft tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://triqs.github.io/triqs">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Manipulating the Green’s functions block structure</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Manipulating the Green’s functions block structure</a><ul>
<li><a class="reference internal" href="#creating-a-block-structure-and-green-s-function">Creating a block structure and Green’s function</a></li>
<li><a class="reference internal" href="#the-solver-structure">The <em>solver</em> structure</a></li>
<li><a class="reference internal" href="#picking-orbitals">Picking orbitals</a></li>
<li><a class="reference internal" href="#basis-rotations">Basis rotations</a></li>
<li><a class="reference internal" href="#diagonal-approximation">Diagonal approximation</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/blockstructure.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="manipulating-the-green-s-functions-block-structure">
<span id="blockstructure"></span><h1>Manipulating the Green’s functions block structure<a class="headerlink" href="#manipulating-the-green-s-functions-block-structure" title="Permalink to this headline">¶</a></h1>
<p>The DFTTools package includes the general <code class="xref py py-class docutils literal notranslate"><span class="pre">BlockStructure</span></code> class for manipulating the blocks of Green’s functions (see also the TRIQS documentation on BlockGF). In the following, we will introduce its basic and most commonly used functionalities that might show up in an actual DFT+DMFT calculation, and will illustrate them on a very basic fictitious problem.</p>
<p>The main idea is to have two structures for the Greens functions available. The first one is used in the procedures of the <code class="xref py py-class docutils literal notranslate"><span class="pre">SumkDFT</span></code> to calculate Dysons equations, lattice Greens functions, and so on, and is normally a full matrix. For instance, in a calculation using <span class="math notranslate nohighlight">\(t_{2g}\)</span> orbitals without spin-orbit-coupling, you have an spin-up block of size 3x3 and a spin-down block of the same size. In the following, wee will refer to this structure as <em>sumk</em> structure.</p>
<p>The second structure, called <em>solver</em> structure, is the one which is used for the solution of the Anderson impurity problem. As a matter of fact, in particular in combination with quantum Monte Carlo techniques, it is advisable to use as small blocks as possible in order to run into numerical problems. In particular, it should contain information about the symmetry of the local problem.</p>
<div class="section" id="creating-a-block-structure-and-green-s-function">
<h2>Creating a block structure and Green’s function<a class="headerlink" href="#creating-a-block-structure-and-green-s-function" title="Permalink to this headline">¶</a></h2>
<p>For the purpose of this documentation, we focus on an example of a 3x3 Green’s function, consisting of a 1x1 block and a 2x2 block (with off-diagonal coupling). This is reminiscent of a <span class="math notranslate nohighlight">\(t_{2g}\)</span> manifold. Note that this initialisation is normally done automatically by DFTTools, we do it here manually for demonstration purposes only.</p>
<p>We can create a simple <code class="xref py py-class docutils literal notranslate"><span class="pre">BlockStructure</span></code> object as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools</span> <span class="k">import</span> <span class="n">BlockStructure</span>
<span class="n">BS</span> <span class="o">=</span> <span class="n">BlockStructure</span><span class="o">.</span><span class="n">full_structure</span><span class="p">([{</span><span class="s1">&#39;up&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]}],</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>This creates a block structure with one 3x3 block named <em>up</em>. Note that we have not created any Green’s function yet; this is just the structure of those objects. If you want to create a Green’s function with this structure, you can do (we will if with some content also):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs.gf</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">GF_sumk</span> <span class="o">=</span> <span class="n">BS</span><span class="o">.</span><span class="n">create_gf</span><span class="p">(</span><span class="n">space</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">beta</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">n_points</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">iOmega_n</span> <span class="o">-</span> <span class="mf">2.0</span>
<span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">iOmega_n</span> <span class="o">+</span> <span class="mf">0.5</span>
<span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">iOmega_n</span> <span class="o">+</span> <span class="mf">0.5</span>
<span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mf">0.1</span>
<span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mf">0.1</span>
<span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">inverse</span><span class="p">(</span><span class="n">GF_sumk</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Technically, we use the <em>sumk</em> block structure for this Green’s function. However, at this point, sumk and solver structure are still the same.</p>
<p>A plot of this structure looks like this. Note that there are off-diagonal elements which are exactly zero by construction.</p>
<a class="reference internal image-reference" href="../_images/BS_GFsumk.png"><img alt="../_images/BS_GFsumk.png" class="align-center" src="../_images/BS_GFsumk.png" style="width: 600px;" /></a>
</div>
<div class="section" id="the-solver-structure">
<h2>The <em>solver</em> structure<a class="headerlink" href="#the-solver-structure" title="Permalink to this headline">¶</a></h2>
<p>The method:<cite>BlockStructure.full_structure()</cite> method, as we used it above to create our BlockStructure object, yields - as the name suggests - a full structure, where <em>sumk</em> and <em>solver</em> structure are identical. Now we want to take advantage of the symmetries of the problem to reduce the <em>solver</em> block structure to the relevant matrix elements only. In our case the [0,0] matrix element of the Green’s function is completely decoupled from the 2x2 matrix of [1:2,1:2] elements. We simplify the <em>solver</em> structure by setting the mapping of each orbital to its target block and orbital:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BS</span><span class="o">.</span><span class="n">map_gf_struct_solver</span><span class="p">([{(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">):(</span><span class="s1">&#39;up_0&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">):(</span><span class="s1">&#39;up_1&#39;</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">):(</span><span class="s1">&#39;up_1&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)}])</span>
</pre></div>
</div>
<p>This creates a <em>solver</em> structure different from the <em>sumk</em> structure. To see the result, let us look at the Green’s function in the <em>solver</em> structure now:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">GF_solver</span> <span class="o">=</span> <span class="n">BS</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span><span class="n">GF_sumk</span><span class="p">,</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This converts the GF_sumk into GF_solver, which looks like this.</p>
<a class="reference internal image-reference" href="../_images/BS_GF_up_0.png"><img alt="../_images/BS_GF_up_0.png" class="align-center" src="../_images/BS_GF_up_0.png" style="width: 200px;" /></a>
<a class="reference internal image-reference" href="../_images/BS_GF_up_1.png"><img alt="../_images/BS_GF_up_1.png" class="align-center" src="../_images/BS_GF_up_1.png" style="width: 400px;" /></a>
<p>As you can see, the Green’s function in the <em>solver</em> structure now consists of two blocks: one 1x1 block (called <em>up_0</em>) and one 2x2 block (called <em>up_1</em>). This is no approximation, as the off-diagonal elements between these blocks are exactly zero anyway.</p>
</div>
<div class="section" id="picking-orbitals">
<h2>Picking orbitals<a class="headerlink" href="#picking-orbitals" title="Permalink to this headline">¶</a></h2>
<p>In some cases it might happen that for the projection to localised orbitals a full <em>d</em> or <em>f</em>-shell has to be used. However, for the Anderson impurity problem, just a subset of the orbitals are needed. This is the case, e.g., when the projection leads to completely empty or full orbitals that you don’t want to include in the AIM.</p>
<p>For the example here, the local energy of the <em>up_0</em> block (2 eV) is higher than that of the <em>up_1</em> block (0.4 and 0.6 eV). Assuming that the chemical potential lies somewhere in the range of the <em>up_1</em> block, we might restrict our calculation to only this <em>up_1</em> block. The <code class="xref py py-class docutils literal notranslate"><span class="pre">BlockStructure</span></code> class includes methods to pick a subset or orbitals:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BS</span><span class="o">.</span><span class="n">pick_gf_struct_solver</span><span class="p">([{</span><span class="s1">&#39;up_1&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]}])</span>
<span class="n">GF2</span> <span class="o">=</span> <span class="n">BS</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span><span class="n">GF_sumk</span><span class="p">,</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Now the Green’s function GF2 consists of only one 2x2 block, called <em>up_1</em>, as we have left out the <em>up_0</em> block.</p>
</div>
<div class="section" id="basis-rotations">
<h2>Basis rotations<a class="headerlink" href="#basis-rotations" title="Permalink to this headline">¶</a></h2>
<p>In cases where the Greens function or the local Hamiltonian shows off diagonal entries in the chosen basis, it is often beneficial to rotate to a different basis. This is of particular interest when using a QMC solver, since off-diagonal contributions lead to a famous fermionic sign problem. The <code class="xref py py-class docutils literal notranslate"><span class="pre">BlockStructure</span></code> class includes methods to perform such basis rotations.</p>
<p>In our example, the local Hamiltonian is given by</p>
<div class="math notranslate nohighlight">
\[\begin{split}\varepsilon_{mm'} = \begin{pmatrix} 2.0 &amp; 0.0 &amp; 0.0 \\0.0  &amp; -0.5 &amp; -0.1\\0.0 &amp; -0.1 &amp; -0.5 \end{pmatrix}\end{split}\]</div>
<p>It is easy to check that the following matrix diagonalises this local Hamiltonian:</p>
<div class="math notranslate nohighlight">
\[\begin{split}T_{mm'} = \begin{pmatrix} 1.0 &amp; 0.0 &amp; 0.0 \\0.0  &amp; 1/\sqrt{2} &amp; -1/\sqrt{2}\\0.0 &amp; 1/\sqrt{2} &amp; 1/\sqrt{2} \end{pmatrix}\end{split}\]</div>
<p>With this unitary matrix, we can do a basis rotation to reduce the size of the off-diagonal matrix elements. Note that the transformation matrix has to be given in the <em>sumk</em> basis form (a 3x3 matrix in this case):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># Unitary transformation matrix</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)],[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]])</span>

<span class="n">BS</span><span class="o">.</span><span class="n">transformation</span> <span class="o">=</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span>
<span class="n">GF3</span> <span class="o">=</span> <span class="n">BS</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span><span class="n">GF_sumk</span><span class="p">,</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/BS_GF_up_1_rotated.png"><img alt="../_images/BS_GF_up_1_rotated.png" class="align-center" src="../_images/BS_GF_up_1_rotated.png" style="width: 400px;" /></a>
<p>As you can see, the offdiagonal elements are reduced to 1e-16 in this basis. Please note that our example is not the most generic case. Normally, due to non-local hybridisation, the off-diagonals can be made smaller, but not exactly zero.</p>
</div>
<div class="section" id="diagonal-approximation">
<h2>Diagonal approximation<a class="headerlink" href="#diagonal-approximation" title="Permalink to this headline">¶</a></h2>
<p>As said above, off diagonal contributions lead to some troubles. However,
when you are exactly sure that you know what you are doing, there is functionality to take only the diagonal parts into account in the block structure. Be careful, there is no automatic check whether this approximation is justified or not!</p>
<p>Starting from the rotated basis as done above, we can get rid of the off-diagonals as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">BS</span><span class="o">.</span><span class="n">approximate_as_diagonal</span><span class="p">()</span>
<span class="n">GF4</span> <span class="o">=</span> <span class="n">BS</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span><span class="n">GF_sumk</span><span class="p">,</span> <span class="n">space_from</span><span class="o">=</span><span class="s1">&#39;sumk&#39;</span><span class="p">,</span> <span class="n">space_to</span><span class="o">=</span><span class="s1">&#39;solver&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The Green’s function GF4 consists now only of two 1x1 blocks, where <em>up_1</em> was the [0,0] element of the former 2x2 block, and <em>up_2</em> was the [1,1] element:</p>
<a class="reference internal image-reference" href="../_images/BS_GF_up_1_rotated_diag.png"><img alt="../_images/BS_GF_up_1_rotated_diag.png" class="align-center" src="../_images/BS_GF_up_1_rotated_diag.png" style="width: 200px;" /></a>
<a class="reference internal image-reference" href="../_images/BS_GF_up_2_rotated_diag.png"><img alt="../_images/BS_GF_up_2_rotated_diag.png" class="align-center" src="../_images/BS_GF_up_2_rotated_diag.png" style="width: 200px;" /></a>
<p>In summary, we started with a full 3x3 matrix in the very beginning, and ended with two 1x1 blocks containing the relevant matrix elements for the calculation.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Manipulating the Green’s functions block structure</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2020.
    </div>
  </body>
</html>