<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>triqs_dft_tools.sumk_dft_transport &mdash; TRIQS DFTTools  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=f7f783a0" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />

  
    <link rel="shortcut icon" href="../../_static/triqs_favicon.ico"/>
  
        <script src="../../_static/jquery.js?v=8dae8fb0"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #7E588A" >

          
          
          <a href="../../index.html" class="icon icon-home">
            TRIQS DFTTools
          </a>
              <div class="version">
                3.3.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#packaged-versions-of-dfttools">Packaged Versions of DFTTools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#ubuntu-debian-packages">Ubuntu Debian packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#anaconda-experimental">Anaconda (experimental)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#docker">Docker</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../install.html#compiling-dfttools-from-source">Compiling DFTTools from source</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#installation-steps">Installation steps</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#important-note-for-fcsc-dft-dmft-calculations">Important note for FCSC DFT+DMFT calculations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#installation-steps-for-the-use-with-wien2k-version-14-2-and-older">Installation steps for the use with WIEN2K version 14.2 and older</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#version-compatibility">Version compatibility</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../install.html#custom-cmake-options">Custom CMake options</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../documentation.html">Documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#basic-notions">Basic notions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../basicnotions/first.html">What you should know</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#what-is-dfttools">What is <strong class="program">DFTTools</strong>?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#understand-the-philosophy-of-dfttools">Understand the philosophy of <strong class="program">DFTTools</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#learn-how-to-use-triqs-library-and-the-cthyb-solver">Learn how to use TRIQS library (and the CTHYB solver)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/first.html#analytic-continuation">Analytic Continuation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../basicnotions/dft_dmft.html">Introduction to DFT+DMFT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#density-functional-theory-in-a-very-small-nutshell">Density-functional theory in a (very small) nutshell</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#from-dft-to-dmft">From DFT to DMFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#using-projective-wannier-functions-for-dmft">Using projective Wannier functions for DMFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/dft_dmft.html#full-charge-self-consistency">Full charge self-consistency</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../basicnotions/structure.html">Structure of <strong class="program">DFTTools</strong></a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#the-interface-layer">The interface layer</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#the-dmft-calculation">The DMFT calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#full-charge-self-consistency">Full charge self consistency</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#post-processing">Post-processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../basicnotions/structure.html#executing-your-python-scripts">Executing your python scripts</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#construction-of-local-orbitals-from-dft">Construction of local orbitals from DFT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/conversion.html">Supported interfaces</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_wien2k.html">Interface with Wien2k</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_vasp.html">Interface with VASP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_elk.html">Interface with Elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_W90.html">Interface with Wannier90</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/conv_generalhk.html">A general H(k)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/conversion.html#mpi-issues">MPI issues</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/conversion.html#interfaces-to-other-packages">Interfaces to other packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../h5structure.html">standardized hdf5 structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../h5structure.html#groups-and-their-formats">groups and their formats</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../h5structure.html#general-and-simple-h-k-converter">General and simple H(k) Converter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#dft-dmft">DFT+DMFT</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/dftdmft_singleshot.html">Single-shot DFT+DMFT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#initialization-of-the-calculation">Initialization of the calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#setting-up-the-impurity-solver">Setting up the impurity solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#doing-the-dmft-loop">Doing the DMFT loop</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#restarting-a-calculation">Restarting a calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_singleshot.html#mixing">Mixing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/dftdmft_selfcons.html">Full charge self-consistency</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#wien2k-dmftproj">Wien2k + dmftproj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#vasp-plovasp">VASP + PLOVasp</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#elk">Elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/dftdmft_selfcons.html#other-dft-codes">Other DFT codes</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#advanced-topics">Advanced Topics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/blockstructure.html">Manipulating the Green’s functions block structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#creating-a-block-structure-and-green-s-function">Creating a block structure and Green’s function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#the-solver-structure">The <em>solver</em> structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#picking-orbitals">Picking orbitals</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#basis-rotations">Basis rotations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/blockstructure.html#diagonal-approximation">Diagonal approximation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/BasisRotation.html">Automatic basis rotations in DFT+DMFT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/BasisRotation.html#setting-up-the-initial-solver-structure-from-dft">Setting up the initial solver structure from DFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/BasisRotation.html#finding-the-transformation-matrix">Finding the transformation matrix</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/BasisRotation.html#automatic-transformation-during-the-dmft-loop">Automatic transformation during the DMFT loop</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/soc.html">Spin-orbit coupled calculations (single-shot)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#treatment-of-soc-in-dft">Treatment of SOC in DFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#treatment-of-soc-in-wien2k">Treatment of SOC in Wien2k</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#treatment-of-soc-in-elk">Treatment of SOC in Elk</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/soc.html#after-generating-the-projectors">After generating the projectors</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#postprocessing">Postprocessing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../guide/analysis.html">Tools for analysis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#initialisation">Initialisation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#density-of-states">Density of states</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#band-resolved-density-matrices">Band resolved density matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#momentum-resolved-spectral-function-with-real-frequency-self-energy">Momentum resolved spectral function (with real-frequency self energy)</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#energy-contours-of-the-k-resolved-spectral-function">Energy contours of the k-resolved Spectral function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/analysis.html#partial-charges">Partial charges</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../guide/transport.html">Transport calculations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#formalism">Formalism</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#prerequisites">Prerequisites</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#using-the-transport-code">Using the transport code</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#example">Example</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../guide/transport.html#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#reference-manual">Reference manual</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.block_structure.html">block_structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.block_structure.BlockStructure.html">triqs_dft_tools.block_structure.BlockStructure</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.converters.html">converters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft.html">sumk_dft</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft.SumkDFT.html">triqs_dft_tools.sumk_dft.SumkDFT</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_tools.html">sumk_dft_tools</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_tools.SumkDFTTools.html">triqs_dft_tools.sumk_dft_tools.SumkDFTTools</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.html">sumk_dft_transport</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.cellvolume.html">triqs_dft_tools.sumk_dft_transport.cellvolume</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.conductivity_and_seebeck.html">triqs_dft_tools.sumk_dft_transport.conductivity_and_seebeck</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.fermi_dis.html">triqs_dft_tools.sumk_dft_transport.fermi_dis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.init_spectroscopy.html">triqs_dft_tools.sumk_dft_transport.init_spectroscopy</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.raman_vertex.html">triqs_dft_tools.sumk_dft_transport.raman_vertex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.read_transport_input_from_hdf.html">triqs_dft_tools.sumk_dft_transport.read_transport_input_from_hdf</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.recompute_w90_input_on_different_mesh.html">triqs_dft_tools.sumk_dft_transport.recompute_w90_input_on_different_mesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.transport_coefficient.html">triqs_dft_tools.sumk_dft_transport.transport_coefficient</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.transport_distribution.html">triqs_dft_tools.sumk_dft_transport.transport_distribution</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.transport_function.html">triqs_dft_tools.sumk_dft_transport.transport_function</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.write_output_to_hdf.html">triqs_dft_tools.sumk_dft_transport.write_output_to_hdf</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.symmetry.html">symmetry</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.symmetry.Symmetry.html">triqs_dft_tools.symmetry.Symmetry</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.trans_basis.html">trans_basis</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.trans_basis.TransBasis.html">triqs_dft_tools.trans_basis.TransBasis</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_python_api/triqs_dft_tools.util.html">util</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_python_api/triqs_dft_tools.util.compute_DC_from_density.html">triqs_dft_tools.util.compute_DC_from_density</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../documentation.html#faqs">FAQs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../faqs/faqs.html">Frequently-Asked Questions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#wien2k-fermi-error-when-running-x-lapw2-almd-band">wien2k: FERMI ERROR when running <cite>x lapw2 -almd -band</cite></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#how-do-i-plot-the-output-of-spaghettis">How do I plot the output of <cite>spaghettis</cite>?</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#x-optic-does-not-write-a-case-pmat-file">x optic does not write a case.pmat file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../faqs/faqs.html#how-do-i-get-real-frequency-quantities">How do I get real-frequency quantities?</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#a-simple-example-srvo3">A simple example: SrVO3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/srvo3.html">DFT (Wien2k) and Wannier orbitals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#dft-setup">DFT setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#wannier-orbitals">Wannier orbitals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/srvo3.html#the-dmft-calculation">The DMFT calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#loading-modules">Loading modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#initializing-sumkdft">Initializing SumkDFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#initializing-the-solver">Initializing the solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#dmft-cycle">DMFT cycle</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/srvo3.html#tail-fit-parameters">Tail fit parameters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#basis-rotations-sr2mgoso6-without-soc">Basis rotations: Sr2MgOsO6 without SOC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html">DFT (Wien2k) and Wannier orbitals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#dft-setup">DFT setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#wannier-orbitals">Wannier orbitals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#the-dmft-calculation">The DMFT calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#rotating-the-basis">Rotating the basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#the-interaction-hamiltonian">The interaction Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_nosoc.html#the-dmft-loop-with-automatic-basis-rotations">The DMFT loop with automatic basis rotations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#sr2mgoso6-with-soc-non-magnetic">Sr2MgOsO6 with SOC (non-magnetic)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html">DFT (Wien2k) and Wannier orbitals</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#dft-setup">DFT setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#wannier-orbitals">Wannier orbitals</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#the-dmft-calculation">The DMFT calculation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#rotating-the-basis">Rotating the basis</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#the-interaction-hamiltonian">The interaction Hamiltonian</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/sr2mgoso6_soc.html#the-dmft-loop-with-automatic-basis-rotations">The DMFT loop with automatic basis rotations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#full-charge-self-consistency-with-wien2k-gamma-ce">Full charge self consistency with Wien2k: <span class="math notranslate nohighlight">\(\gamma\)</span>-Ce</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html">DFT+DMFT tutorial: Ce with Hubbard-I approximation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#wien2k-setup">Wien2k setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#wannier-orbitals-dmftproj">Wannier orbitals: dmftproj</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#dmft-setup-hubbard-i-calculations-in-triqs">DMFT setup: Hubbard-I calculations in TRIQS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#fully-charge-self-consistent-dft-dmft-calculation">Fully charge self-consistent DFT+DMFT calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/ce-gamma-fscs_wien2k.html#post-processing-and-data-analysis">Post-processing and data analysis</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#vasp-interface-examples">VASP interface examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials.html#simple-converter-example-srvo3">Simple Converter example: SrVO3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_vasp/svo_notebook.html">VASP setup</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_vasp/svo_notebook.html#PLOVASP">PLOVASP</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_vasp/svo_notebook.html#Converting-to-hdf5-file">Converting to hdf5 file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials.html#complex-example-nio">Complex example: NiO</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/nio_csc_vasp/nio_csc.html">DFT and projections</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/nio_csc_vasp/nio_csc.html#dmft">DMFT</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/nio_csc_vasp/nio_csc.html#charge-self-consistent-dmft">Charge self-consistent DMFT</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../tutorials.html#elk-interface-examples">Elk interface examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../tutorials.html#converter-example-srvo3">Converter example: SrVO3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_elk/srvo3.html">Elk to TRIQS</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_elk/srvo3.html#the-dmft-calculation">The DMFT calculation</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../tutorials/svo_elk/srvo3.html#triqs-to-elk-fully-charge-self-consistent-dft-dmft">TRIQS to Elk (Fully Charge Self-Consistent DFT+DMFT)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../issues.html">Reporting issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ChangeLog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-3-1">Version 3.3.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#general">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#doc">Doc</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-3-0">Version 3.3.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id2">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#feat">feat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#build">build</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id3">doc</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-2-1">Version 3.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-2-0">Version 3.2.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id4">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#elk">Elk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#vasp">Vasp</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#w90-qe">w90 + QE</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#clean">clean</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-1-1">Version 3.1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id5">General</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-1-0">Version 3.1.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#wannier90-converter">Wannier90 Converter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#change-in-gf-struct">Change in gf_struct</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#documentation">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#cmake">Cmake</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#other-changes">Other changes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-3-0-0">Version 3.0.0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#restructuring">Restructuring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#dependency-management">Dependency Management</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../ChangeLog.html#id6">Other Changes:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-2-2-1">Version 2.2.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-2-2-0">Version 2.2.0</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ChangeLog.html#version-2-1-x-changes-since-1-4">Version 2.1.x (changes since 1.4)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../about.html">About</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../about.html#license">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../about.html#authors-quotation">Authors &amp; Quotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../about.html#disclaimer">Disclaimer</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #7E588A" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">TRIQS DFTTools</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">triqs_dft_tools.sumk_dft_transport</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for triqs_dft_tools.sumk_dft_transport</h1><div class="highlight"><pre>
<span></span><span class="c1">##########################################################################</span>

<span class="c1">#</span>
<span class="c1"># TRIQS: a Toolbox for Research in Interacting Quantum Systems</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2011 by M. Aichhorn, L. Pourovskii, V. Vildosola</span>
<span class="c1"># Copyright (c) 2022-2023 Simons Foundation</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is free software: you can redistribute it and/or modify it under the</span>
<span class="c1"># terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation, either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="c1"># WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># TRIQS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1"># Authors: M. Aichhorn, S. Beck, A. Hampel, L. Pourovskii, V. Vildosola</span>

<span class="c1">##########################################################################</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">try</span><span class="p">:</span> <span class="c1"># try wannierberri import - needs to be placed before importing numpy</span>
    <span class="kn">import</span> <span class="nn">wannierberri</span> <span class="k">as</span> <span class="nn">wb</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">triqs.gf</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">triqs.utility.mpi</span> <span class="k">as</span> <span class="nn">mpi</span>
<span class="kn">from</span> <span class="nn">.symmetry</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">cst</span>
<span class="kn">import</span> <span class="nn">os.path</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;transport_distribution&#39;</span><span class="p">,</span> <span class="s1">&#39;conductivity_and_seebeck&#39;</span><span class="p">,</span> <span class="s1">&#39;write_output_to_hdf&#39;</span><span class="p">,</span>
           <span class="s1">&#39;init_spectroscopy&#39;</span><span class="p">,</span> <span class="s1">&#39;transport_function&#39;</span><span class="p">,</span> <span class="s1">&#39;raman_vertex&#39;</span><span class="p">]</span>

<span class="c1"># ----------------- helper functions -----------------------</span>


<div class="viewcode-block" id="read_transport_input_from_hdf">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.read_transport_input_from_hdf.html#triqs_dft_tools.sumk_dft_transport.read_transport_input_from_hdf">[docs]</a>
<span class="k">def</span> <span class="nf">read_transport_input_from_hdf</span><span class="p">(</span><span class="n">sum_k</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads the data for transport calculations from the hdf5 archive.</span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">assert</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">dft_code</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="s1">&#39;wien2k&#39;</span><span class="p">,</span> <span class="s1">&#39;elk&#39;</span><span class="p">,</span> <span class="s1">&#39;w90&#39;</span><span class="p">),</span> <span class="s2">&quot;read_transport_input_from_hdf() is only implemented for wien2k and elk inputs&quot;</span>

    <span class="k">if</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">dft_code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wien2k&#39;</span><span class="p">,</span> <span class="s1">&#39;elk&#39;</span><span class="p">):</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window_optics&#39;</span><span class="p">,</span> <span class="s1">&#39;velocities_k&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window_optics&#39;</span><span class="p">]</span>

    <span class="n">sum_k</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span><span class="n">subgrp</span><span class="o">=</span><span class="n">sum_k</span><span class="o">.</span><span class="n">transp_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">thingstoread</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">dft_code</span> <span class="o">==</span> <span class="s2">&quot;wien2k&quot;</span><span class="p">):</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window&#39;</span><span class="p">,</span> <span class="s1">&#39;lattice_angles&#39;</span><span class="p">,</span> <span class="s1">&#39;lattice_constants&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;lattice_type&#39;</span><span class="p">,</span> <span class="s1">&#39;n_symmetries&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_symmetries&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">dft_code</span> <span class="o">==</span> <span class="s2">&quot;elk&quot;</span><span class="p">):</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window&#39;</span><span class="p">,</span> <span class="s1">&#39;n_symmetries&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_symmetries&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;cell_vol&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">dft_code</span> <span class="o">==</span> <span class="s1">&#39;w90&#39;</span><span class="p">):</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window&#39;</span><span class="p">,</span> <span class="s1">&#39;n_symmetries&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_symmetries&#39;</span><span class="p">]</span>

    <span class="n">sum_k</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span><span class="n">subgrp</span><span class="o">=</span><span class="n">sum_k</span><span class="o">.</span><span class="n">misc_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">thingstoread</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">dft_code</span> <span class="o">==</span> <span class="s2">&quot;wien2k&quot;</span><span class="p">):</span>
        <span class="n">sum_k</span><span class="o">.</span><span class="n">cell_vol</span> <span class="o">=</span> <span class="n">cellvolume</span><span class="p">(</span>
            <span class="n">sum_k</span><span class="o">.</span><span class="n">lattice_type</span><span class="p">,</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">,</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">lattice_angles</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sum_k</span></div>



<div class="viewcode-block" id="write_output_to_hdf">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.write_output_to_hdf.html#triqs_dft_tools.sumk_dft_transport.write_output_to_hdf">[docs]</a>
<span class="k">def</span> <span class="nf">write_output_to_hdf</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">things_to_save</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s1">&#39;user_data&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves data from a list into the HDF file. Prints a warning if a requested data is not found in SumkDFT object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hdf_file : hdf5 archive</span>
<span class="sd">               hd5 file</span>
<span class="sd">    things_to_save : list of strings</span>
<span class="sd">                     List of datasets to be saved into the hdf5 file.</span>
<span class="sd">    subgrp : string, optional</span>
<span class="sd">             Name of hdf5 file subgroup in which the data are to be stored.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
        <span class="k">return</span>  <span class="c1"># do nothing on nodes</span>
    <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
            <span class="n">ar</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">it</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">things_to_save</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gf_struct_sumk&quot;</span><span class="p">,</span> <span class="s2">&quot;gf_struct_solver&quot;</span><span class="p">,</span>
                      <span class="s2">&quot;solver_to_sumk&quot;</span><span class="p">,</span> <span class="s2">&quot;sumk_to_solver&quot;</span><span class="p">,</span> <span class="s2">&quot;solver_to_sumk_block&quot;</span><span class="p">]:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;It is not recommended to save &#39;</span><span class="si">{}</span><span class="s2">&#39; individually. Save &#39;block_structure&#39; instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
            <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span></div>



<div class="viewcode-block" id="cellvolume">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.cellvolume.html#triqs_dft_tools.sumk_dft_transport.cellvolume">[docs]</a>
<span class="k">def</span> <span class="nf">cellvolume</span><span class="p">(</span><span class="n">lattice_type</span><span class="p">,</span> <span class="n">lattice_constants</span><span class="p">,</span> <span class="n">latticeangle</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines the conventional und primitive unit cell volumes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lattice_type : string</span>
<span class="sd">        Lattice type according to the Wien2k convention (P, F, B, R, H, CXY, CYZ, CXZ).</span>
<span class="sd">    lattice_constants : list of double</span>
<span class="sd">        Lattice constants (a, b, c).</span>
<span class="sd">    lattice angles : list of double</span>
<span class="sd">        Lattice angles (:math:`\alpha, \beta, \gamma`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vol_c : double</span>
<span class="sd">        Conventional unit cell volume.</span>
<span class="sd">    vol_p : double</span>
<span class="sd">        Primitive unit cell volume.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">c_al</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latticeangle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">c_be</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latticeangle</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">c_ga</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latticeangle</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">vol_c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> \
        <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_al</span> <span class="o">*</span> <span class="n">c_be</span> <span class="o">*</span> <span class="n">c_ga</span> <span class="o">-</span>
                   <span class="n">c_al</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">c_be</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">c_ga</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">det</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
           <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;CXY&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;CYZ&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;CXZ&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
    <span class="n">vol_p</span> <span class="o">=</span> <span class="n">vol_c</span> <span class="o">/</span> <span class="n">det</span><span class="p">[</span><span class="n">lattice_type</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">vol_c</span><span class="p">,</span> <span class="n">vol_p</span></div>



<div class="viewcode-block" id="fermi_dis">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.fermi_dis.html#triqs_dft_tools.sumk_dft_transport.fermi_dis">[docs]</a>
<span class="k">def</span> <span class="nf">fermi_dis</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fermi distribution.</span>

<span class="sd">    .. math::</span>
<span class="sd">       f(x) = 1/(e^x+1).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    w : double</span>
<span class="sd">       frequency</span>
<span class="sd">    beta : double</span>
<span class="sd">       inverse temperature</span>
<span class="sd">    der : integer</span>
<span class="sd">       order of derivative</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f : double</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exponent</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">longdouble</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span>
    <span class="n">fermi</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">der</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fermi</span>
    <span class="k">elif</span> <span class="n">der</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">fermi</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">exponent</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;higher order of derivative than 1 not implemented&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="recompute_w90_input_on_different_mesh">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.recompute_w90_input_on_different_mesh.html#triqs_dft_tools.sumk_dft_transport.recompute_w90_input_on_different_mesh">[docs]</a>
<span class="k">def</span> <span class="nf">recompute_w90_input_on_different_mesh</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">seedname</span><span class="p">,</span> <span class="n">nk_optics</span><span class="p">,</span> <span class="n">pathname</span><span class="o">=</span><span class="s1">&#39;./&#39;</span><span class="p">,</span> <span class="n">calc_velocity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">calc_inverse_mass</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">oc_select</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">oc_basis</span><span class="o">=</span><span class="s1">&#39;h&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recomputes dft_input objects on a finer mesh using WannierBerri and Wannier90 input.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    seedname: string</span>
<span class="sd">              Wannier90 seedname</span>
<span class="sd">    nk_optics: single integer/float or three integers</span>
<span class="sd">               if single integer given, mesh is [nk_optics, nk_optics, nk_optics]</span>
<span class="sd">               elif single float given, mesh is ceiling of *sum_k.kpts * nk_optics</span>
<span class="sd">               elif three integers given, mesh is nk_optics</span>
<span class="sd">    pathname : string, optional, default=&#39;./&#39;</span>
<span class="sd">               location of Wannier90 data</span>
<span class="sd">    calc_velocity : boolean, optional, default=False</span>
<span class="sd">                    whether the velocity (first derivative of H(k)) is computed</span>
<span class="sd">    calc_inverse_mass : boolean, optional, default=False</span>
<span class="sd">                        whether the inverse effective mass (second derivative of H(k)) is computed</span>
<span class="sd">    oc_select : string, optional, default=&#39;both&#39;</span>
<span class="sd">                select contributions for optical conductivity from [&#39;intra&#39;, &#39;inter&#39;, &#39;both&#39;]</span>
<span class="sd">    oc_basis : string, optional, default=&#39;h&#39;</span>
<span class="sd">               gauge choice options &#39;h&#39; for Hamiltonian/band and &#39;w&#39; for Wannier basis</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    things_to_store : dictionary</span>
<span class="sd">                      dictionary of datasets to be temporarily overwritten</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Starting Wannier interpolation...&#39;</span><span class="p">)</span>

    <span class="n">BOHRTOANG</span> <span class="o">=</span> <span class="n">cst</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;Bohr radius&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cst</span><span class="o">.</span><span class="n">angstrom</span>
    <span class="n">HARTREETOEV</span> <span class="o">=</span> <span class="n">cst</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;Hartree energy&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cst</span><span class="o">.</span><span class="n">eV</span>
    <span class="n">n_inequiv_spin_blocks</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SO</span>

    <span class="c1"># set-up k mesh depending on input shape</span>
    <span class="c1"># read in transport input and some checks</span>
    <span class="n">read_transport_input_from_hdf</span><span class="p">(</span><span class="n">sum_k</span><span class="p">)</span>

    <span class="c1"># first check for right formatting of sum_k.nk_optics</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nk_optics</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s1">&#39;&quot;nk_optics&quot; must be given as three integers or one float&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nk_optics</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nk_optics</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="s1">&#39;&quot;nk_optics&quot; single value must be float or integer&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nk_optics</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nk_optics</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">int</span><span class="p">,</span> <span class="s1">&#39;&quot;nk_optics&quot; mesh must be integers&#39;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nk_optics</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">interpolate_factor</span> <span class="o">=</span> <span class="n">nk_optics</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">nk_x</span><span class="p">,</span> <span class="n">nk_y</span><span class="p">,</span> <span class="n">nk_z</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">interpolate_factor</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">kpts</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])))),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nk_x</span><span class="p">,</span> <span class="n">nk_y</span><span class="p">,</span> <span class="n">nk_z</span> <span class="o">=</span> <span class="n">nk_optics</span>

    <span class="c1"># check for spin calculation (not supported)</span>
    <span class="k">assert</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;spin dependent transport calculations are not supported.&#39;</span>

    <span class="n">n_orb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">sum_k</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">n_k</span><span class="p">)])</span>

    <span class="c1"># temporarily recompute the following quantities on a different mesh</span>
    <span class="n">things_to_modify</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;bz_weights&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;hopping&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;kpt_weights&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;kpts&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s1">&#39;n_k&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;n_orbitals&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;proj_mat&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;band_window&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;band_window_optics&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>
    <span class="n">things_to_store</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">things_to_modify</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># initialize variables</span>
    <span class="n">n_kpts</span> <span class="o">=</span> <span class="n">nk_x</span> <span class="o">*</span> <span class="n">nk_y</span> <span class="o">*</span> <span class="n">nk_z</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpts</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">hopping</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_kpts</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">proj_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span>
        <span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">cell_volume</span> <span class="o">=</span> <span class="n">kpts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">calc_velocity</span><span class="p">:</span>
        <span class="n">velocities_k</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">calc_inverse_mass</span><span class="p">:</span>
        <span class="n">inverse_mass</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>

        <span class="k">if</span> <span class="s1">&#39;wannierberri&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ImportError: WannierBerri needs to be installed to run optics calculations with Wannier90&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="o">.</span><span class="n">Abort</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
        <span class="c1"># initialize WannierBerri system</span>
        <span class="n">shift_gamma</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="n">wberri</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">System_w90</span><span class="p">(</span><span class="n">pathname</span> <span class="o">+</span> <span class="n">seedname</span><span class="p">,</span> <span class="n">berry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">Grid</span><span class="p">(</span><span class="n">wberri</span><span class="p">,</span> <span class="n">NKdiv</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">NKFFT</span><span class="o">=</span><span class="p">[</span><span class="n">nk_x</span><span class="p">,</span> <span class="n">nk_y</span><span class="p">,</span> <span class="n">nk_z</span><span class="p">])</span>
        <span class="n">dataK</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">data_K</span><span class="o">.</span><span class="n">Data_K_R</span><span class="p">(</span><span class="n">wberri</span><span class="p">,</span> <span class="n">dK</span><span class="o">=</span><span class="n">shift_gamma</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="n">grid</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">dataK</span><span class="o">.</span><span class="n">HH_K</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;wberri / wannier Hamiltonian has different number of orbitals than SumK object. Disentanglement is not supported as of now.&#39;</span>

        <span class="c1"># read in hoppings and proj_mat</span>
        <span class="k">if</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">hopping</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">hopping</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">E_K</span>
        <span class="k">elif</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">HH_K</span>
            <span class="n">fake_proj_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">dataK</span><span class="o">.</span><span class="n">UU_K</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
            <span class="n">fake_proj_mat</span><span class="p">[:,</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fake_proj_mat</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span>
                <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fake_proj_mat</span><span class="p">)[</span><span class="mi">2</span><span class="p">])]</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inequiv_spin_blocks</span><span class="p">):</span>
            <span class="n">iorb</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
                    <span class="n">proj_mat</span><span class="p">[:,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">UU_K</span><span class="p">[:,</span> <span class="n">iorb</span><span class="p">:</span><span class="n">iorb</span><span class="o">+</span><span class="n">dim</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">elif</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                    <span class="n">proj_mat</span><span class="p">[:,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fake_proj_mat</span><span class="p">[:,</span> <span class="n">iorb</span><span class="p">:</span><span class="n">iorb</span><span class="o">+</span><span class="n">dim</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">iorb</span> <span class="o">+=</span> <span class="n">dim</span>

        <span class="k">if</span> <span class="n">calc_velocity</span><span class="p">:</span>
            <span class="c1"># velocity: [k x n_orb x n_orb x R]</span>
            <span class="k">def</span> <span class="nf">_commutator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
                <span class="n">term1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;kmo, kona -&gt; kmna&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
                <span class="n">term2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;kmoa, kon -&gt; kmna&#39;</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">term1</span> <span class="o">-</span> <span class="n">term2</span>

            <span class="c1"># in the band basis</span>
            <span class="c1"># vh_alpha = Hhbar_alpha + i [Hh, Ahbar_alpha]</span>
            <span class="k">if</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
                <span class="c1"># first term</span>
                <span class="n">Hhbar_alpha</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">Xbar</span><span class="p">(</span><span class="s1">&#39;Ham&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># second term</span>
                <span class="n">c_Hh_Ahbar_alpha</span> <span class="o">=</span> <span class="n">_commutator</span><span class="p">(</span><span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">dataK</span><span class="o">.</span><span class="n">Xbar</span><span class="p">(</span><span class="s1">&#39;AA&#39;</span><span class="p">))</span>
                <span class="n">velocities_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">Hhbar_alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">c_Hh_Ahbar_alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">HARTREETOEV</span> <span class="o">/</span> <span class="n">BOHRTOANG</span>

                <span class="c1"># split into diag and offdiag elements, corresponding to intra- and interband contributions</span>
                <span class="n">v_diag</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
                <span class="n">v_diag</span><span class="p">[:,</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
                       <span class="nb">range</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)[</span><span class="mi">2</span><span class="p">]),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">velocities_k</span><span class="p">[:,</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span>
                                                                              <span class="nb">range</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)[</span><span class="mi">2</span><span class="p">]),</span> <span class="p">:]</span>
                <span class="n">v_offdiag</span> <span class="o">=</span> <span class="n">velocities_k</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">v_offdiag</span><span class="p">[:,</span> <span class="nb">range</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)[</span><span class="mi">2</span><span class="p">]),</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="mf">0.0</span>

                <span class="k">if</span> <span class="n">oc_select</span> <span class="o">==</span> <span class="s1">&#39;intra&#39;</span><span class="p">:</span>
                    <span class="n">velocities_k</span> <span class="o">=</span> <span class="n">v_diag</span>
                <span class="k">elif</span> <span class="n">oc_select</span> <span class="o">==</span> <span class="s1">&#39;inter&#39;</span><span class="p">:</span>
                    <span class="n">velocities_k</span> <span class="o">=</span> <span class="n">v_offdiag</span>
                <span class="k">elif</span> <span class="n">oc_select</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
                    <span class="n">velocities_k</span> <span class="o">=</span> <span class="n">v_diag</span> <span class="o">+</span> <span class="n">v_offdiag</span>

            <span class="c1"># in the orbital basis</span>
            <span class="c1"># vw_alpha = Hw_alpha + i [Hw, Aw_alpha]</span>
            <span class="k">elif</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="c1"># first term</span>
                <span class="n">Hw_R</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">get_R_mat</span><span class="p">(</span><span class="s1">&#39;Ham&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">Hw_alpha</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">rvec</span><span class="o">.</span><span class="n">R_to_k</span><span class="p">(</span><span class="n">Hw_R</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="n">dataK</span><span class="o">.</span><span class="n">select_K</span><span class="p">]</span>
                <span class="c1"># second term</span>
                <span class="n">Aw_R</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">get_R_mat</span><span class="p">(</span><span class="s1">&#39;AA&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">Aw_alpha</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">rvec</span><span class="o">.</span><span class="n">R_to_k</span><span class="p">(</span><span class="n">Aw_R</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="n">dataK</span><span class="o">.</span><span class="n">select_K</span><span class="p">]</span>
                <span class="n">c_Hw_Aw_alpha</span> <span class="o">=</span> <span class="n">_commutator</span><span class="p">(</span><span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">Aw_alpha</span><span class="p">)</span>
                <span class="n">velocities_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">Hw_alpha</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">c_Hw_Aw_alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">HARTREETOEV</span> <span class="o">/</span> <span class="n">BOHRTOANG</span>

        <span class="k">if</span> <span class="n">calc_inverse_mass</span><span class="p">:</span>
            <span class="c1"># approximating this as the first term in eq (28) in PRB 75, 195121 (2007)</span>
            <span class="c1"># application published in PHYSICAL REVIEW RESEARCH 6, 023124 (2024)</span>
            <span class="c1"># Procedure is the same as for calc_velocity, but using second derivative of Hamiltonian.</span>
            <span class="c1"># in the band basis</span>
            <span class="k">if</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
                <span class="n">inverse_mass</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">Xbar</span><span class="p">(</span><span class="s1">&#39;Ham&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="c1"># in the orbital basis</span>
            <span class="k">elif</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">inverse_mass</span> <span class="o">=</span> <span class="n">wb</span><span class="o">.</span><span class="n">data_K</span><span class="o">.</span><span class="n">Data_K_R</span><span class="o">.</span><span class="n">_R_to_k_H</span><span class="p">(</span><span class="n">dataK</span><span class="p">,</span> <span class="n">dataK</span><span class="o">.</span><span class="n">Ham_R</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">hermitian</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">inverse_mass</span> <span class="o">=</span> <span class="n">inverse_mass</span> <span class="o">/</span> <span class="n">HARTREETOEV</span> <span class="o">/</span> <span class="n">BOHRTOANG</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># read in rest from dataK</span>
        <span class="n">cell_volume</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">cell_volume</span> <span class="o">/</span> <span class="n">BOHRTOANG</span> <span class="o">**</span> <span class="mi">3</span>
        <span class="n">kpts</span> <span class="o">=</span> <span class="n">dataK</span><span class="o">.</span><span class="n">kpoints_all</span>

    <span class="c1"># broadcast everything</span>
    <span class="n">sum_k</span><span class="o">.</span><span class="n">cell_vol</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">cell_volume</span><span class="p">)</span>
    <span class="n">kpts</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">kpts</span><span class="p">)</span>
    <span class="n">hopping</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">hopping</span><span class="p">)</span>
    <span class="n">proj_mat</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">proj_mat</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">calc_velocity</span><span class="p">:</span>
        <span class="n">velocities_k</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">velocities_k</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">calc_inverse_mass</span><span class="p">:</span>
        <span class="n">inverse_mass</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">inverse_mass</span><span class="p">)</span>

    <span class="c1"># write interpolated sumk quantities into &quot;things_to_modify&quot;</span>
    <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;n_k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_kpts</span>
    <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;n_orbitals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_kpts</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">n_orb</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bz_weights&#39;</span><span class="p">,</span> <span class="s1">&#39;kpt_weights&#39;</span><span class="p">]:</span>
        <span class="n">things_to_modify</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_kpts</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">n_kpts</span><span class="p">)</span>
    <span class="n">n_inequiv_spin_blocks</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SO</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;band_window&#39;</span><span class="p">,</span> <span class="s1">&#39;band_window_optics&#39;</span><span class="p">]:</span>
        <span class="n">things_to_modify</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_kpts</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                                 <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inequiv_spin_blocks</span><span class="p">)]</span>
    <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;kpts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kpts</span>
    <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;hopping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hopping</span>
    <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;proj_mat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">proj_mat</span>
    <span class="k">if</span> <span class="n">calc_velocity</span><span class="p">:</span>
        <span class="n">sum_k</span><span class="o">.</span><span class="n">velocities_k</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;velocities_k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocities_k</span>
    <span class="k">if</span> <span class="n">calc_inverse_mass</span><span class="p">:</span>
        <span class="n">sum_k</span><span class="o">.</span><span class="n">inverse_mass</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">things_to_modify</span><span class="p">[</span><span class="s1">&#39;inverse_mass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_mass</span>

    <span class="c1"># now save previous sum_k instances into &quot;things_to_store&quot; and overwrite</span>
    <span class="c1"># TODO: decide whether this should be undone after the run</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">things_to_modify</span><span class="p">:</span>
        <span class="n">things_to_store</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">things_to_modify</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="c1"># write velocities to file</span>
    <span class="k">if</span> <span class="n">calc_velocity</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_transp_input&#39;</span><span class="p">][</span><span class="s1">&#39;velocities_k&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocities_k</span>
    <span class="k">if</span> <span class="n">calc_inverse_mass</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
            <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_transp_input&#39;</span><span class="p">][</span><span class="s1">&#39;inverse_mass&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inverse_mass</span>

    <span class="k">return</span> <span class="n">sum_k</span><span class="p">,</span> <span class="n">things_to_store</span></div>


<span class="c1"># ----------------- transport -----------------------</span>

<div class="viewcode-block" id="raman_vertex">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.raman_vertex.html#triqs_dft_tools.sumk_dft_transport.raman_vertex">[docs]</a>
<span class="k">def</span> <span class="nf">raman_vertex</span><span class="p">(</span><span class="n">sumk</span><span class="p">,</span><span class="n">ik</span><span class="p">,</span><span class="n">direction</span><span class="p">,</span><span class="n">code</span><span class="p">,</span><span class="n">isp</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads all necessary quantities for transport calculations from transport subgroup of the hdf5 archive.</span>
<span class="sd">    Performs checks on input. Uses interpolation if code=wannier90.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    ik : integer</span>
<span class="sd">            the ik index in which will be calculate the raman vertex</span>
<span class="sd">    direction : string</span>
<span class="sd">            direction to calculate the Raman vertex. </span>
<span class="sd">    code : string</span>
<span class="sd">        DFT code from which velocities are being read. Options: &#39;wien2k&#39;, &#39;wannier90&#39;</span>
<span class="sd">    isp : integer</span>
<span class="sd">            spin index</span>
<span class="sd">    options : dictionary, optional</span>
<span class="sd">        additional keywords necessary in case a new direction wants to be implemented</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    raman_vertex : 2D array</span>
<span class="sd">            numpy array size [n_orb, n_orb] of complex type</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wien2k&#39;</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Raman for wien2k not yet implemented&#39;</span> 
    <span class="n">dir_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;xx&#39;</span><span class="p">,</span><span class="s1">&#39;yy&#39;</span><span class="p">,</span><span class="s1">&#39;zz&#39;</span><span class="p">,</span><span class="s1">&#39;B2g&#39;</span><span class="p">,</span><span class="s1">&#39;B1g&#39;</span><span class="p">,</span><span class="s1">&#39;A1g&#39;</span><span class="p">,</span><span class="s1">&#39;Eg&#39;</span><span class="p">]</span>
    <span class="n">dir_array</span><span class="o">=</span><span class="p">[</span> <span class="p">[[</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">]],</span>
                <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">1.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">],[</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">]]</span> <span class="p">]</span>
    <span class="c1"># Load custom directions</span>
    <span class="k">if</span> <span class="s2">&quot;custom_dir&quot;</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;custom_dir&quot;</span><span class="p">],</span><span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;raman_vertex: in options, custom_dir must be a dictionary&quot;</span>
        <span class="k">for</span> <span class="n">dire</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;custom_dir&quot;</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;custom_dir&quot;</span><span class="p">][</span><span class="n">dire</span><span class="p">]))</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;raman_vertex: custom_dir must have shape 3x3 (a numpy array or a nested list)&quot;</span>
            <span class="k">if</span> <span class="n">dire</span> <span class="ow">in</span> <span class="n">dir_names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction</span><span class="o">==</span><span class="n">dire</span> <span class="ow">and</span> <span class="n">ik</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c1">#reports only when ik==0</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Warning: the direction </span><span class="si">%s</span><span class="s2"> was already loaded and will be replace with the one provided in custom_dir&quot;</span><span class="o">%</span><span class="n">dire</span><span class="p">)</span>
                <span class="n">idir</span> <span class="o">=</span> <span class="n">dir_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dire</span><span class="p">)</span>
                <span class="n">dir_array</span><span class="p">[</span><span class="n">idir</span><span class="p">]</span><span class="o">=</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;custom_dir&quot;</span><span class="p">][</span><span class="n">dire</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dir_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dire</span><span class="p">)</span>
                <span class="n">dir_array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;custom_dir&quot;</span><span class="p">][</span><span class="n">dire</span><span class="p">])</span>
    
    <span class="n">dir_array</span><span class="o">=</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">el</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">dir_array</span><span class="p">]</span> <span class="c1"># convert list to numpy array</span>

    <span class="k">if</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">dir_names</span><span class="p">:</span>
        <span class="n">idir</span> <span class="o">=</span> <span class="n">dir_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span><span class="s1">&#39;raman_vertex: direction </span><span class="si">%s</span><span class="s1"> is not supported by default. Try to add it by raman_vertex options custom_dir.&#39;</span><span class="o">%</span><span class="n">direction</span>
    <span class="n">n_bands</span> <span class="o">=</span> <span class="n">sumk</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">][</span><span class="n">isp</span><span class="p">]</span>
    <span class="n">ram_vert</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span><span class="n">n_bands</span><span class="p">,</span> <span class="n">n_bands</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_bands</span><span class="p">):</span>
            <span class="n">ram_vert</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dir_array</span><span class="p">[</span><span class="n">idir</span><span class="p">],</span><span class="n">sumk</span><span class="o">.</span><span class="n">inverse_mass</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,:,:])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">ram_vert</span></div>


<div class="viewcode-block" id="init_spectroscopy">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.init_spectroscopy.html#triqs_dft_tools.sumk_dft_transport.init_spectroscopy">[docs]</a>
<span class="k">def</span> <span class="nf">init_spectroscopy</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;wien2k&#39;</span><span class="p">,</span> <span class="n">w90_params</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads all necessary quantities for transport calculations from transport subgroup of the hdf5 archive.</span>
<span class="sd">    Performs checks on input. Uses interpolation if code=wannier90.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    code : string</span>
<span class="sd">        DFT code from which velocities are being read. Options: &#39;wien2k&#39;, &#39;wannier90&#39;</span>
<span class="sd">    w90_params : dictionary, optional</span>
<span class="sd">        additional keywords necessary in case code == &#39;wannier90&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object, interpolated</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Initializing optical conductivity...&#39;</span><span class="p">)</span>
    <span class="c1"># up and down are equivalent if SP = 0</span>
    <span class="n">n_inequiv_spin_blocks</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SO</span>

    <span class="c1"># ----------------- set-up input from DFT -----------------------</span>
    <span class="k">if</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wien2k&#39;</span><span class="p">,</span> <span class="s1">&#39;elk&#39;</span><span class="p">):</span>
        <span class="c1"># Check if wien converter was called and read transport subgroup form</span>
        <span class="c1"># hdf file</span>
        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">transp_data</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s2">&quot;transport_distribution: No </span><span class="si">%s</span><span class="s2"> subgroup in hdf file found! Call convert_transp_input first.&quot;</span> <span class="o">%</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">transp_data</span><span class="p">)</span>
            <span class="c1"># check if outputs file was converted</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s1">&#39;n_symmetries&#39;</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s2">&quot;transport_distribution: n_symmetries missing. Check if case.outputs file is present and call convert_misc_input() or convert_dft_input().&quot;</span><span class="p">)</span>

        <span class="n">sum_k</span> <span class="o">=</span> <span class="n">read_transport_input_from_hdf</span><span class="p">(</span><span class="n">sum_k</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wannier90&#39;</span><span class="p">):</span>
        <span class="n">required_entries</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;seedname&#39;</span><span class="p">,</span> <span class="s1">&#39;nk_optics&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="n">entry</span> <span class="ow">in</span> <span class="n">w90_params</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">required_entries</span><span class="p">),</span> <span class="s1">&#39;Please provide additional keywords &quot;seedname&quot; and &quot;nk_optics&quot; for &quot;code = &quot;wannier90&quot;&quot;&#39;</span>
        <span class="c1"># check if spin-unpolarized</span>
        <span class="k">assert</span> <span class="n">n_inequiv_spin_blocks</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Spin-polarized optical conductivity calculations not implemented with Wannier90&quot;</span>

        <span class="c1"># check some of the input</span>
        <span class="n">pathname</span> <span class="o">=</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;pathname&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pathname&#39;</span> <span class="ow">in</span> <span class="n">w90_params</span> <span class="k">else</span> <span class="s1">&#39;./&#39;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span>
                   <span class="s1">&#39;seedname&#39;</span><span class="p">,</span> <span class="s1">&#39;pathname&#39;</span><span class="p">]),</span> <span class="sa">f</span><span class="s1">&#39;Check pathname </span><span class="si">{</span><span class="n">w90_params</span><span class="p">[</span><span class="s2">&quot;pathname&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> and seedname </span><span class="si">{</span><span class="n">w90_params</span><span class="p">[</span><span class="s2">&quot;seedname&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">file_ending</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.wout&#39;</span><span class="p">,</span> <span class="s1">&#39;_hr.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;.chk&#39;</span><span class="p">,</span> <span class="s1">&#39;.mmn&#39;</span><span class="p">,</span> <span class="s1">&#39;.eig&#39;</span><span class="p">]:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="p">[</span><span class="n">pathname</span><span class="p">,</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;seedname&#39;</span><span class="p">],</span> <span class="n">file_ending</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span>
                <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filename</span><span class="p">)),</span> <span class="sa">f</span><span class="s1">&#39;Filename </span><span class="si">{</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span><span class="si">}</span><span class="s1"> does not exist!&#39;</span>
        <span class="n">calc_velocity</span> <span class="o">=</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;calc_velocity&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;calc_velocity&#39;</span> <span class="ow">in</span> <span class="n">w90_params</span> <span class="k">else</span> <span class="kc">True</span>
        <span class="n">calc_inverse_mass</span> <span class="o">=</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;calc_inverse_mass&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;calc_inverse_mass&#39;</span> <span class="ow">in</span> <span class="n">w90_params</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span>
                   <span class="n">calc_velocity</span><span class="p">,</span> <span class="n">calc_inverse_mass</span><span class="p">]),</span> <span class="sa">f</span><span class="s1">&#39;Parameter </span><span class="si">{</span><span class="n">calc_velocity</span><span class="si">}</span><span class="s1"> or </span><span class="si">{</span><span class="n">calc_inverse_mass</span><span class="si">}</span><span class="s1"> not bool!&#39;</span>

        <span class="c1"># select contributions to be used</span>
        <span class="n">oc_select</span> <span class="o">=</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;oc_select&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;oc_select&#39;</span> <span class="ow">in</span> <span class="n">w90_params</span> <span class="k">else</span> <span class="s1">&#39;both&#39;</span>
        <span class="k">assert</span> <span class="n">oc_select</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;intra&#39;</span><span class="p">,</span> <span class="s1">&#39;inter&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;both&#39;</span><span class="p">],</span> <span class="s1">&#39;&quot;oc_select&quot; needs to be either [&quot;intra&quot;, &quot;inter&quot;, &quot;both&quot;]&#39;</span>
        <span class="c1"># gauge choice options &#39;h&#39; for Hamiltonian and &#39;w&#39; for Wannier</span>
        <span class="n">oc_basis</span> <span class="o">=</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;oc_basis&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;oc_basis&#39;</span> <span class="ow">in</span> <span class="n">w90_params</span> <span class="k">else</span> <span class="s1">&#39;h&#39;</span>
        <span class="k">assert</span> <span class="n">oc_basis</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">],</span> <span class="s1">&#39;&quot;oc_basis&quot; needs to be either [&quot;h&quot;, &quot;w&quot;]&#39;</span>
        <span class="c1"># finally, make sure oc_select is &#39;both&#39; for oc_basis = &#39;w&#39;</span>
        <span class="k">if</span> <span class="n">oc_basis</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span> <span class="ow">and</span> <span class="n">oc_select</span> <span class="o">!=</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;&quot;oc_select&quot; must be &quot;both&quot; for &quot;oc_basis&quot; = &quot;w&quot;!&#39;</span><span class="p">)</span>
            <span class="n">oc_select</span> <span class="o">=</span> <span class="s1">&#39;both&#39;</span>
        <span class="c1"># further checks for calc_inverse_mass</span>
        <span class="k">if</span> <span class="n">calc_inverse_mass</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">oc_select</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;oc_select&quot; not implemented for &quot;calc_inverse_mass&quot;&#39;</span>
        <span class="c1"># print some information</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;Basis choice [h (Hamiltonian), w (Wannier)]:&quot;</span><span class="si">:</span><span class="s1">&lt;60s</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">oc_basis</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;Contributions from [intra(-band), inter(-band), both]:&quot;</span><span class="si">:</span><span class="s1">&lt;60s</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">oc_select</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># recompute sum_k instances on denser grid</span>
        <span class="n">sum_k</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">recompute_w90_input_on_different_mesh</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;seedname&#39;</span><span class="p">],</span> <span class="n">nk_optics</span><span class="o">=</span><span class="n">w90_params</span><span class="p">[</span><span class="s1">&#39;nk_optics&#39;</span><span class="p">],</span> <span class="n">pathname</span><span class="o">=</span><span class="n">pathname</span><span class="p">,</span>
                                                         <span class="n">calc_velocity</span><span class="o">=</span><span class="n">calc_velocity</span><span class="p">,</span> <span class="n">calc_inverse_mass</span><span class="o">=</span><span class="n">calc_inverse_mass</span><span class="p">,</span> <span class="n">oc_select</span><span class="o">=</span><span class="n">oc_select</span><span class="p">,</span> <span class="n">oc_basis</span><span class="o">=</span><span class="n">oc_basis</span><span class="p">)</span>

    <span class="c1"># k-dependent-projections.</span>
    <span class="c1"># to be checked. But this should be obsolete atm, works for both cases</span>
    <span class="c1"># k_dep_projection is nowhere used</span>
    <span class="c1"># assert sum_k.k_dep_projection == 0, &quot;transport_distribution: k dependent projection is not implemented!&quot;</span>

    <span class="k">return</span> <span class="n">sum_k</span></div>


<span class="c1"># Uses .data of only GfReFreq objects.</span>


<div class="viewcode-block" id="transport_distribution">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.transport_distribution.html#triqs_dft_tools.sumk_dft_transport.transport_distribution">[docs]</a>
<span class="k">def</span> <span class="nf">transport_distribution</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;xx&#39;</span><span class="p">],</span> <span class="n">energy_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_om</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="s1">&#39;wien2k&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;optics&#39;</span><span class="p">,</span> <span class="n">raman_options</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the transport distribution</span>

<span class="sd">    .. math::</span>
<span class="sd">       \Gamma_{\alpha\beta}\left(\omega+\Omega/2, \omega-\Omega/2\right) = \frac{1}{V} \sum_k Tr\left(v_{k,\alpha}A_{k}(\omega+\Omega/2)v_{k,\beta}A_{k}\left(\omega-\Omega/2\right)\right)</span>

<span class="sd">    in the direction :math:`\alpha\beta`. The velocities :math:`v_{k}` are read from the transport subgroup of the hdf5 archive.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sum_k : sum_k object</span>
<span class="sd">            triqs SumkDFT object</span>
<span class="sd">    beta : double</span>
<span class="sd">        Inverse temperature :math:`\beta`.</span>
<span class="sd">    directions : list of string, optional</span>
<span class="sd">        :math:`\alpha\beta` e.g.: [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;,&#39;xy&#39;,&#39;xz&#39;,&#39;yz&#39;].</span>
<span class="sd">    energy_window : list of double, optional</span>
<span class="sd">        Specifies the upper and lower limit of the frequency integration for :math:`\Omega=0.0`. The window is automatically enlarged by the largest :math:`\Omega` value,</span>
<span class="sd">        hence the integration is performed in the interval [energy_window[0]-max(Om_mesh), energy_window[1]+max(Om_mesh)].</span>
<span class="sd">    Om_mesh : list of double, optional</span>
<span class="sd">        :math:`\Omega` frequency mesh of the optical conductivity. For the conductivity and the Seebeck coefficient :math:`\Omega=0.0` has to be</span>
<span class="sd">        part of the mesh. In the current version Om_mesh is repined to the mesh provided by the self-energy! The actual mesh is printed on the screen and given as output.</span>
<span class="sd">    with_Sigma : boolean, optional</span>
<span class="sd">        Determines whether the calculation is performed with or without self energy. If this parameter is set to False the self energy is set to zero (i.e. the DFT band</span>
<span class="sd">        structure :math:`A(k,\omega)` is used). Note: For with_Sigma=False it is necessary to specify the parameters energy_window, n_om and broadening.</span>
<span class="sd">    n_om : integer, optional</span>
<span class="sd">        Number of equidistant frequency points in the interval [energy_window[0]-max(Om_mesh), energy_window[1]+max(Om_mesh)]. This parameters is only used if</span>
<span class="sd">        with_Sigma = False.</span>
<span class="sd">    broadening : double, optional</span>
<span class="sd">        Lorentzian broadening. It is necessary to specify the boradening if with_Sigma = False, otherwise this parameter can be set to 0.0.</span>
<span class="sd">    code : string</span>
<span class="sd">        DFT code from which velocities are being read. Options: &#39;wien2k&#39;, &#39;wannier90&#39;</span>
<span class="sd">    mode : string</span>
<span class="sd">        Choose between optical (&#39;optics&#39;) or Raman (&#39;raman&#39;) transport distribution.</span>
<span class="sd">    raman_options : dictionary</span>
<span class="sd">        additional keywords necessary in case mode == &#39;raman&#39;. Depending on the situation, the allow keys could be &#39;custom_dir&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Gamma_w : dictionary of double matrices</span>
<span class="sd">              transport distribution function in each direction, frequency given by Om_mesh_out and omega</span>
<span class="sd">    omega : list of double</span>
<span class="sd">            omega vector</span>
<span class="sd">    Om_mesh_out : list of double</span>
<span class="sd">                  frequency mesh of the optical conductivity recomputed on the mesh provided by the self energy</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Computing transport distribution...&#39;</span><span class="p">)</span>

    <span class="n">n_inequiv_spin_blocks</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">SO</span>
    <span class="c1"># up and down are equivalent if SP = 0</span>

    <span class="c1"># positive om_mesh</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">Om</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">Om</span> <span class="ow">in</span> <span class="n">Om_mesh</span><span class="p">),</span> <span class="s2">&quot;transport_distribution: Om_mesh should not contain negative values!&quot;</span>
    <span class="c1"># Check if energy_window is sufficiently large and correct</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: energy_window wrong!&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">fermi_dis</span><span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">fermi_dis</span><span class="p">(</span><span class="o">-</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-5</span>
            <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">fermi_dis</span><span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">fermi_dis</span><span class="p">(</span><span class="o">-</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">):</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">####################################################################&quot;</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
            <span class="s2">&quot;transport_distribution: WARNING - energy window might be too narrow!&quot;</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
            <span class="s2">&quot;####################################################################</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># ----------------- calculate A(k,w) -----------------------</span>

    <span class="c1"># Define mesh for Green&#39;s function and in the specified energy window</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">with_Sigma</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">])</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Using omega mesh provided by Sigma!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">energy_window</span><span class="p">:</span>
            <span class="c1"># Find according window in Sigma mesh</span>
            <span class="n">ioffset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">omega</span> <span class="o">&lt;</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">))</span>
            <span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">omega</span> <span class="o">&gt;=</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">omega</span> <span class="o">&lt;=</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">))]</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>

            <span class="c1"># Truncate Sigma to given omega window</span>
            <span class="c1"># In the future there should be an option in gf to manipulate the mesh (e.g. truncate) directly.</span>
            <span class="c1"># For now we stick with this:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">Sigma_save</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">spn</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="n">sum_k</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>
                <span class="k">def</span> <span class="nf">glist</span><span class="p">():</span> <span class="k">return</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">target_shape</span><span class="o">=</span><span class="p">(</span><span class="n">block_dim</span><span class="p">,</span> <span class="n">block_dim</span><span class="p">),</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span>
                    <span class="mi">0</span><span class="p">],</span> <span class="n">omega</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_om</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">block_dim</span> <span class="ow">in</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]]</span>
                <span class="n">sum_k</span><span class="o">.</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span>
                    <span class="n">name_list</span><span class="o">=</span><span class="n">spn</span><span class="p">,</span> <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">(),</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">iL</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                                <span class="n">g</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iL</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">iR</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Sigma_save</span><span class="p">[</span>
                                    <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ioffset</span> <span class="o">+</span> <span class="n">iom</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iL</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">iR</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">n_om</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: Number of omega points (n_om) needed to calculate transport distribution!&quot;</span>
        <span class="k">assert</span> <span class="n">energy_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: Energy window needed to calculate transport distribution!&quot;</span>
        <span class="k">assert</span> <span class="n">broadening</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: Broadening necessary to calculate transport distribution!&quot;</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">MeshReFreq</span><span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                          <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">dir_to_int</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

    <span class="c1"># Define mesh for optic conductivity</span>
    <span class="n">d_omega</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">iOm_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">((</span><span class="n">Om</span> <span class="o">/</span> <span class="n">d_omega</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">Om</span> <span class="ow">in</span> <span class="n">Om_mesh</span><span class="p">])</span>
    <span class="n">temp_Om_mesh</span> <span class="o">=</span> <span class="n">iOm_mesh</span> <span class="o">*</span> <span class="n">d_omega</span>

    <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chemical potential: &quot;</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using n_om = </span><span class="si">%s</span><span class="s2"> points in the energy_window [</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">n_om</span><span class="p">,</span> <span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">omega</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;where the omega vector is:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculation requested for Omega mesh:   &quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Omega mesh automatically repined to:  &quot;</span><span class="p">,</span> <span class="n">temp_Om_mesh</span><span class="p">)</span>

    <span class="n">Gamma_w</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">temp_Om_mesh</span><span class="p">),</span> <span class="n">n_om</span><span class="p">),</span>
                                      <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>

    <span class="c1"># Sum over all k-points</span>
    <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
        <span class="c1"># Calculate G_w  for ik and initialize A_kw</span>
        <span class="n">G_w</span> <span class="o">=</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">)</span>
        <span class="n">A_kw</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">sum_k</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">][</span><span class="n">isp</span><span class="p">],</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">][</span><span class="n">isp</span><span class="p">],</span> <span class="n">n_om</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inequiv_spin_blocks</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inequiv_spin_blocks</span><span class="p">):</span>
            <span class="c1"># copy data from G_w (swapaxes is used to have omega in the 3rd</span>
            <span class="c1"># dimension)</span>
            <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G_w</span><span class="p">[</span><span class="n">sum_k</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="n">sum_k</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span>
                                      <span class="n">isp</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="c1"># calculate A(k,w) for each frequency</span>
            <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">iw</span><span class="p">])))</span>
            <span class="c1"># Akw_write[ik] = A_kw[isp].copy() * sum_k.bz_weights[ik]</span>

            <span class="n">b_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span>
                        <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">b_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span>
                        <span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">A_i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                <span class="n">b_min</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b_max</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">v_i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">b_min</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span>
                        <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b_max</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;optics&#39;</span><span class="p">):</span>
                <span class="c1"># loop over all symmetries</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">rot_symmetries</span><span class="p">:</span>
                    <span class="c1"># get transformed velocity under symmetry R</span>
                    <span class="k">if</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wien2k&#39;</span><span class="p">):</span>
                        <span class="n">vel_R</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">velocities_k</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wannier90&#39;</span><span class="p">):</span>
                        <span class="n">vel_R</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">velocities_k</span><span class="p">[</span><span class="n">ik</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">nu1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">nu2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">vel_R</span><span class="p">[</span><span class="n">nu1</span><span class="p">][</span><span class="n">nu2</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                                <span class="n">R</span><span class="p">,</span> <span class="n">vel_R</span><span class="p">[</span><span class="n">nu1</span><span class="p">][</span><span class="n">nu2</span><span class="p">][:])</span>

                    <span class="c1"># calculate Gamma_w for each direction from the velocities</span>
                    <span class="c1"># vel_R and the spectral function A_kw</span>
                    <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">temp_Om_mesh</span><span class="p">)):</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="n">iOm_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n_om</span> <span class="ow">or</span> <span class="n">omega</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">temp_Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">omega</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp_Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="k">continue</span>

                                <span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_R</span><span class="p">[</span><span class="n">v_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">dir_to_int</span><span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span> <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">A_i</span><span class="p">,</span> <span class="n">A_i</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="n">iOm_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">])]),</span>
                                                                                <span class="n">vel_R</span><span class="p">[</span><span class="n">v_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">dir_to_int</span><span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]),</span> <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">A_i</span><span class="p">,</span> <span class="n">A_i</span><span class="p">,</span> <span class="n">iw</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;raman&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wannier90&#39;</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span><span class="s2">&quot;inverse_mass&quot;</span><span class="p">),</span> <span class="s1">&#39;inverse_mass not available in sum_k. Set calc_inverse_mass=True in w90_params.&#39;</span>
                <span class="k">elif</span> <span class="n">code</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;wien2k&#39;</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;Raman for wien2k not yet implemented&#39;</span>
                <span class="c1"># loop over all symmetries</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">rot_symmetries</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
                        <span class="c1"># calculate the raman vertex for each direction</span>
                        <span class="n">vert</span> <span class="o">=</span> <span class="n">raman_vertex</span><span class="p">(</span><span class="n">sum_k</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">raman_options</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">)):</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="n">iOm_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n_om</span> <span class="ow">or</span> <span class="n">omega</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">omega</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="k">continue</span>
                                
                                <span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vert</span><span class="p">[</span><span class="n">v_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">],</span> <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">A_i</span><span class="p">,</span> <span class="n">A_i</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="n">iOm_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">])]),</span>
                                                                             <span class="n">vert</span><span class="p">[</span><span class="n">v_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">]),</span> <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">A_i</span><span class="p">,</span> <span class="n">A_i</span><span class="p">,</span> <span class="n">iw</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
        <span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">])</span> <span class="o">/</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">cell_vol</span> <span class="o">/</span> <span class="n">sum_k</span><span class="o">.</span><span class="n">n_symmetries</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">temp_Om_mesh</span></div>



<div class="viewcode-block" id="transport_function">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.transport_function.html#triqs_dft_tools.sumk_dft_transport.transport_function">[docs]</a>
<span class="k">def</span> <span class="nf">transport_function</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">hopping</span><span class="p">,</span> <span class="n">velocities</span><span class="p">,</span> <span class="n">energy_window</span><span class="p">,</span> <span class="n">n_om</span><span class="p">,</span> <span class="n">rot_symmetries</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the transport function</span>

<span class="sd">    .. math::</span>
<span class="sd">       \Phi_\alpha\beta(\omega) = \sum_k v_{k,\alpha} v_{k,\beta} \delta(\omega-\varepsilon)</span>

<span class="sd">    in the direction :math:`\alpha\beta`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    beta : double</span>
<span class="sd">        Inverse temperature :math:`\beta`.</span>
<span class="sd">    directions : list of string, optional</span>
<span class="sd">        :math:`\alpha\beta` e.g.: [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;,&#39;xy&#39;,&#39;xz&#39;,&#39;yz&#39;].</span>
<span class="sd">    hopping : double array</span>
<span class="sd">        Hamiltonian in band basis :math:`\epsilon(k)`</span>
<span class="sd">    veolcities : complex array</span>
<span class="sd">        matrix elements derivative of Hamiltonian :math:`\frac{d\epsilon(k)}{dk}`</span>
<span class="sd">    energy_window : list of double</span>
<span class="sd">        Specifies the upper and lower limit of the frequency integration for :math:`\Omega=0.0`. The window is automatically enlarged by the largest :math:`\Omega` value,</span>
<span class="sd">        hence the integration is performed in the interval [energy_window[0]-max(Om_mesh), energy_window[1]+max(Om_mesh)].</span>
<span class="sd">    n_om : integer</span>
<span class="sd">        Number of equidistant frequency points in the interval [energy_window[0]-max(Om_mesh), energy_window[1]+max(Om_mesh)]. This parameters is only used if</span>
<span class="sd">        with_Sigma = False.</span>
<span class="sd">    rot_symmetries :  list of 3 x 3 matrices</span>
<span class="sd">        rotational symmetries to restore the full FBZ</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    transp_func : dictionary of double array</span>
<span class="sd">              transport function in each direction, frequencies given by energy_window</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Computing transport function...&#39;</span><span class="p">)</span>

    <span class="c1"># check that velocities are computed on the FBZ</span>
    <span class="k">assert</span> <span class="n">numpy</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">rot_symmetries</span><span class="p">)[</span>
        <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Using symmetries currently not implemented for transport function.&#39;</span>

    <span class="n">dir_to_int</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

    <span class="n">tol</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">beta</span>
    <span class="n">orb_1</span><span class="p">,</span> <span class="n">orb_2</span> <span class="o">=</span> <span class="n">velocities</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">ws</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_om</span><span class="p">)</span>
    <span class="n">transp_func</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">ws</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ws</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">orb_1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">orb_2</span><span class="p">)]</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">)</span>
        <span class="n">fermi_wg</span> <span class="o">=</span> <span class="n">fermi_dis</span><span class="p">(</span><span class="n">hopping</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">orb_1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">orb_2</span><span class="p">)]</span>
                             <span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">-</span> <span class="n">w</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">fermi_dis</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
            <span class="n">dir_a</span><span class="p">,</span> <span class="n">dir_b</span> <span class="o">=</span> <span class="p">[</span><span class="n">dir_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">direction</span><span class="p">]</span>
            <span class="n">matrix_product</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s1">&#39;kmn, kno -&gt; kmo&#39;</span><span class="p">,</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">dir_a</span><span class="p">],</span> <span class="n">velocities</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">dir_b</span><span class="p">])</span>
            <span class="n">transp_func</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">ct</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">fermi_wg</span> <span class="o">*</span> <span class="n">matrix_product</span><span class="p">[:,</span> <span class="nb">range</span><span class="p">(</span><span class="n">orb_1</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">orb_2</span><span class="p">)][</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">real</span>

    <span class="k">return</span> <span class="n">transp_func</span></div>



<div class="viewcode-block" id="transport_coefficient">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.transport_coefficient.html#triqs_dft_tools.sumk_dft_transport.transport_coefficient">[docs]</a>
<span class="k">def</span> <span class="nf">transport_coefficient</span><span class="p">(</span><span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">,</span> <span class="n">spin_polarization</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the transport coefficient A_n in a given direction for a given :math:`\Omega`. The required members (Gamma_w, directions, Om_mesh) have to be obtained first</span>
<span class="sd">    by calling the function :meth:`transport_distribution &lt;dft.sumk_dft_tools.SumkDFTTools.transport_distribution&gt;`. For n&gt;0 A is set to NaN if :math:`\Omega` is not 0.0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Gamma_w : dictionary of double matrices</span>
<span class="sd">              transport distribution function in each direction, frequency given by Om_mesh_out and omega</span>
<span class="sd">    omega : list of double</span>
<span class="sd">            omega vector</span>
<span class="sd">    Om_mesh : list of double</span>
<span class="sd">              frequency mesh of the optical conductivity recomputed on the mesh provided by the self energy</span>
<span class="sd">    spin_polarization : integer</span>
<span class="sd">                        Boolean-type integer whether system is spin-polarized or not</span>
<span class="sd">    direction : string</span>
<span class="sd">       :math:`\alpha\beta` e.g.: &#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;,&#39;xy&#39;,&#39;xz&#39;,&#39;yz&#39;.</span>
<span class="sd">    iq : integer</span>
<span class="sd">        Index of :math:`\Omega` point in the member Om_mesh.</span>
<span class="sd">    n : integer</span>
<span class="sd">        Number of the desired moment of the transport distribution.</span>
<span class="sd">    beta : double</span>
<span class="sd">        Inverse temperature :math:`\beta`.</span>
<span class="sd">    method : string</span>
<span class="sd">        Integration method: cubic spline and scipy.integrate.quad (&#39;quad&#39;), simpson rule (&#39;simpson&#39;), trapezoidal rule (&#39;trapz&#39;), rectangular integration (otherwise)</span>
<span class="sd">        Note that the sampling points of the the self-energy are used!</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A : double</span>
<span class="sd">        Transport coefficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
    <span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">simpson</span><span class="p">,</span> <span class="n">quad</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># setup the integrand</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">A_int</span> <span class="o">=</span> <span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> \
                <span class="p">(</span><span class="n">fermi_dis</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="n">fermi_dis</span><span class="p">(</span><span class="o">-</span><span class="n">omega</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">omega</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="n">n</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">A_int</span> <span class="o">=</span> <span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">fermi_dis</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">-</span>
                                              <span class="n">fermi_dis</span><span class="p">(</span><span class="n">omega</span> <span class="o">+</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">beta</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span>

        <span class="c1"># w-integration</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quad&#39;</span><span class="p">:</span>
            <span class="c1"># quad on interpolated w-points with cubic spline</span>
            <span class="n">A_int_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="n">A_int</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">A_int_interp</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span>
                     <span class="n">epsabs</span><span class="o">=</span><span class="mf">1.0e-12</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1.0e-12</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;simpson&#39;</span><span class="p">:</span>
            <span class="c1"># simpson rule for w-grid</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">simpson</span><span class="p">(</span><span class="n">A_int</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;trapz&#39;</span><span class="p">:</span>
            <span class="c1"># trapezoidal rule for w-grid</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">A_int</span><span class="p">,</span> <span class="n">omega</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># rectangular integration for w-grid (orignal implementation)</span>
            <span class="n">d_w</span> <span class="o">=</span> <span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">A</span> <span class="o">+=</span> <span class="n">A_int</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_w</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">-</span> <span class="n">spin_polarization</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">A</span></div>



<div class="viewcode-block" id="conductivity_and_seebeck">
<a class="viewcode-back" href="../../_python_api/triqs_dft_tools.sumk_dft_transport.conductivity_and_seebeck.html#triqs_dft_tools.sumk_dft_transport.conductivity_and_seebeck">[docs]</a>
<span class="k">def</span> <span class="nf">conductivity_and_seebeck</span><span class="p">(</span><span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;optics&#39;</span><span class="p">,</span> <span class="n">optic_kappa</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the Seebeck coefficient and the optical conductivity by calling</span>
<span class="sd">    :meth:`transport_coefficient &lt;dft.sumk_dft_tools.SumkDFTTools.transport_coefficient&gt;`.</span>
<span class="sd">    The required members (Gamma_w, directions, Om_mesh) have to be obtained first by calling the function</span>
<span class="sd">    :meth:`transport_distribution &lt;dft.sumk_dft_tools.SumkDFTTools.transport_distribution&gt;`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Gamma_w : dictionary of double matrices</span>
<span class="sd">              transport distribution function in each direction, frequency given by Om_mesh_out and omega</span>
<span class="sd">    omega : list of double</span>
<span class="sd">            omega vector</span>
<span class="sd">    Om_mesh : list of double</span>
<span class="sd">              frequency mesh of the optical conductivity recomputed on the mesh provided by the self energy</span>
<span class="sd">    spin_polarization : integer</span>
<span class="sd">                        Boolean-type integer whether system is spin-polarized or not</span>
<span class="sd">    directions : list of string, optional</span>
<span class="sd">        :math:`\alpha\beta` e.g.: [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;,&#39;xy&#39;,&#39;xz&#39;,&#39;yz&#39;].</span>
<span class="sd">    beta : double</span>
<span class="sd">        Inverse temperature :math:`\beta`.</span>
<span class="sd">    method : string</span>
<span class="sd">        Integration method: cubic spline and scipy.integrate.quad (&#39;quad&#39;), simpson rule (&#39;simpson&#39;), trapezoidal rule (&#39;trapz&#39;), rectangular integration (otherwise)</span>
<span class="sd">        Note that the sampling points of the the self-energy are used!</span>
<span class="sd">    mode : string</span>
<span class="sd">        Choose between optical conductivity/seebeck/Kappa (&#39;optics&#39;) or Raman conductivity (&#39;raman&#39;)</span>
<span class="sd">    optic_kappa : bool</span>
<span class="sd">        If calculates $\kappa(\omega)$ or not. Only if mode is &#39;optics&#39;.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    optic_cond : dictionary of double vectors</span>
<span class="sd">        Optical conductivity in each direction and frequency given by Om_mesh.</span>

<span class="sd">    seebeck : dictionary of double</span>
<span class="sd">        Seebeck coefficient in each direction. If zero is not present in Om_mesh the Seebeck coefficient is set to NaN.</span>

<span class="sd">    kappa : dictionary of double.</span>
<span class="sd">        thermal conductivity in each direction. If zero is not present in Om_mesh the thermal conductivity is set to NaN.</span>
<span class="sd">        If optic_kappa is True, then returns the kappa for all frequencies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Computing optical conductivity and kinetic coefficients...&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

    <span class="n">n_q</span> <span class="o">=</span> <span class="n">Gamma_w</span><span class="p">[</span><span class="n">directions</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># initialization</span>
    <span class="n">A0</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>
    <span class="c1"># The conductivity is proportional to A0, A1 and A2 are only needed for the Seebeck coefficient and thermal conductivity</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;optics&#39;</span><span class="p">):</span>
        <span class="n">A1</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>
        <span class="n">optic_cond</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>
        <span class="n">seebeck</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>
        <span class="n">kappa</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">optic_kappa</span><span class="p">:</span> <span class="n">optic_kappa</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">transport_coefficient</span><span class="p">(</span>
                    <span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">transport_coefficient</span><span class="p">(</span>
                    <span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">transport_coefficient</span><span class="p">(</span>
                    <span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_0 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> a.u.&quot;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_1 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> a.u.&quot;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_2 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> a.u.&quot;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="k">if</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]):</span>
                    <span class="c1"># Seebeck and kappa are overwritten if there is more than one Omega =</span>
                    <span class="c1"># 0 in Om_mesh</span>
                    <span class="n">seebeck</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">/</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="mf">86.17</span>
                    <span class="n">kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">-</span> \
                        <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span><span class="o">*</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span><span class="o">/</span><span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span>
                    <span class="n">kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">293178.0</span>

            <span class="c1"># factor for optical conductivity: hbar * velocity_Hartree_to_SI * volume_Hartree_to_SI * m_to_cm * 10^-4 final unit</span>
            <span class="n">convert_to_SI</span> <span class="o">=</span> <span class="n">cst</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="p">(</span><span class="n">cst</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">cst</span><span class="o">.</span><span class="n">fine_structure</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> \
                <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">cst</span><span class="o">.</span><span class="n">physical_constants</span><span class="p">[</span><span class="s1">&#39;Bohr radius&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">*</span> <span class="mf">1e-6</span>
            <span class="n">optic_cond</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">convert_to_SI</span> <span class="o">*</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">optic_kappa</span><span class="p">:</span> <span class="n">optic_kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">-</span> <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span><span class="o">*</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span><span class="o">/</span><span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">])</span><span class="o">*</span><span class="mf">293178.0</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Conductivity in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">       </span><span class="si">%f</span><span class="s2">  x 10^4 Ohm^-1 cm^-1&quot;</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">optic_cond</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">optic_kappa</span><span class="p">:</span>
                      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;kappa(Omega) in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">       </span><span class="si">%f</span><span class="s2">  W/(m * K)&quot;</span> <span class="o">%</span> 
                            <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">optic_kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">])):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Seebeck in direction      </span><span class="si">%s</span><span class="s2"> for Omega = 0.00      </span><span class="si">%f</span><span class="s2">  x 10^(-6) V/K&quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">seebeck</span><span class="p">[</span><span class="n">direction</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;kappa in direction      </span><span class="si">%s</span><span class="s2"> for Omega = 0.00      </span><span class="si">%f</span><span class="s2">  W/(m * K)&quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">optic_kappa</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">optic_cond</span><span class="p">,</span> <span class="n">seebeck</span><span class="p">,</span> <span class="n">optic_kappa</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">optic_cond</span><span class="p">,</span> <span class="n">seebeck</span><span class="p">,</span> <span class="n">kappa</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;raman&#39;</span><span class="p">):</span>
        <span class="c1"># TODO: express in SI units</span>
        <span class="n">raman_cond</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="n">transport_coefficient</span><span class="p">(</span><span class="n">Gamma_w</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_0 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> atomic units&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
            <span class="n">raman_cond</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> 
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Raman conductivity in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.4f</span><span class="s2">       </span><span class="si">%f</span><span class="s2">  atomic units&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">raman_cond</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">raman_cond</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011-2021.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>