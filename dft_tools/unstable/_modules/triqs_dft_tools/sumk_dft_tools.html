
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>triqs_dft_tools.sumk_dft_tools &#8212; triqs_dft_tools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/triqs.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head><body>
<div class="pageheader">
  <ul>
    
    <li><a href="../../install.html">Install</a></li>
    
    <li><a href="../../documentation.html">Documentation</a></li>
    
    <li><a href="../../tutorials.html">Tutorials</a></li>
    
    <li><a href="../../issues.html">Issues</a></li>
    
    <li><a href="../../about.html">About DFTTools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../../index.html">dft tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://triqs.github.io/triqs">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">triqs_dft_tools.sumk_dft_tools</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for triqs_dft_tools.sumk_dft_tools</h1><div class="highlight"><pre>
<span></span><span class="c1">##########################################################################</span>
<span class="c1">#</span>
<span class="c1"># TRIQS: a Toolbox for Research in Interacting Quantum Systems</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2011 by M. Aichhorn, L. Pourovskii, V. Vildosola</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is free software: you can redistribute it and/or modify it under the</span>
<span class="c1"># terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation, either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="c1"># WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># TRIQS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">##########################################################################</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">from</span> <span class="nn">triqs.gf</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">triqs.utility.mpi</span> <span class="k">as</span> <span class="nn">mpi</span>
<span class="kn">from</span> <span class="nn">.symmetry</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">.sumk_dft</span> <span class="k">import</span> <span class="n">SumkDFT</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="o">*</span>

<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">numpy</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">):</span>
    <span class="c1"># polyfill full for older numpy:</span>
    <span class="n">numpy</span><span class="o">.</span><span class="n">full</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">f</span>

<div class="viewcode-block" id="SumkDFTTools"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools">[docs]</a><span class="k">class</span> <span class="nc">SumkDFTTools</span><span class="p">(</span><span class="n">SumkDFT</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extends the SumkDFT class with some tools for analysing the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SumkDFTTools.__init__"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf_file</span><span class="p">,</span> <span class="n">h_field</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">use_dft_blocks</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dft_data</span><span class="o">=</span><span class="s1">&#39;dft_input&#39;</span><span class="p">,</span> <span class="n">symmcorr_data</span><span class="o">=</span><span class="s1">&#39;dft_symmcorr_input&#39;</span><span class="p">,</span>
                 <span class="n">parproj_data</span><span class="o">=</span><span class="s1">&#39;dft_parproj_input&#39;</span><span class="p">,</span> <span class="n">symmpar_data</span><span class="o">=</span><span class="s1">&#39;dft_symmpar_input&#39;</span><span class="p">,</span> <span class="n">bands_data</span><span class="o">=</span><span class="s1">&#39;dft_bands_input&#39;</span><span class="p">,</span>
                 <span class="n">transp_data</span><span class="o">=</span><span class="s1">&#39;dft_transp_input&#39;</span><span class="p">,</span> <span class="n">misc_data</span><span class="o">=</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialisation of the class. Parameters are exactly as for SumKDFT.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">SumkDFT</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf_file</span><span class="o">=</span><span class="n">hdf_file</span><span class="p">,</span> <span class="n">h_field</span><span class="o">=</span><span class="n">h_field</span><span class="p">,</span> <span class="n">use_dft_blocks</span><span class="o">=</span><span class="n">use_dft_blocks</span><span class="p">,</span>
                         <span class="n">dft_data</span><span class="o">=</span><span class="n">dft_data</span><span class="p">,</span> <span class="n">symmcorr_data</span><span class="o">=</span><span class="n">symmcorr_data</span><span class="p">,</span> <span class="n">parproj_data</span><span class="o">=</span><span class="n">parproj_data</span><span class="p">,</span>
                         <span class="n">symmpar_data</span><span class="o">=</span><span class="n">symmpar_data</span><span class="p">,</span> <span class="n">bands_data</span><span class="o">=</span><span class="n">bands_data</span><span class="p">,</span> <span class="n">transp_data</span><span class="o">=</span><span class="n">transp_data</span><span class="p">,</span>
                         <span class="n">misc_data</span><span class="o">=</span><span class="n">misc_data</span><span class="p">)</span></div>

    <span class="c1"># Uses .data of only GfReFreq objects.</span>
<div class="viewcode-block" id="SumkDFTTools.dos_wannier_basis"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.dos_wannier_basis">[docs]</a>    <span class="k">def</span> <span class="nf">dos_wannier_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the density of states in the basis of the Wannier functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">                     Lorentzian broadening of the spectra. If not given, standard value of lattice_gf is used.</span>
<span class="sd">        mesh : real frequency MeshType, optional</span>
<span class="sd">               Omega mesh for the real-frequency Green&#39;s function. Given as parameter to lattice_gf.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True, the self energy is used for the calculation. If false, the DOS is calculated without self energy.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True the double counting correction is used.</span>
<span class="sd">        save_to_file : boolean, optional</span>
<span class="sd">                       If True, text files with the calculated data will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DOS : Dict of numpy arrays</span>
<span class="sd">              Contains the full density of states.</span>
<span class="sd">        DOSproj :  Dict of numpy arrays</span>
<span class="sd">                   DOS projected to atoms.</span>
<span class="sd">        DOSproj_orb : Dict of numpy arrays</span>
<span class="sd">                      DOS projected to atoms and resolved into orbital contributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">with_Sigma</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lattice_gf: Give the mesh=(om_min,om_max,n_points) for the lattice GfReFreq.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
            <span class="n">om_min</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">om_max</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>

        <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>
            <span class="n">glist</span> <span class="o">=</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">),</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_om</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]]</span>
            <span class="n">G_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_list</span><span class="o">=</span><span class="n">spn</span><span class="p">,</span> <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">,</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="n">DOS</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]}</span>
        <span class="n">DOSproj</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="n">DOSproj_orb</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="n">DOSproj</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="n">G_latt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>
            <span class="n">G_latt_w</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

            <span class="c1"># Non-projected DOS</span>
            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                    <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> \
                        <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># Projected DOS:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt_w</span><span class="p">[</span>
                                                <span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>  <span class="c1"># downfolding G</span>
                <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>

        <span class="c1"># Collect data from mpi:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">DOS</span><span class="p">:</span>
            <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Symmetrize and rotate to local coord. system if needed:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">G_loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                        <span class="n">icrsh</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toLocal&#39;</span><span class="p">)</span>

        <span class="c1"># G_loc can now also be used to look at orbitally-resolved quantities</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]:</span>  <span class="c1"># loop over spins</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">DOSproj</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span>
                                                        <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">bname</span><span class="p">][</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">gf</span><span class="o">-</span><span class="n">gf</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,:]</span>

        <span class="c1"># Write to files</span>
        <span class="k">if</span> <span class="n">save_to_file</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_wann_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOS</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c1"># Partial</span>
                <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_wann_</span><span class="si">%s</span><span class="s1">_proj</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">ish</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOSproj</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                    <span class="c1"># Orbitally-resolved</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]):</span>
                            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_wann_&#39;</span> <span class="o">+</span> <span class="n">sp</span> <span class="o">+</span> <span class="s1">&#39;_proj&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ish</span><span class="p">)</span> <span class="o">+</span>
                                     <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">DOSproj</span><span class="p">,</span> <span class="n">DOSproj_orb</span></div>


<div class="viewcode-block" id="SumkDFTTools.dos_wannier_basis_all"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.dos_wannier_basis_all">[docs]</a>    <span class="k">def</span> <span class="nf">dos_wannier_basis_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the density of states in the basis of the Wannier functions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">                     Lorentzian broadening of the spectra. If not given, standard value of lattice_gf is used.</span>
<span class="sd">        mesh : real frequency MeshType, optional</span>
<span class="sd">               Omega mesh for the real-frequency Green&#39;s function. Given as parameter to lattice_gf.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True, the self energy is used for the calculation. If false, the DOS is calculated without self energy.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True the double counting correction is used.</span>
<span class="sd">        save_to_file : boolean, optional</span>
<span class="sd">                       If True, text files with the calculated data will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DOS : Dict of numpy arrays</span>
<span class="sd">              Contains the full density of states.</span>
<span class="sd">        DOSproj :  Dict of numpy arrays</span>
<span class="sd">                   DOS projected to atoms.</span>
<span class="sd">        DOSproj_orb : Dict of numpy arrays</span>
<span class="sd">                      DOS projected to atoms and resolved into orbital contributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">with_Sigma</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lattice_gf: Give the mesh=(om_min,om_max,n_points) for the lattice GfReFreq.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
            <span class="n">om_min</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">om_max</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>

        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">gf_struct_parproj</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">])))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
        <span class="n">n_local_orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_csc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">gf_struct_parproj_all</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_local_orbs</span><span class="p">)))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]]</span>

        <span class="n">glist_all</span> <span class="o">=</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">),</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_om</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct_parproj_all</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">G_loc_all</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_list</span><span class="o">=</span><span class="n">spn</span><span class="p">,</span> <span class="n">block_list</span><span class="o">=</span><span class="n">glist_all</span><span class="p">,</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">DOS</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]}</span>
        <span class="n">DOSproj</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">DOSproj_orb</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">n_local_orbs</span>
            <span class="n">DOSproj</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="n">G_latt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>
            <span class="n">G_latt_w</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

            <span class="c1"># Non-projected DOS</span>
            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                    <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> \
                        <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># Projected DOS:</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                <span class="n">G_loc_all</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">G_loc_all</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;csc&#39;</span><span class="p">)</span>
        <span class="c1"># Collect data from mpi:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">DOS</span><span class="p">:</span>
            <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">G_loc_all</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">G_loc_all</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Symmetrize and rotate to local coord. system if needed:</span>
        <span class="c1">#if self.symm_op != 0:</span>
        <span class="c1">#    G_loc_all = self.symmcorr.symmetrize(G_loc_all)</span>

        <span class="c1"># G_loc can now also be used to look at orbitally-resolved quantities</span>
        <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc_all</span><span class="p">:</span>  <span class="c1"># loop over spins</span>
            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="n">DOSproj</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
            <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">bname</span><span class="p">][:,:,:]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">gf</span><span class="o">-</span><span class="n">gf</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,:]</span>
        <span class="c1"># Write to files</span>
        <span class="k">if</span> <span class="n">save_to_file</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_wann_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOS</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c1"># Partial</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_wann_all_</span><span class="si">%s</span><span class="s1">_proj.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOSproj</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c1"># Orbitally-resolved</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_local_orbs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n_local_orbs</span><span class="p">):</span>
                        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_wann_all&#39;</span> <span class="o">+</span> <span class="n">sp</span> <span class="o">+</span> <span class="s1">&#39;_proj_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">DOSproj</span><span class="p">,</span> <span class="n">DOSproj_orb</span></div>

    <span class="c1"># Uses .data of only GfReFreq objects.</span>
<div class="viewcode-block" id="SumkDFTTools.dos_parproj_basis"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.dos_parproj_basis">[docs]</a>    <span class="k">def</span> <span class="nf">dos_parproj_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the orbitally-resolved DOS.</span>
<span class="sd">        Different to dos_Wannier_basis is that here we calculate projections also to non-Wannier projectors, in the</span>
<span class="sd">        flavour of Wien2k QTL calculatuions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">                     Lorentzian broadening of the spectra. If not given, standard value of lattice_gf is used.</span>
<span class="sd">        mesh : real frequency MeshType, optional</span>
<span class="sd">               Omega mesh for the real-frequency Green&#39;s function. Given as parameter to lattice_gf.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True, the self energy is used for the calculation. If false, the DOS is calculated without self energy.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True the double counting correction is used.</span>
<span class="sd">        save_to_file : boolean, optional</span>
<span class="sd">                       If True, text files with the calculated data will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DOS : Dict of numpy arrays</span>
<span class="sd">              Contains the full density of states.</span>
<span class="sd">        DOSproj :  Dict of numpy arrays</span>
<span class="sd">                   DOS projected to atoms.</span>
<span class="sd">        DOSproj_orb : Dict of numpy arrays</span>
<span class="sd">                      DOS projected to atoms and resolved into orbital contributions.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;n_parproj&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_mat_all&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;rot_mat_all&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_mat_all_time_inv&#39;</span><span class="p">]</span>
        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parproj_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_read</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmpar</span> <span class="o">=</span> <span class="n">Symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="n">subgroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symmpar_data</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">with_Sigma</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lattice_gf: Give the mesh=(om_min,om_max,n_points) for the lattice GfReFreq.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
            <span class="n">om_min</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">om_max</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>

        <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">gf_struct_parproj</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">])))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="n">glist</span> <span class="o">=</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">),</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_om</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct_parproj</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
            <span class="n">G_loc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_list</span><span class="o">=</span><span class="n">spn</span><span class="p">,</span> <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">,</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="n">DOS</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]}</span>
        <span class="n">DOSproj</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
        <span class="n">DOSproj_orb</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="n">DOSproj</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">n_om</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="n">G_latt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>
            <span class="n">G_latt_w</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

            <span class="c1"># Non-projected DOS</span>
            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                    <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> \
                        <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>

            <span class="c1"># Projected DOS:</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_parproj</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt_w</span><span class="p">[</span>
                                                    <span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="n">ir</span><span class="p">)</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>

        <span class="c1"># Collect data from mpi:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">DOS</span><span class="p">:</span>
            <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Symmetrize and rotate to local coord. system if needed:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmpar</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">G_loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                        <span class="n">ish</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toLocal&#39;</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

        <span class="c1"># G_loc can now also be used to look at orbitally-resolved quantities</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">DOSproj</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span>
                                                        <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
                <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">bname</span><span class="p">][</span>
                    <span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="p">(</span><span class="n">gf</span><span class="o">-</span><span class="n">gf</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="p">[:,:,:]</span>

        <span class="c1"># Write to files</span>
        <span class="k">if</span> <span class="n">save_to_file</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_parproj_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOS</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c1"># Partial</span>
                <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_parproj_</span><span class="si">%s</span><span class="s1">_proj</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">ish</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOSproj</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                    <span class="c1"># Orbitally-resolved</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]):</span>
                            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DOS_parproj_&#39;</span> <span class="o">+</span> <span class="n">sp</span> <span class="o">+</span> <span class="s1">&#39;_proj&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ish</span><span class="p">)</span> <span class="o">+</span>
                                     <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">DOSproj_orb</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">DOSproj</span><span class="p">,</span> <span class="n">DOSproj_orb</span></div>

    <span class="c1"># Elk total and partial dos calculations</span>
    <span class="c1"># Uses .data of only GfReFreq objects.</span>
<div class="viewcode-block" id="SumkDFTTools.elk_dos"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.elk_dos">[docs]</a>    <span class="k">def</span> <span class="nf">elk_dos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">pdos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">nk</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This calculates the total DOS and the partial DOS (orbital-DOS) from the band characters calculated in Elk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">                     Lorentzian broadening of the spectra. If not given, standard value of lattice_gf is used.</span>
<span class="sd">        mesh : real frequency MeshType, optional</span>
<span class="sd">               Omega mesh for the real-frequency Green&#39;s function. Given as parameter to lattice_gf.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True, the self energy is used for the calculation. If false, the DOS is calculated without self energy.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True the double counting correction is used.</span>
<span class="sd">        save_to_file : boolean, optional</span>
<span class="sd">                       If True, text files with the calculated data will be created.</span>
<span class="sd">        pdos : allows the partial density of states to be calculated</span>
<span class="sd">        nk : diagonal of the occupation function (from the Matsubara Green&#39;s function)</span>
<span class="sd">             in the band basis (has form nk[spn][n_k][n_orbital])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DOS : Dict of numpy arrays</span>
<span class="sd">              Contains the full density of states.</span>
<span class="sd">        pDOS :  Dict of numpy arrays</span>
<span class="sd">                partial (orbital resolved) DOS for each atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pdos</span><span class="p">):</span>
          <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;maxlm&#39;</span><span class="p">,</span> <span class="s1">&#39;bc&#39;</span><span class="p">]</span>
          <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bc_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_read</span>
          <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;n_atoms&#39;</span><span class="p">]</span>
          <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
          <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_read</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">with_Sigma</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;lattice_gf: Give the mesh=(om_min,om_max,n_points) for the lattice GfReFreq.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
            <span class="n">om_min</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">om_max</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>

        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>

        <span class="n">DOS</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
               <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]}</span>
        <span class="c1">#set up temporary arrays for pdos calculations</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pdos</span><span class="p">):</span>
          <span class="n">pDOS</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">maxlm</span><span class="p">,</span><span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]}</span>
          <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">pDOS</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="n">G_latt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>
            <span class="n">G_latt_w</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
            <span class="k">if</span><span class="p">(</span><span class="n">nk</span><span class="o">!=</span><span class="kc">None</span><span class="p">):</span>
              <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                  <span class="n">numpy</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">G_latt_w</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">nk</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][:]</span><span class="o">*</span><span class="n">G_latt_w</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">diagonal</span><span class="p">())</span>

            <span class="c1"># Non-projected DOS</span>
            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                    <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iom</span><span class="p">]</span> <span class="o">-=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> \
                        <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>


            <span class="c1"># Partial DOS</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pdos</span><span class="p">):</span>
              <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                  <span class="n">isp</span><span class="o">=</span><span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span>
                  <span class="n">nst</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="n">isp</span><span class="p">]</span>
                  <span class="n">tmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">nst</span><span class="p">])</span>
                  <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                      <span class="c1">#get diagonal spectral function</span>
                      <span class="n">tmp</span><span class="p">[:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
                      <span class="c1">#calculate the pDOS of all atoms</span>
                      <span class="k">for</span> <span class="n">iatom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                        <span class="n">bcar</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bc</span><span class="p">[:,</span><span class="n">isp</span><span class="p">,</span><span class="n">iatom</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="n">nst</span><span class="p">,</span><span class="n">ik</span><span class="p">]</span>
                        <span class="n">pDOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iatom</span><span class="p">,:,</span><span class="n">iom</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">bcar</span><span class="p">,</span><span class="n">tmp</span><span class="p">)</span>
                  <span class="k">del</span> <span class="n">tmp</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="c1"># Collect data from mpi:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">DOS</span><span class="p">:</span>
            <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">DOS</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pdos</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">pDOS</span><span class="p">:</span>
              <span class="k">for</span> <span class="n">iatom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                 <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxlm</span><span class="p">):</span>
                   <span class="n">pDOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iatom</span><span class="p">,</span><span class="n">lm</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                      <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">pDOS</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">iatom</span><span class="p">,</span><span class="n">lm</span><span class="p">,:],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>


        <span class="c1"># Write to files</span>
        <span class="k">if</span> <span class="n">save_to_file</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;TDOS_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">DOS</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iom</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="c1"># Partial</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pdos</span><span class="p">):</span>
                  <span class="k">for</span> <span class="n">iatom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_atoms</span><span class="p">):</span>
                      <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;pDOS_</span><span class="si">%s</span><span class="s1">_atom_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">iatom</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">lm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxlm</span><span class="p">):</span>
                          <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                                  <span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">pDOS</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">iatom</span><span class="p">,</span><span class="n">lm</span><span class="p">,</span><span class="n">iom</span><span class="p">]))</span>
                          <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                      <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">pDOS</span></div>

    <span class="c1"># vector manipulation used in Elk for symmetry operations - This is already in elktools, this should</span>
    <span class="c1"># put somewhere for general use by the converter and this script.</span>
    <span class="k">def</span> <span class="nf">v3frac</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">eps</span><span class="p">):</span>
       <span class="c1">#This finds the fractional part of 3-vector v components. This uses the</span>
       <span class="c1">#same method as in Elk (version 6.2.8) r3fac subroutine.</span>
       <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
       <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
       <span class="k">if</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
       <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
       <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
       <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
       <span class="k">if</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
       <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
       <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
       <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
       <span class="k">if</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
       <span class="k">if</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">):</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
       <span class="k">return</span> <span class="n">v</span>

    <span class="c1">#  Calculate the spectral function at an energy contour omega - i.e. Fermi surface plots</span>
    <span class="c1"># Uses .data of only GfReFreq objects.</span>
<div class="viewcode-block" id="SumkDFTTools.fs_plot"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.fs_plot">[docs]</a>    <span class="k">def</span> <span class="nf">fs_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">FS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">orthvec</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the correlated spectral function at specific frequencies. The default output is the</span>
<span class="sd">        correlated spectral function at zero frequency - this relates the the Fermi surface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">                     Lorentzian broadening of the spectra. If not given, standard value of lattice_gf is used.</span>
<span class="sd">        mesh : real frequency MeshType, optional</span>
<span class="sd">               Omega mesh for the real-frequency Green&#39;s function. Given as parameter to lattice_gf.</span>
<span class="sd">        plane : boolean, optional</span>
<span class="sd">                True assumes that the k-mesh of eigenvalues calculated was a plane.</span>
<span class="sd">        sym: boolean, optional</span>
<span class="sd">             Uses the symmetry operations to fold out the correlated spectral function in the BZ</span>
<span class="sd">        FS: boolean</span>
<span class="sd">            Flag for calculating the spectral function at the Fermi level (omega-&gt;0)</span>
<span class="sd">        orthvec: double (3) element numpy array, optional</span>
<span class="sd">                 This is used to determine the vectors used in the plane calculations after folding out the IBZ.</span>
<span class="sd">                 This needs to correspond to the same orthonormal LATTICE inputs vectors used in the DFT code</span>
<span class="sd">                 which generated the plane of energy eigenvalues.</span>
<span class="sd">                 The default is orthvec=[0,0,1].</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True, the self energy is used for the calculation. If false, the DOS is calculated without self energy.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True the double counting correction is used.</span>
<span class="sd">        save_to_file : boolean, optional</span>
<span class="sd">                       If True, text files with the calculated data will be created.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nk : int</span>
<span class="sd">             The number of k-points in the plane.</span>
<span class="sd">        vkc : Dict of numpy arrays [shape - (nk, 3)]</span>
<span class="sd">              Contains the cartesian vectors which the spectral function has been evaluated on.</span>
<span class="sd">        Akw : Dict of numpy arrays [shape - (spn)(self.n_k, n_om)]</span>
<span class="sd">              Correlated spectral function - the data as it is written to the files.</span>
<span class="sd">        iknr : int array</span>
<span class="sd">               An array of k-point indices which mape the Akw over the unfolded BZ.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#default vector tolerance used in Elk. This should not be alter.</span>
        <span class="n">epslat</span><span class="o">=</span><span class="mf">1E-6</span>
        <span class="c1">#read in the energy contour energies and projectors</span>
        <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;n_k&#39;</span><span class="p">,</span><span class="s1">&#39;bmat&#39;</span><span class="p">,</span><span class="s1">&#39;symlat&#39;</span><span class="p">,</span><span class="s1">&#39;n_symm&#39;</span><span class="p">,</span><span class="s1">&#39;vkl&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;n_orbitals&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_mat&#39;</span><span class="p">,</span> <span class="s1">&#39;hopping&#39;</span><span class="p">]</span>
        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
          <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fs_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
          <span class="k">return</span> <span class="n">value_read</span>

        <span class="k">if</span> <span class="n">with_Sigma</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
            <span class="c1">#for Fermi Surface calculations</span>
            <span class="k">if</span> <span class="n">FS</span><span class="p">:</span>
              <span class="n">jw</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">))</span> <span class="k">if</span> <span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span>
              <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">jw</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Sigma_imp_w mesh does not include zero frequency value&#39;</span><span class="p">)</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Using the next absolute lowest frequency value.&#39;</span><span class="p">)</span>
                <span class="n">abs_om_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">om_mesh</span><span class="p">]</span>
                <span class="n">jw</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">abs_om_mesh</span><span class="p">))</span> <span class="k">if</span> <span class="n">abs_om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">abs_om_mesh</span><span class="p">[:])]</span>
              <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="n">jw</span><span class="p">)</span>
            <span class="c1">#for many energy contour calculations</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="k">if</span> <span class="n">mesh</span><span class="p">:</span>
                <span class="n">om_mn</span><span class="o">=</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">om_mx</span><span class="o">=</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">jw</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">))</span> <span class="k">if</span><span class="p">((</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">om_mx</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">om_mn</span><span class="p">))]</span>
            <span class="n">om_min</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">om_max</span> <span class="o">=</span> <span class="n">om_mesh</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">broadening</span><span class="o">=</span><span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1">#default is to set &quot;mesh&quot; to be just for the Fermi surface - omega=0.0</span>
            <span class="n">om_min</span> <span class="o">=</span> <span class="mf">0.000</span>
            <span class="n">om_max</span> <span class="o">=</span> <span class="mf">0.001</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
               <span class="n">broadening</span><span class="o">=</span><span class="mf">0.01</span>
            <span class="n">FS</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">jw</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">))</span> <span class="k">if</span><span class="p">((</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">om_max</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">om_min</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
        <span class="c1">#a range of frequencies can be used if desired</span>
            <span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span> <span class="o">=</span> <span class="n">mesh</span>
            <span class="n">om_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">om_min</span><span class="p">,</span> <span class="n">om_max</span><span class="p">,</span> <span class="n">n_om</span><span class="p">)</span>
            <span class="n">FS</span><span class="o">=</span><span class="kc">False</span>
            <span class="n">jw</span><span class="o">=</span><span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">))</span> <span class="k">if</span><span class="p">((</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">om_max</span><span class="p">)</span><span class="ow">and</span><span class="p">(</span><span class="n">om_mesh</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">om_min</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>

        <span class="c1">#orthogonal vector used for plane calculations</span>
        <span class="k">if</span> <span class="n">orthvec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="c1">#set to [0,0,1] by default</span>
          <span class="n">orthvec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
          <span class="n">orthvec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">orthvec</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
          <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;The input numpy orthvec is not the required size of 3!&quot;</span>

        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>

        <span class="n">Akw</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">,</span> <span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>

        <span class="c1">#Cartesian lattice coordinates array</span>
        <span class="n">vkc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="c1">#calculate the catesian coordinates of IBZ</span>
            <span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">vkl</span><span class="p">[</span><span class="n">ik</span><span class="p">,:])</span>

            <span class="n">G_latt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
              <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                <span class="n">Akw</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]</span> <span class="o">+=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,:,:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Collect data from mpi:</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
          <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1">#fold out the IBZ k-points using the lattice vectors and symmetries</span>
        <span class="c1">#reducible number of k-points (which will alter after out folding)</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_k</span>
        <span class="n">iknr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
          <span class="n">vkltmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vkl</span>
          <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
          <span class="n">v_orth</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
          <span class="k">for</span> <span class="n">isym</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_symm</span><span class="p">):</span>
            <span class="c1">#calculate the orthonormal vector after symmetry operation. This is used to</span>
            <span class="c1">#check if the orthonormal vector after the symmetry operation is parallel</span>
            <span class="c1">#or anit-parallel to the original vector.</span>
            <span class="k">if</span> <span class="n">plane</span><span class="p">:</span>
              <span class="n">vo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symlat</span><span class="p">[</span><span class="n">isym</span><span class="p">][:,:],</span><span class="n">orthvec</span><span class="p">[:]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
              <span class="c1">#check if the vectors are parallel or anti-parallel respectively</span>
              <span class="n">t1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">vo</span><span class="p">,</span> <span class="n">orthvec</span><span class="p">)</span>
              <span class="k">if</span><span class="p">(</span><span class="ow">not</span> <span class="n">t1</span><span class="p">):</span>
                <span class="c1">#exit this symmetry operation</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
              <span class="c1">#find point in BZ by symmetry operation</span>
              <span class="n">v</span><span class="p">[:]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symlat</span><span class="p">[</span><span class="n">isym</span><span class="p">][:,:],</span><span class="bp">self</span><span class="o">.</span><span class="n">vkl</span><span class="p">[</span><span class="n">ik</span><span class="p">,:])</span>
              <span class="c1">#shift back in to range [0,1) - Elk specific</span>
              <span class="n">v</span><span class="p">[:]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">v3frac</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">epslat</span><span class="p">)</span>
              <span class="c1">#add vector to list if not present and add the equivalent Akw value</span>
                <span class="c1">#convert to cartesian</span>
              <span class="n">v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bmat</span><span class="p">,</span><span class="n">v</span><span class="p">[:])</span>
                <span class="c1">#alter temporary arrays</span>
              <span class="n">nk</span> <span class="o">+=</span> <span class="mi">1</span>
              <span class="n">vkc</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">vkc</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
              <span class="n">iknr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iknr</span><span class="p">,</span><span class="n">ik</span><span class="p">)</span>
              <span class="n">vkltmp</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">vkltmp</span><span class="p">,</span><span class="n">v</span><span class="p">))</span>
          <span class="c1">#remove duplicates</span>
          <span class="p">[</span><span class="n">vkc</span><span class="p">,</span><span class="n">ind</span><span class="p">]</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vkc</span><span class="p">,</span><span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">iknr</span><span class="o">=</span><span class="n">iknr</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
          <span class="n">nk</span><span class="o">=</span><span class="n">vkc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="c1">#sort the indices for output in decending order</span>
          <span class="n">iksrt</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(([</span><span class="n">vkc</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">vkc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)]))</span>
          <span class="c1">#rearrange the vkc and iknr arrays</span>
          <span class="n">vkc</span><span class="o">=</span><span class="n">vkc</span><span class="p">[</span><span class="n">iksrt</span><span class="p">]</span>
          <span class="n">iknr</span><span class="o">=</span><span class="n">iknr</span><span class="p">[</span><span class="n">iksrt</span><span class="p">]</span>

        <span class="c1"># Write to files</span>
        <span class="k">if</span> <span class="n">save_to_file</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
          <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">FS</span><span class="p">:</span>
            <span class="c1">#Output default FS spectral function</span>
              <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;Akw_FS_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="n">sp</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                <span class="n">jk</span><span class="o">=</span><span class="n">iknr</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">Akw</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">jk</span><span class="p">,</span> <span class="n">jw</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
              <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
            <span class="c1">#Output spectral function from multiple frequencies</span>
              <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="n">jw</span><span class="p">:</span>
                <span class="c1">#output the energy contours in multiple files with mesh index.</span>
                <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;Akw_</span><span class="si">%s</span><span class="s1">_omega_</span><span class="si">%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">iom</span><span class="p">),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
                  <span class="n">jk</span><span class="o">=</span><span class="n">iknr</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
                  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="s2">    </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">vkc</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">om_mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">Akw</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">jk</span><span class="p">,</span> <span class="n">iom</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">nk</span><span class="p">,</span> <span class="n">vkc</span><span class="p">,</span> <span class="n">Akw</span><span class="p">,</span> <span class="n">iknr</span></div>



    <span class="c1"># Uses .data of only GfReFreq objects.</span>
<div class="viewcode-block" id="SumkDFTTools.spaghettis"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.spaghettis">[docs]</a>    <span class="k">def</span> <span class="nf">spaghettis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_shift</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">plot_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ishell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_to_file</span><span class="o">=</span><span class="s1">&#39;Akw_&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the correlated band structure using a real-frequency self energy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">                     Lorentzian broadening of the spectra. If not given, standard value of lattice_gf is used.</span>
<span class="sd">        plot_shift : double, optional</span>
<span class="sd">                     Offset for each A(k,w) for stacked plotting of spectra.</span>
<span class="sd">        plot_range : list of double, optional</span>
<span class="sd">                     Sets the energy window for plotting to (plot_range[0],plot_range[1]). If not provided, the energy mesh of the self energy is used.</span>
<span class="sd">        ishell : integer, optional</span>
<span class="sd">                 Contains the index of the shell on which the spectral function is projected. If ishell=None, the total spectrum without projection is calculated.</span>
<span class="sd">        save_to_file : string, optional</span>
<span class="sd">                       Filename where the spectra are stored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Akw : Dict of numpy arrays</span>
<span class="sd">              Data as it is also written to the files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp_w&quot;</span><span class="p">),</span> <span class="s2">&quot;spaghettis: Set Sigma_imp_w first.&quot;</span>
        <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;n_k&#39;</span><span class="p">,</span> <span class="s1">&#39;n_orbitals&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_mat&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;hopping&#39;</span><span class="p">,</span> <span class="s1">&#39;n_parproj&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_mat_all&#39;</span><span class="p">]</span>
        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bands_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_read</span>
        <span class="k">if</span> <span class="n">ishell</span><span class="p">:</span>
            <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;rot_mat_all&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_mat_all_time_inv&#39;</span><span class="p">]</span>
            <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
                <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parproj_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">value_read</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">]</span>
        <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">om_minplot</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.001</span>
            <span class="n">om_maxplot</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">[</span><span class="n">n_om</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">om_minplot</span> <span class="o">=</span> <span class="n">plot_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">om_maxplot</span> <span class="o">=</span> <span class="n">plot_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ishell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Akw</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">,</span> <span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Akw</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ishell</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">,</span> <span class="n">n_om</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ishell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gf_struct_parproj</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ishell</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">])))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                                                  <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct_parproj</span><span class="p">],</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">G_loc</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="n">G_latt_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ishell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Non-projected A(k,w)</span>
                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">om_minplot</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">om_maxplot</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_w</span><span class="p">:</span>
                            <span class="n">Akw</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]</span> <span class="o">+=</span> <span class="n">gf</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="p">:,</span>
                                                           <span class="p">:]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                        <span class="c1"># shift Akw for plotting stacked k-resolved eps(k)</span>
                        <span class="c1"># curves</span>
                        <span class="n">Akw</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ik</span> <span class="o">*</span> <span class="n">plot_shift</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># ishell not None</span>
                <span class="c1"># Projected A(k,w):</span>
                <span class="n">G_loc</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">G_loc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_parproj</span><span class="p">[</span><span class="n">ishell</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">ishell</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt_w</span><span class="p">[</span>
                                                    <span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="n">ir</span><span class="p">)</span>
                    <span class="n">G_loc</span> <span class="o">+=</span> <span class="n">tmp</span>

                <span class="c1"># Rotate to local frame</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">:</span>
                        <span class="n">G_loc</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                            <span class="n">ishell</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toLocal&#39;</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">om_minplot</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">om_maxplot</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ishell</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                                <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ish</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span>
                                    <span class="n">iom</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">/</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Collect data from mpi</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
            <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">save_to_file</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">ishell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>  <span class="c1"># loop over GF blocs:</span>
                    <span class="c1"># Open file for storage:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_to_file</span> <span class="o">+</span> <span class="n">sp</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">om_minplot</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">om_maxplot</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">plot_shift</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
                                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">      </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]))</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">     </span><span class="si">%s</span><span class="s1">      </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]))</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># ishell is not None</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ishell</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]):</span>
                        <span class="c1"># Open file for storage:</span>
                        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">save_to_file</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ishell</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span>
                                 <span class="n">sp</span> <span class="o">+</span> <span class="s1">&#39;_proj&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ish</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">om_minplot</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">om_maxplot</span><span class="p">):</span>
                                    <span class="k">if</span> <span class="n">plot_shift</span> <span class="o">&gt;</span> <span class="mf">0.0001</span><span class="p">:</span>
                                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">      </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                            <span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ish</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]))</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">     </span><span class="si">%s</span><span class="s1">      </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                            <span class="n">ik</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="n">iom</span><span class="p">],</span> <span class="n">Akw</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ish</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">iom</span><span class="p">]))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Akw</span></div>

<div class="viewcode-block" id="SumkDFTTools.partial_charges"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.partial_charges">[docs]</a>    <span class="k">def</span> <span class="nf">partial_charges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the orbitally-resolved density matrix for all the orbitals considered in the input, consistent with</span>
<span class="sd">        the definition of Wien2k. Hence, (possibly non-orthonormal) projectors have to be provided in the partial projectors subgroup of</span>
<span class="sd">        the hdf5 archive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True, the self energy is used for the calculation. If false, partial charges are calculated without self-energy correction.</span>
<span class="sd">        beta : double, optional</span>
<span class="sd">               In case the self-energy correction is not used, the inverse temperature where the calculation should be done has to be given here.</span>
<span class="sd">        mu : double, optional</span>
<span class="sd">             Chemical potential, overrides the one stored in the hdf5 archive.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True the double counting correction is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens_mat : list of numpy array</span>
<span class="sd">                   A list of density matrices projected to all shells provided in the input.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;dens_mat_below&#39;</span><span class="p">,</span> <span class="s1">&#39;n_parproj&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;proj_mat_all&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_mat_all&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_mat_all_time_inv&#39;</span><span class="p">]</span>
        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parproj_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">value_read</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">value_read</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmpar</span> <span class="o">=</span> <span class="n">Symmetry</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="n">subgroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symmpar_data</span><span class="p">)</span>

        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="c1"># Density matrix in the window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dens_mat_window</span> <span class="o">=</span> <span class="p">[[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
                                <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spn</span><span class="p">))]</span>
        <span class="c1"># Set up G_loc</span>
        <span class="n">gf_struct_parproj</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">])))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                                                   <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct_parproj</span><span class="p">[</span><span class="n">ish</span><span class="p">]],</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">))</span>
                                                   <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct_parproj</span><span class="p">[</span><span class="n">ish</span><span class="p">]],</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="n">G_latt_iw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;iw&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">)</span>
            <span class="n">G_latt_iw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_parproj</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                        <span class="n">tmp</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt_iw</span><span class="p">[</span>
                                                    <span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="n">ir</span><span class="p">)</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>

        <span class="c1"># Collect data from mpi:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># Symmetrize and rotate to local coord. system if needed:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmpar</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">G_loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                        <span class="n">ish</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toLocal&#39;</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">):</span>
            <span class="n">isp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dens_mat_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ish</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">density</span><span class="p">()[</span><span class="n">bname</span><span class="p">]</span>
                <span class="n">isp</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Add density matrices to get the total:</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">dens_mat_below</span><span class="p">[</span><span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">]]][</span><span class="n">ish</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dens_mat_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ish</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_shells</span><span class="p">)]</span>
                    <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spn</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>

<div class="viewcode-block" id="SumkDFTTools.print_hamiltonian"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.print_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">print_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints the Kohn-Sham Hamiltonian to the text files hamup.dat and hamdn.dat (no spin orbit-coupling), or to ham.dat (with spin-orbit coupling).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;hamup.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">f2</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;hamdn.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">    </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="n">f2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">    </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
                <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">f2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f1</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">f2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;ham.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">    </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1"># ----------------- transport -----------------------</span>

<div class="viewcode-block" id="SumkDFTTools.read_transport_input_from_hdf"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.read_transport_input_from_hdf">[docs]</a>    <span class="k">def</span> <span class="nf">read_transport_input_from_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads the data for transport calculations from the hdf5 archive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window_optics&#39;</span><span class="p">,</span> <span class="s1">&#39;velocities_k&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">transp_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">thingstoread</span><span class="p">)</span>
        <span class="n">thingstoread</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;band_window&#39;</span><span class="p">,</span> <span class="s1">&#39;lattice_angles&#39;</span><span class="p">,</span> <span class="s1">&#39;lattice_constants&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;lattice_type&#39;</span><span class="p">,</span> <span class="s1">&#39;n_symmetries&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_symmetries&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
            <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">misc_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">thingstoread</span><span class="p">)</span></div>

<div class="viewcode-block" id="SumkDFTTools.cellvolume"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.cellvolume">[docs]</a>    <span class="k">def</span> <span class="nf">cellvolume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice_type</span><span class="p">,</span> <span class="n">lattice_constants</span><span class="p">,</span> <span class="n">latticeangle</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the conventional und primitive unit cell volumes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lattice_type : string</span>
<span class="sd">            Lattice type according to the Wien2k convention (P, F, B, R, H, CXY, CYZ, CXZ).</span>
<span class="sd">        lattice_constants : list of double</span>
<span class="sd">            Lattice constants (a, b, c).</span>
<span class="sd">        lattice angles : list of double</span>
<span class="sd">            Lattice angles (:math:`\alpha, \beta, \gamma`).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol_c : double</span>
<span class="sd">            Conventional unit cell volume.</span>
<span class="sd">        vol_p : double</span>
<span class="sd">            Primitive unit cell volume.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">lattice_constants</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">c_al</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latticeangle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c_be</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latticeangle</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c_ga</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latticeangle</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">vol_c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> \
            <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">c_al</span> <span class="o">*</span> <span class="n">c_be</span> <span class="o">*</span> <span class="n">c_ga</span> <span class="o">-</span>
                       <span class="n">c_al</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">c_be</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">c_ga</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">det</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;P&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
               <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;CXY&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;CYZ&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;CXZ&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
        <span class="n">vol_p</span> <span class="o">=</span> <span class="n">vol_c</span> <span class="o">/</span> <span class="n">det</span><span class="p">[</span><span class="n">lattice_type</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">vol_c</span><span class="p">,</span> <span class="n">vol_p</span></div>

    <span class="c1"># Uses .data of only GfReFreq objects.</span>
<div class="viewcode-block" id="SumkDFTTools.transport_distribution"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.transport_distribution">[docs]</a>    <span class="k">def</span> <span class="nf">transport_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;xx&#39;</span><span class="p">],</span> <span class="n">energy_window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Om_mesh</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_om</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transport distribution</span>

<span class="sd">        .. math::</span>
<span class="sd">           \Gamma_{\alpha\beta}\left(\omega+\Omega/2, \omega-\Omega/2\right) = \frac{1}{V} \sum_k Tr\left(v_{k,\alpha}A_{k}(\omega+\Omega/2)v_{k,\beta}A_{k}\left(\omega-\Omega/2\right)\right)</span>

<span class="sd">        in the direction :math:`\alpha\beta`. The velocities :math:`v_{k}` are read from the transport subgroup of the hdf5 archive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        beta : double</span>
<span class="sd">            Inverse temperature :math:`\beta`.</span>
<span class="sd">        directions : list of double, optional</span>
<span class="sd">            :math:`\alpha\beta` e.g.: [&#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;,&#39;xy&#39;,&#39;xz&#39;,&#39;yz&#39;].</span>
<span class="sd">        energy_window : list of double, optional</span>
<span class="sd">            Specifies the upper and lower limit of the frequency integration for :math:`\Omega=0.0`. The window is automatically enlarged by the largest :math:`\Omega` value,</span>
<span class="sd">            hence the integration is performed in the interval [energy_window[0]-max(Om_mesh), energy_window[1]+max(Om_mesh)].</span>
<span class="sd">        Om_mesh : list of double, optional</span>
<span class="sd">            :math:`\Omega` frequency mesh of the optical conductivity. For the conductivity and the Seebeck coefficient :math:`\Omega=0.0` has to be</span>
<span class="sd">            part of the mesh. In the current version Om_mesh is repined to the mesh provided by the self-energy! The actual mesh is printed on the screen and stored as</span>
<span class="sd">            member Om_mesh.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">            Determines whether the calculation is performed with or without self energy. If this parameter is set to False the self energy is set to zero (i.e. the DFT band</span>
<span class="sd">            structure :math:`A(k,\omega)` is used). Note: For with_Sigma=False it is necessary to specify the parameters energy_window, n_om and broadening.</span>
<span class="sd">        n_om : integer, optional</span>
<span class="sd">            Number of equidistant frequency points in the interval [energy_window[0]-max(Om_mesh), energy_window[1]+max(Om_mesh)]. This parameters is only used if</span>
<span class="sd">            with_Sigma = False.</span>
<span class="sd">        broadening : double, optional</span>
<span class="sd">            Lorentzian broadening. It is necessary to specify the boradening if with_Sigma = False, otherwise this parameter can be set to 0.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if wien converter was called and read transport subgroup form</span>
        <span class="c1"># hdf file</span>
        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transp_data</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;transport_distribution: No </span><span class="si">%s</span><span class="s2"> subgroup in hdf file found! Call convert_transp_input first.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">transp_data</span><span class="p">)</span>
            <span class="c1"># check if outputs file was converted</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s1">&#39;n_symmetries&#39;</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;transport_distribution: n_symmetries missing. Check if case.outputs file is present and call convert_misc_input() or convert_dft_input().&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">read_transport_input_from_hdf</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="c1"># k-dependent-projections.</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_dep_projection</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: k dependent projection is not implemented!&quot;</span>
            <span class="c1"># positive Om_mesh</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
                <span class="n">Om</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">Om</span> <span class="ow">in</span> <span class="n">Om_mesh</span><span class="p">),</span> <span class="s2">&quot;transport_distribution: Om_mesh should not contain negative values!&quot;</span>

        <span class="c1"># Check if energy_window is sufficiently large and correct</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">assert</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: energy_window wrong!&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span><span class="o">-</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">beta</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-5</span>
                <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span><span class="o">-</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">beta</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1e-5</span><span class="p">):</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">####################################################################&quot;</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                <span class="s2">&quot;transport_distribution: WARNING - energy window might be too narrow!&quot;</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                <span class="s2">&quot;####################################################################</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># up and down are equivalent if SP = 0</span>
        <span class="n">n_inequiv_spin_blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="n">directions</span>
        <span class="n">dir_to_int</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>

        <span class="c1"># calculate A(k,w)</span>
        <span class="c1">#######################################</span>

        <span class="c1"># Define mesh for Green&#39;s function and in the specified energy window</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">with_Sigma</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">])</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
            <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Using omega mesh provided by Sigma!&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">energy_window</span><span class="p">:</span>
                <span class="c1"># Find according window in Sigma mesh</span>
                <span class="n">ioffset</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">&lt;</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">&gt;=</span> <span class="n">energy_window</span><span class="p">[</span>
                                                          <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">&lt;=</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">))]</span>
                <span class="n">n_om</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>

                <span class="c1"># Truncate Sigma to given omega window</span>
                <span class="c1"># In the future there should be an option in gf to manipulate the mesh (e.g. truncate) directly.</span>
                <span class="c1"># For now we stick with this:</span>
                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                    <span class="n">Sigma_save</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>
                    <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span>
                                              <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_points</span><span class="o">=</span><span class="n">n_om</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span>
                        <span class="n">name_list</span><span class="o">=</span><span class="n">spn</span><span class="p">,</span> <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">(),</span> <span class="n">make_copies</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">iL</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="k">for</span> <span class="n">iom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                                    <span class="n">g</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">iom</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iL</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">iR</span><span class="p">)]</span> <span class="o">=</span> <span class="n">Sigma_save</span><span class="p">[</span>
                                        <span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">ioffset</span> <span class="o">+</span> <span class="n">iom</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iL</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">iR</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n_om</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: Number of omega points (n_om) needed to calculate transport distribution!&quot;</span>
            <span class="k">assert</span> <span class="n">energy_window</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: Energy window needed to calculate transport distribution!&quot;</span>
            <span class="k">assert</span> <span class="n">broadening</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;transport_distribution: Broadening necessary to calculate transport distribution!&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">n_om</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span>
                    <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">n_om</span><span class="p">]</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Define mesh for optic conductivity</span>
        <span class="n">d_omega</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">12</span><span class="p">)</span>
        <span class="n">iOm_mesh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">round</span><span class="p">((</span><span class="n">Om</span> <span class="o">/</span> <span class="n">d_omega</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">Om</span> <span class="ow">in</span> <span class="n">Om_mesh</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span> <span class="o">=</span> <span class="n">iOm_mesh</span> <span class="o">*</span> <span class="n">d_omega</span>

        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Chemical potential: &quot;</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using n_om = </span><span class="si">%s</span><span class="s2"> points in the energy_window [</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_om</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;where the omega vector is:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calculation requested for Omega mesh:   &quot;</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Om_mesh</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Omega mesh automatically repined to:  &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">),</span> <span class="n">n_om</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>

        <span class="c1"># Sum over all k-points</span>
        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="c1"># Calculate G_w  for ik and initialize A_kw</span>
            <span class="n">G_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span>
                                  <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">)</span>
            <span class="n">A_kw</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">][</span><span class="n">isp</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">][</span><span class="n">isp</span><span class="p">],</span> <span class="n">n_om</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inequiv_spin_blocks</span><span class="p">)]</span>

            <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inequiv_spin_blocks</span><span class="p">):</span>
                <span class="c1"># copy data from G_w (swapaxes is used to have omega in the 3rd</span>
                <span class="c1"># dimension)</span>
                <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">G_w</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span>
                                          <span class="n">isp</span><span class="p">]]</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
                <span class="c1"># calculate A(k,w) for each frequency</span>
                <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                    <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][:,</span> <span class="p">:,</span> <span class="n">iw</span><span class="p">])))</span>

                <span class="n">b_min</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">b_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">A_i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span>
                    <span class="n">b_min</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">v_i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">b_min</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b_max</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># loop over all symmetries</span>
                <span class="k">for</span> <span class="n">R</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_symmetries</span><span class="p">:</span>
                    <span class="c1"># get transformed velocity under symmetry R</span>
                    <span class="n">vel_R</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">velocities_k</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">nu1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">nu2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_window_optics</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                            <span class="n">vel_R</span><span class="p">[</span><span class="n">nu1</span><span class="p">][</span><span class="n">nu2</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                                <span class="n">R</span><span class="p">,</span> <span class="n">vel_R</span><span class="p">[</span><span class="n">nu1</span><span class="p">][</span><span class="n">nu2</span><span class="p">][:])</span>

                    <span class="c1"># calculate Gamma_w for each direction from the velocities</span>
                    <span class="c1"># vel_R and the spectral function A_kw</span>
                    <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_om</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">)):</span>
                                <span class="k">if</span><span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="n">iOm_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n_om</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">+</span> <span class="n">energy_window</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="k">continue</span>

                                <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">,</span> <span class="n">iw</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vel_R</span><span class="p">[</span><span class="n">v_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">dir_to_int</span><span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">0</span><span class="p">]]],</span>
                                                                                                  <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">A_i</span><span class="p">,</span> <span class="n">A_i</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">iw</span> <span class="o">+</span> <span class="n">iOm_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">])]),</span> <span class="n">vel_R</span><span class="p">[</span><span class="n">v_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">dir_to_int</span><span class="p">[</span><span class="n">direction</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]),</span>
                                                                              <span class="n">A_kw</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">A_i</span><span class="p">,</span> <span class="n">A_i</span><span class="p">,</span> <span class="n">iw</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
                                       <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">cellvolume</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_constants</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_angles</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_symmetries</span><span class="p">)</span></div>

<div class="viewcode-block" id="SumkDFTTools.transport_coefficient"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.transport_coefficient">[docs]</a>    <span class="k">def</span> <span class="nf">transport_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the transport coefficient A_n in a given direction for a given :math:`\Omega`. The required members (Gamma_w, directions, Om_mesh) have to be obtained first</span>
<span class="sd">        by calling the function :meth:`transport_distribution &lt;dft.sumk_dft_tools.SumkDFTTools.transport_distribution&gt;`. For n&gt;0 A is set to NaN if :math:`\Omega` is not 0.0.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        direction : string</span>
<span class="sd">           :math:`\alpha\beta` e.g.: &#39;xx&#39;,&#39;yy&#39;,&#39;zz&#39;,&#39;xy&#39;,&#39;xz&#39;,&#39;yz&#39;.</span>
<span class="sd">        iq : integer</span>
<span class="sd">            Index of :math:`\Omega` point in the member Om_mesh.</span>
<span class="sd">        n : integer</span>
<span class="sd">            Number of the desired moment of the transport distribution.</span>
<span class="sd">        beta : double</span>
<span class="sd">            Inverse temperature :math:`\beta`.</span>
<span class="sd">        method : string</span>
<span class="sd">            Integration method: cubic spline and scipy.integrate.quad (&#39;quad&#39;), simpson rule (&#39;simps&#39;), trapezoidal rule (&#39;trapz&#39;), rectangular integration (otherwise)</span>
<span class="sd">            Note that the sampling points of the the self-energy are used!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A : double</span>
<span class="sd">            Transport coefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Gamma_w&#39;</span><span class="p">),</span> <span class="s2">&quot;transport_coefficient: Run transport_distribution first or load data from h5!&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">A</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># setup the integrand</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="n">A_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">beta</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="n">n</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="n">A_int</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">beta</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">fermi_dis</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">beta</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span>

            <span class="c1"># w-integration</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;quad&#39;</span><span class="p">:</span>
                <span class="c1"># quad on interpolated w-points with cubic spline</span>
                <span class="n">A_int_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">A_int</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">A_int_interp</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">),</span>
                         <span class="n">epsabs</span><span class="o">=</span><span class="mf">1.0e-12</span><span class="p">,</span> <span class="n">epsrel</span><span class="o">=</span><span class="mf">1.0e-12</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">500</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;simps&#39;</span><span class="p">:</span>
                <span class="c1"># simpson rule for w-grid</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">simps</span><span class="p">(</span><span class="n">A_int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;trapz&#39;</span><span class="p">:</span>
                <span class="c1"># trapezoidal rule for w-grid</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">A_int</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># rectangular integration for w-grid (orignal implementation)</span>
                <span class="n">d_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">iw</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">A</span> <span class="o">+=</span> <span class="n">A_int</span><span class="p">[</span><span class="n">iw</span><span class="p">]</span> <span class="o">*</span> <span class="n">d_w</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="n">A</span></div>

<div class="viewcode-block" id="SumkDFTTools.conductivity_and_seebeck"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.conductivity_and_seebeck">[docs]</a>    <span class="k">def</span> <span class="nf">conductivity_and_seebeck</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the Seebeck coefficient and the optical conductivity by calling</span>
<span class="sd">        :meth:`transport_coefficient &lt;dft.sumk_dft_tools.SumkDFTTools.transport_coefficient&gt;`.</span>
<span class="sd">        The required members (Gamma_w, directions, Om_mesh) have to be obtained first by calling the function</span>
<span class="sd">        :meth:`transport_distribution &lt;dft.sumk_dft_tools.SumkDFTTools.transport_distribution&gt;`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        beta : double</span>
<span class="sd">            Inverse temperature :math:`\beta`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        optic_cond : dictionary of double vectors</span>
<span class="sd">            Optical conductivity in each direction and frequency given by Om_mesh.</span>

<span class="sd">        seebeck : dictionary of double</span>
<span class="sd">            Seebeck coefficient in each direction. If zero is not present in Om_mesh the Seebeck coefficient is set to NaN.</span>

<span class="sd">        kappa : dictionary of double.</span>
<span class="sd">            thermal conductivity in each direction. If zero is not present in Om_mesh the thermal conductivity is set to NaN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Gamma_w&#39;</span><span class="p">),</span> <span class="s2">&quot;conductivity_and_seebeck: Run transport_distribution first or load data from h5!&quot;</span>
        <span class="n">n_q</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Gamma_w</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">A0</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>
        <span class="n">A1</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>
        <span class="n">A2</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seebeck</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">optic_cond</span> <span class="o">=</span> <span class="p">{</span><span class="n">direction</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="p">(</span><span class="n">n_q</span><span class="p">,),</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transport_coefficient</span><span class="p">(</span>
                    <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transport_coefficient</span><span class="p">(</span>
                    <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transport_coefficient</span><span class="p">(</span>
                    <span class="n">direction</span><span class="p">,</span> <span class="n">iq</span><span class="o">=</span><span class="n">iq</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_0 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> a.u.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_1 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> a.u.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;A_2 in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">    </span><span class="si">%e</span><span class="s2"> a.u.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="k">if</span> <span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]):</span>
                    <span class="c1"># Seebeck and kappa are overwritten if there is more than one Omega =</span>
                    <span class="c1"># 0 in Om_mesh</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">seebeck</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> \
                        <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">/</span> <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">*</span> <span class="mf">86.17</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">A2</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span> <span class="o">-</span> <span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span><span class="o">*</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span><span class="o">/</span><span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">293178.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optic_cond</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> \
                <span class="n">A0</span><span class="p">[</span><span class="n">direction</span><span class="p">]</span> <span class="o">*</span> <span class="mf">10700.0</span> <span class="o">/</span> <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_q</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Conductivity in direction </span><span class="si">%s</span><span class="s2"> for Omega = </span><span class="si">%.2f</span><span class="s2">       </span><span class="si">%f</span><span class="s2">  x 10^4 Ohm^-1 cm^-1&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Om_mesh</span><span class="p">[</span><span class="n">iq</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">optic_cond</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">]))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">A1</span><span class="p">[</span><span class="n">direction</span><span class="p">][</span><span class="n">iq</span><span class="p">])):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Seebeck in direction      </span><span class="si">%s</span><span class="s2"> for Omega = 0.00      </span><span class="si">%f</span><span class="s2">  x 10^(-6) V/K&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seebeck</span><span class="p">[</span><span class="n">direction</span><span class="p">]))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;kappa in direction      </span><span class="si">%s</span><span class="s2"> for Omega = 0.00      </span><span class="si">%f</span><span class="s2">  W/(m * K)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span><span class="p">[</span><span class="n">direction</span><span class="p">]))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">optic_cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seebeck</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">kappa</span></div>


<div class="viewcode-block" id="SumkDFTTools.fermi_dis"><a class="viewcode-back" href="../../reference/sumk_dft_tools.html#triqs_dft_tools.sumk_dft_tools.SumkDFTTools.fermi_dis">[docs]</a>    <span class="k">def</span> <span class="nf">fermi_dis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">beta</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fermi distribution.</span>

<span class="sd">        .. math::</span>
<span class="sd">           f(x) = 1/(e^x+1).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        w : double</span>
<span class="sd">           frequency</span>
<span class="sd">        beta : double</span>
<span class="sd">           inverse temperature</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f : double</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">beta</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">triqs_dft_tools.sumk_dft_tools</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2020.
    </div>
  </body>
</html>