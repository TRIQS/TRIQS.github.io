<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>triqs_dft_tools.sumk_dft &mdash; TRIQS DFTTools  documentation</title>
    
    <link rel="stylesheet" href="../../_static/triqs.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=default"></script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="TRIQS DFTTools  documentation" href="../../contents.html" />
    <link rel="up" title="Module code" href="../index.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head>
  <body role="document">
<div class="pageheader">
  <ul>
    
    <li><a href="../../install.html">Install</a></li>
    
    <li><a href="../../documentation.html">Documentation</a></li>
    
    <li><a href="../../issues.html">Issues</a></li>
    
    <li><a href="../../about.html">About DFTTools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../../index.html">dft tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://triqs.github.io/triqs">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for triqs_dft_tools.sumk_dft</h1><div class="highlight"><pre>

<span class="c1">##########################################################################</span>
<span class="c1">#</span>
<span class="c1"># TRIQS: a Toolbox for Research in Interacting Quantum Systems</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2011 by M. Aichhorn, L. Pourovskii, V. Vildosola</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is free software: you can redistribute it and/or modify it under the</span>
<span class="c1"># terms of the GNU General Public License as published by the Free Software</span>
<span class="c1"># Foundation, either version 3 of the License, or (at your option) any later</span>
<span class="c1"># version.</span>
<span class="c1">#</span>
<span class="c1"># TRIQS is distributed in the hope that it will be useful, but WITHOUT ANY</span>
<span class="c1"># WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE. See the GNU General Public License for more</span>
<span class="c1"># details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License along with</span>
<span class="c1"># TRIQS. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="c1">##########################################################################</span>

<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">pytriqs.utility.dichotomy</span> <span class="kn">as</span> <span class="nn">dichotomy</span>
<span class="kn">from</span> <span class="nn">pytriqs.gf</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">pytriqs.utility.mpi</span> <span class="kn">as</span> <span class="nn">mpi</span>
<span class="kn">from</span> <span class="nn">pytriqs.utility.comparison_tests</span> <span class="kn">import</span> <span class="n">assert_arrays_are_close</span>
<span class="kn">from</span> <span class="nn">pytriqs.archive</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">symmetry</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">block_structure</span> <span class="kn">import</span> <span class="n">BlockStructure</span>
<span class="kn">from</span> <span class="nn">sets</span> <span class="kn">import</span> <span class="n">Set</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">compress</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>


<div class="viewcode-block" id="SumkDFT"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT">[docs]</a><span class="k">class</span> <span class="nc">SumkDFT</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This class provides a general SumK method for combining ab-initio code and pytriqs.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="SumkDFT.__init__"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdf_file</span><span class="p">,</span> <span class="n">h_field</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">use_dft_blocks</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">dft_data</span><span class="o">=</span><span class="s1">&#39;dft_input&#39;</span><span class="p">,</span> <span class="n">symmcorr_data</span><span class="o">=</span><span class="s1">&#39;dft_symmcorr_input&#39;</span><span class="p">,</span> <span class="n">parproj_data</span><span class="o">=</span><span class="s1">&#39;dft_parproj_input&#39;</span><span class="p">,</span>
                 <span class="n">symmpar_data</span><span class="o">=</span><span class="s1">&#39;dft_symmpar_input&#39;</span><span class="p">,</span> <span class="n">bands_data</span><span class="o">=</span><span class="s1">&#39;dft_bands_input&#39;</span><span class="p">,</span> <span class="n">transp_data</span><span class="o">=</span><span class="s1">&#39;dft_transp_input&#39;</span><span class="p">,</span>
                 <span class="n">misc_data</span><span class="o">=</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Initialises the class from data previously stored into an hdf5 archive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        hdf_file : string</span>
<span class="sd">                   Name of hdf5 containing the data.</span>
<span class="sd">        h_field : scalar, optional</span>
<span class="sd">                  The value of magnetic field to add to the DFT Hamiltonian. </span>
<span class="sd">                  The contribution -h_field*sigma is added to diagonal elements of the Hamiltonian.</span>
<span class="sd">                  It cannot be used with the spin-orbit coupling on; namely h_field is set to 0 if self.SO=True.</span>
<span class="sd">        use_dft_blocks : boolean, optional</span>
<span class="sd">                         If True, the local Green&#39;s function matrix for each spin is divided into smaller blocks </span>
<span class="sd">                          with the block structure determined from the DFT density matrix of the corresponding correlated shell.</span>

<span class="sd">                         Alternatively and additionally, the block structure can be analysed using :meth:`analyse_block_structure &lt;dft.sumk_dft.SumkDFT.analyse_block_structure&gt;`</span>
<span class="sd">                         and manipulated using the SumkDFT.block_structre attribute (see :class:`BlockStructure &lt;dft.block_structure.BlockStructure&gt;`).</span>
<span class="sd">        dft_data : string, optional</span>
<span class="sd">                   Name of hdf5 subgroup in which DFT data for projector and lattice Green&#39;s function construction are stored.</span>
<span class="sd">        symmcorr_data : string, optional</span>
<span class="sd">                        Name of hdf5 subgroup in which DFT data on symmetries of correlated shells </span>
<span class="sd">                        (symmetry operations, permutaion matrices etc.) are stored.</span>
<span class="sd">        parproj_data : string, optional</span>
<span class="sd">                       Name of hdf5 subgroup in which DFT data on non-normalized projectors for non-correlated</span>
<span class="sd">                       states (used in the partial density of states calculations) are stored.</span>
<span class="sd">        symmpar_data : string, optional</span>
<span class="sd">                       Name of hdf5 subgroup in which DFT data on symmetries of the non-normalized projectors</span>
<span class="sd">                       are stored.</span>
<span class="sd">        bands_data : string, optional</span>
<span class="sd">                     Name of hdf5 subgroup in which DFT data necessary for band-structure/k-resolved spectral</span>
<span class="sd">                     function calculations (projectors, DFT Hamiltonian for a chosen path in the Brillouin zone etc.)</span>
<span class="sd">                     are stored.</span>
<span class="sd">        transp_data : string, optional</span>
<span class="sd">                      Name of hdf5 subgroup in which DFT data necessary for transport calculations are stored.</span>
<span class="sd">        misc_data : string, optional</span>
<span class="sd">                    Name of hdf5 subgroup in which miscellaneous DFT data are stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">hdf_file</span><span class="p">)</span> <span class="o">==</span> <span class="n">StringType</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Give a string for the hdf5 filename to read the input!&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span> <span class="o">=</span> <span class="n">hdf_file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span> <span class="o">=</span> <span class="n">dft_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span> <span class="o">=</span> <span class="n">symmcorr_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parproj_data</span> <span class="o">=</span> <span class="n">parproj_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symmpar_data</span> <span class="o">=</span> <span class="n">symmpar_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bands_data</span> <span class="o">=</span> <span class="n">bands_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transp_data</span> <span class="o">=</span> <span class="n">transp_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">misc_data</span> <span class="o">=</span> <span class="n">misc_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">=</span> <span class="n">h_field</span>

            <span class="c1"># Read input from HDF:</span>
            <span class="n">things_to_read</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;energy_unit&#39;</span><span class="p">,</span> <span class="s1">&#39;n_k&#39;</span><span class="p">,</span> <span class="s1">&#39;k_dep_projection&#39;</span><span class="p">,</span> <span class="s1">&#39;SP&#39;</span><span class="p">,</span> <span class="s1">&#39;SO&#39;</span><span class="p">,</span> <span class="s1">&#39;charge_below&#39;</span><span class="p">,</span> <span class="s1">&#39;density_required&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;symm_op&#39;</span><span class="p">,</span> <span class="s1">&#39;n_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;shells&#39;</span><span class="p">,</span> <span class="s1">&#39;n_corr_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;corr_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;use_rotations&#39;</span><span class="p">,</span> <span class="s1">&#39;rot_mat&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;rot_mat_time_inv&#39;</span><span class="p">,</span> <span class="s1">&#39;n_reps&#39;</span><span class="p">,</span> <span class="s1">&#39;dim_reps&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;n_orbitals&#39;</span><span class="p">,</span> <span class="s1">&#39;proj_mat&#39;</span><span class="p">,</span> <span class="s1">&#39;bz_weights&#39;</span><span class="p">,</span> <span class="s1">&#39;hopping&#39;</span><span class="p">,</span>
                              <span class="s1">&#39;n_inequiv_shells&#39;</span><span class="p">,</span> <span class="s1">&#39;corr_to_inequiv&#39;</span><span class="p">,</span> <span class="s1">&#39;inequiv_to_corr&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subgroup_present</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_read</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_input_from_hdf</span><span class="p">(</span>
                <span class="n">subgrp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dft_data</span><span class="p">,</span> <span class="n">things_to_read</span><span class="o">=</span><span class="n">things_to_read</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span> <span class="o">=</span> <span class="n">Symmetry</span><span class="p">(</span><span class="n">hdf_file</span><span class="p">,</span> <span class="n">subgroup</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symmcorr_data</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_field</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.000001</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s2">&quot;For SO, the external magnetic field is not implemented, setting it to 0!&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;ud&#39;</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Convert spin_block_names to indices -- if spin polarized,</span>
            <span class="c1"># differentiate up and down blocks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span> <span class="o">=</span> <span class="p">[{},</span> <span class="p">{}]</span>
            <span class="k">for</span> <span class="n">iso</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>  <span class="c1"># SO = 0 or 1</span>
                <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="n">iso</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="n">iso</span><span class="p">][</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="n">iso</span><span class="p">][</span><span class="n">isp</span><span class="p">]]</span> <span class="o">=</span> <span class="n">isp</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span> <span class="o">=</span> <span class="n">BlockStructure</span><span class="p">()</span>

            <span class="c1"># GF structure used for the local things in the k sums</span>
            <span class="c1"># Most general form allowing for all hybridisation, i.e. largest</span>
            <span class="c1"># blocks possible</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]]</span>
                                   <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="c1"># First set a standard gf_struct solver:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">([(</span><span class="n">sp</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]))</span>
                                           <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]])</span>
                                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="c1"># Set standard (identity) maps from gf_struct_sumk &lt;-&gt;</span>
            <span class="c1"># gf_struct_solver</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="p">[{}</span>
                                         <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>
                    <span class="k">for</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">inner_list</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">inner</span><span class="p">)</span>
            <span class="c1"># assume no shells are degenerate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># initialise mu</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">init_dc</span><span class="p">()</span>  <span class="c1"># initialise the double counting</span>

            <span class="c1"># Analyse the block structure and determine the smallest gf_struct</span>
            <span class="c1"># blocks and maps, if desired</span>
            <span class="k">if</span> <span class="n">use_dft_blocks</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">analyse_block_structure</span><span class="p">()</span></div>

<span class="c1">################</span>
<span class="c1"># hdf5 FUNCTIONS</span>
<span class="c1">################</span>

<div class="viewcode-block" id="SumkDFT.read_input_from_hdf"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.read_input_from_hdf">[docs]</a>    <span class="k">def</span> <span class="nf">read_input_from_hdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgrp</span><span class="p">,</span> <span class="n">things_to_read</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Reads data from the HDF file. Prints a warning if a requested dataset is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        subgrp : string</span>
<span class="sd">                 Name of hdf5 file subgroup from which the data are to be read.</span>
<span class="sd">        things_to_read : list of strings</span>
<span class="sd">                         List of datasets to be read from the hdf5 file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        subgroup_present : boolean</span>
<span class="sd">                           Is the subgrp is present in hdf5 file?</span>
<span class="sd">        value_read : boolean</span>
<span class="sd">                     Did the reading of requested datasets succeed?</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># initialise variables on all nodes to ensure mpi broadcast works at</span>
        <span class="c1"># the end</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">subgroup_present</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
                <span class="n">subgroup_present</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="c1"># first read the necessary things:</span>
                <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">]:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Loading </span><span class="si">%s</span><span class="s2"> failed!&quot;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span>
                        <span class="n">value_read</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">things_to_read</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                        <span class="s2">&quot;Loading failed: No </span><span class="si">%s</span><span class="s2"> subgroup in hdf5!&quot;</span> <span class="o">%</span> <span class="n">subgrp</span><span class="p">)</span>
                <span class="n">subgroup_present</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">value_read</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">del</span> <span class="n">ar</span>
        <span class="c1"># now do the broadcasting:</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_read</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">,</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)))</span>
        <span class="n">subgroup_present</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">subgroup_present</span><span class="p">)</span>
        <span class="n">value_read</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">value_read</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">subgroup_present</span><span class="p">,</span> <span class="n">value_read</span></div>

<div class="viewcode-block" id="SumkDFT.save"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">things_to_save</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s1">&#39;user_data&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Saves data from a list into the HDF file. Prints a warning if a requested data is not found in SumkDFT object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        things_to_save : list of strings</span>
<span class="sd">                         List of datasets to be saved into the hdf5 file.</span>
<span class="sd">        subgrp : string, optional</span>
<span class="sd">                 Name of hdf5 file subgroup in which the data are to be stored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>  <span class="c1"># do nothing on nodes</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
            <span class="n">ar</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="n">subgrp</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">it</span> <span class="ow">in</span> <span class="p">[</span> <span class="s2">&quot;gf_struct_sumk&quot;</span><span class="p">,</span> <span class="s2">&quot;gf_struct_solver&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;solver_to_sumk&quot;</span><span class="p">,</span> <span class="s2">&quot;sumk_to_solver&quot;</span><span class="p">,</span> <span class="s2">&quot;solver_to_sumk_block&quot;</span><span class="p">]:</span>
                <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;It is not recommended to save &#39;{}&#39; individually. Save &#39;block_structure&#39; instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">it</span><span class="p">))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">it</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> not found, and so not saved.&quot;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ar</span></div>

<div class="viewcode-block" id="SumkDFT.load"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">things_to_load</span><span class="p">,</span> <span class="n">subgrp</span><span class="o">=</span><span class="s1">&#39;user_data&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Loads user data from the HDF file. Raises an exeption if a requested dataset is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        things_to_read : list of strings</span>
<span class="sd">                         List of datasets to be read from the hdf5 file.</span>
<span class="sd">        subgrp : string, optional</span>
<span class="sd">                 Name of hdf5 file subgroup from which the data are to be read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list_to_return : list</span>
<span class="sd">                         A list containing data read from hdf5.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
            <span class="k">return</span>  <span class="c1"># do nothing on nodes</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">subgrp</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">:</span>
            <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Loading </span><span class="si">%s</span><span class="s2"> failed!&quot;</span> <span class="o">%</span> <span class="n">subgrp</span><span class="p">)</span>
        <span class="n">list_to_return</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">things_to_load</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">list_to_return</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="n">subgrp</span><span class="p">][</span><span class="n">it</span><span class="p">])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;load: </span><span class="si">%s</span><span class="s2"> not found, and so not loaded.&quot;</span> <span class="o">%</span> <span class="n">it</span>
        <span class="k">del</span> <span class="n">ar</span>
        <span class="k">return</span> <span class="n">list_to_return</span></div>

<span class="c1">################</span>
<span class="c1"># CORE FUNCTIONS</span>
<span class="c1">################</span>

<div class="viewcode-block" id="SumkDFT.downfold"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.downfold">[docs]</a>    <span class="k">def</span> <span class="nf">downfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf_to_downfold</span><span class="p">,</span> <span class="n">gf_inp</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Downfolds a block of the Green&#39;s function for a given shell and k-point using the corresponding projector matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index for which the downfolding is to be done.</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be downfolded.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        bname : string</span>
<span class="sd">                Block name of the target block of the lattice Green&#39;s function.</span>
<span class="sd">        gf_to_downfold : Gf </span>
<span class="sd">                       Block of the Green&#39;s function that is to be downfolded.</span>
<span class="sd">        gf_inp : Gf </span>
<span class="sd">                 FIXME </span>
<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: orthonormalized projectors for correlated shells are used for the downfolding.</span>
<span class="sd">                 - if shells=&#39;all&#39;: non-normalized projectors for all included shells are used for the downfolding.</span>

<span class="sd">        ir : integer, optional</span>
<span class="sd">             Index of equivalent site in the non-correlated shell &#39;ish&#39;, only used if shells=&#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_downfolded : Gf</span>
<span class="sd">                      Downfolded block of the lattice Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf_downfolded</span> <span class="o">=</span> <span class="n">gf_inp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get spin index for proj. matrices</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ir</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;downfold: provide ir if treating all shells.&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_all</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>

        <span class="n">gf_downfolded</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span>
            <span class="n">projmat</span><span class="p">,</span> <span class="n">gf_to_downfold</span><span class="p">,</span> <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">gf_downfolded</span></div>

<div class="viewcode-block" id="SumkDFT.upfold"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.upfold">[docs]</a>    <span class="k">def</span> <span class="nf">upfold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf_to_upfold</span><span class="p">,</span> <span class="n">gf_inp</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">,</span> <span class="n">ir</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Upfolds a block of the Green&#39;s function for a given shell and k-point using the corresponding projector matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index for which the upfolding is to be done.</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be upfolded.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        bname : string</span>
<span class="sd">                Block name of the target block of the lattice Green&#39;s function.</span>
<span class="sd">        gf_to_upfold : Gf </span>
<span class="sd">                       Block of the Green&#39;s function that is to be upfolded.</span>
<span class="sd">        gf_inp : Gf </span>
<span class="sd">                 FIXME </span>
<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: orthonormalized projectors for correlated shells are used for the upfolding.</span>
<span class="sd">                 - if shells=&#39;all&#39;: non-normalized projectors for all included shells are used for the upfolding.</span>

<span class="sd">        ir : integer, optional</span>
<span class="sd">             Index of equivalent site in the non-correlated shell &#39;ish&#39;, only used if shells=&#39;all&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_upfolded : Gf</span>
<span class="sd">                      Upfolded block of the lattice Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf_upfolded</span> <span class="o">=</span> <span class="n">gf_inp</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># get spin index for proj. matrices</span>
        <span class="n">isp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span>
        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ir</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;upfold: provide ir if treating all shells.&quot;</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat_all</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">ir</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>

        <span class="n">gf_upfolded</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span>
            <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_to_upfold</span><span class="p">,</span> <span class="n">projmat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">gf_upfolded</span></div>

<div class="viewcode-block" id="SumkDFT.rotloc"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.rotloc">[docs]</a>    <span class="k">def</span> <span class="nf">rotloc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">gf_to_rotate</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">shells</span><span class="o">=</span><span class="s1">&#39;corr&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Rotates a block of the local Green&#39;s function from the local frame to the global frame and vice versa.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ish : integer</span>
<span class="sd">              Shell index of GF to be rotated.</span>

<span class="sd">              - if shells=&#39;corr&#39;: ish labels all correlated shells (equivalent or not)</span>
<span class="sd">              - if shells=&#39;all&#39;: ish labels only representative (inequivalent) non-correlated shells</span>

<span class="sd">        gf_to_rotate : Gf </span>
<span class="sd">                       Block of the Green&#39;s function that is to be rotated.</span>
<span class="sd">        direction : string</span>
<span class="sd">                    The direction of rotation can be either </span>

<span class="sd">                    - &#39;toLocal&#39; : global -&gt; local transformation,</span>
<span class="sd">                    - &#39;toGlobal&#39; : local -&gt; global transformation.</span>

<span class="sd">        shells : string, optional</span>

<span class="sd">                 - if shells=&#39;corr&#39;: the rotation matrix for the correlated shell &#39;ish&#39; is used,</span>
<span class="sd">                 - if shells=&#39;all&#39;: the rotation matrix for the generic (non-correlated) shell &#39;ish&#39; is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf_rotated : Gf</span>
<span class="sd">                     Rotated block of the local Green&#39;s function.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="p">((</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toLocal&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toGlobal&#39;</span><span class="p">)</span>
                <span class="p">),</span> <span class="s2">&quot;rotloc: Give direction &#39;toLocal&#39; or &#39;toGlobal&#39;.&quot;</span>
        <span class="n">gf_rotated</span> <span class="o">=</span> <span class="n">gf_to_rotate</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;corr&#39;</span><span class="p">:</span>
            <span class="n">rot_mat_time_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span>
        <span class="k">elif</span> <span class="n">shells</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">rot_mat_time_inv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_all_time_inv</span>
            <span class="n">rot_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_all</span>

        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toGlobal&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">:</span>
                <span class="n">gf_rotated</span> <span class="o">&lt;&lt;</span> <span class="n">gf_rotated</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                <span class="p">),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span>
                                      <span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;toLocal&#39;</span><span class="p">:</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">:</span>
                <span class="n">gf_rotated</span> <span class="o">&lt;&lt;</span> <span class="n">gf_rotated</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span>
                <span class="p">),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gf_rotated</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
                <span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_rotated</span><span class="p">,</span> <span class="n">rot_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">gf_rotated</span></div>

<div class="viewcode-block" id="SumkDFT.lattice_gf"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.lattice_gf">[docs]</a>    <span class="k">def</span> <span class="nf">lattice_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;iw&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the lattice Green function for a given k-point from the DFT Hamiltonian and the self energy. </span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ik : integer</span>
<span class="sd">             k-point index.</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">             Chemical potential for which the Green&#39;s function is to be calculated.</span>
<span class="sd">             If not provided, self.chemical_potential is used for mu.</span>
<span class="sd">        iw_or_w : string, optional</span>

<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>

<span class="sd">        beta : real, optional</span>
<span class="sd">               Inverse temperature.</span>
<span class="sd">        broadening : real, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">        mesh : list, optional</span>
<span class="sd">               Data defining mesh on which the real-axis GF will be calculated, given in the form</span>
<span class="sd">               (om_min,om_max,n_points), where om_min is the minimum omega, om_max is the maximum omega and n_points is the number of points.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True the GF will be calculated with the self-energy stored in self.Sigmaimp_(w/iw), for real/Matsubara GF, respectively. </span>
<span class="sd">                     In this case the mesh is taken from the self.Sigma_imp object.</span>
<span class="sd">                     If with_Sigma=True but self.Sigmaimp_(w/iw) is not present, with_Sigma is reset to False.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  if True and with_Sigma=True, the dc correction is substracted from the self-energy before it is included into GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_latt : BlockGf</span>
<span class="sd">                 Lattice Green&#39;s function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iw_or_w</span> <span class="o">!=</span> <span class="s2">&quot;iw&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iw_or_w</span> <span class="o">!=</span> <span class="s2">&quot;w&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;lattice_gf: Implemented only for Re/Im frequency functions.&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">):</span>
            <span class="n">with_Sigma</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">broadening</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">broadening</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># broadening = 2 * \Delta omega, where \Delta omega is the spacing of omega points</span>
                <span class="n">broadening</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">((</span><span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Are we including Sigma?</span>
        <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
            <span class="n">Sigma_imp</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">)</span>
            <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">with_dc</span><span class="p">:</span>
                <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_dc</span><span class="p">(</span><span class="n">iw_or_w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;iw&quot;</span><span class="p">:</span>
                <span class="c1"># override beta if Sigma_iw is present</span>
                <span class="n">beta</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
                <span class="k">if</span> <span class="n">broadening</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;lattice_gf called with Sigma and broadening &gt; 0 (broadening = {}). You might want to explicitly set the broadening to 0.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">broadening</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;iw&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">beta</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;lattice_gf: Give the beta for the lattice GfReFreq.&quot;</span>
                <span class="c1"># Default number of Matsubara frequencies</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">MeshImFreq</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="s1">&#39;Fermion&#39;</span><span class="p">,</span> <span class="n">n_max</span><span class="o">=</span><span class="mi">1025</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;lattice_gf: Give the mesh=(om_min,om_max,n_points) for the lattice GfReFreq.&quot;</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">MeshReFreq</span><span class="p">(</span><span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Check if G_latt is present</span>
        <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">False</span>                       <span class="c1"># Assume not</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_latt_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">):</span>
            <span class="c1"># Need to create G_latt_(i)w</span>
            <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>                                       <span class="c1"># Check that existing GF is consistent</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_latt_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">)</span>
            <span class="n">GFsize</span> <span class="o">=</span> <span class="p">[</span><span class="n">gf</span><span class="o">.</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">]</span>
            <span class="n">unchangedsize</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">]]]</span> <span class="o">==</span> <span class="n">GFsize</span><span class="p">[</span>
                                <span class="n">isp</span><span class="p">]</span> <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">])])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unchangedsize</span><span class="p">:</span>
                <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;iw&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">G_latt_iw</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">!=</span> <span class="n">beta</span><span class="p">):</span>
                <span class="n">set_up_G_latt</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># additional check for ImFreq</span>

        <span class="c1"># Set up G_latt</span>
        <span class="k">if</span> <span class="n">set_up_G_latt</span><span class="p">:</span>
            <span class="n">block_structure</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]])</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
            <span class="n">gf_struct</span> <span class="o">=</span> <span class="p">[(</span><span class="n">spn</span><span class="p">[</span><span class="n">isp</span><span class="p">],</span> <span class="n">block_structure</span><span class="p">[</span><span class="n">isp</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">isp</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">])]</span>
            <span class="n">block_ind_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;iw&quot;</span><span class="p">:</span>
                <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
                <span class="n">glist</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="n">gf_struct</span><span class="p">]</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="n">BlockGf</span><span class="p">(</span><span class="n">name_list</span><span class="o">=</span><span class="n">block_ind_list</span><span class="p">,</span>
                             <span class="n">block_list</span><span class="o">=</span><span class="n">glist</span><span class="p">(),</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">G_latt</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;iw&quot;</span><span class="p">:</span>
            <span class="n">G_latt</span> <span class="o">&lt;&lt;</span> <span class="n">iOmega_n</span>
        <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
            <span class="n">G_latt</span> <span class="o">&lt;&lt;</span> <span class="n">Omega</span> <span class="o">+</span> <span class="mi">1j</span> <span class="o">*</span> <span class="n">broadening</span>

        <span class="n">idmat</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">idmat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ibl</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_spin_blocks</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">spn</span><span class="p">[</span><span class="n">ibl</span><span class="p">]]</span>
            <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
            <span class="n">M</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span> <span class="o">-</span> \
                <span class="p">(</span><span class="n">idmat</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">*</span> <span class="n">mu</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">idmat</span><span class="p">[</span><span class="n">ibl</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ibl</span><span class="p">))</span>
        <span class="n">G_latt</span> <span class="o">-=</span> <span class="n">M</span>

        <span class="k">if</span> <span class="n">with_Sigma</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt</span><span class="p">:</span>
                    <span class="n">gf</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">upfold</span><span class="p">(</span><span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span>
                                      <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>

        <span class="n">G_latt</span><span class="o">.</span><span class="n">invert</span><span class="p">()</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;G_latt_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">,</span> <span class="n">G_latt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G_latt</span></div>

    <span class="k">def</span> <span class="nf">set_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">put_Sigma</span><span class="p">(</span><span class="n">Sigma_imp</span><span class="p">)</span>

<div class="viewcode-block" id="SumkDFT.put_Sigma"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.put_Sigma">[docs]</a>    <span class="k">def</span> <span class="nf">put_Sigma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sigma_imp</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Inserts the impurity self-energies into the sumk_dft class.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Sigma_imp : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">                    List containing impurity self-energy for all inequivalent correlated shells.</span>
<span class="sd">                    Self-energies for equivalent shells are then automatically set by this function.</span>
<span class="sd">                    The self-energies can be of the real or imaginary-frequency type.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">Sigma_imp</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;put_Sigma: Sigma_imp has to be a list of Sigmas for the correlated shells, even if it is of length 1!&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">Sigma_imp</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">,</span> <span class="s2">&quot;put_Sigma: give exactly one Sigma for each inequivalent corr. shell!&quot;</span>

        <span class="c1"># init self.Sigma_imp_(i)w:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">gf</span><span class="p">,</span> <span class="n">Gf</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshImFreq</span><span class="p">))</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Imaginary frequency Sigma:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                                                               <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]],</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="n">SK_Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">gf</span><span class="p">,</span> <span class="n">Gf</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span> <span class="p">(</span><span class="n">gf</span><span class="o">.</span><span class="n">mesh</span><span class="p">,</span> <span class="n">MeshReFreq</span><span class="p">)</span> <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Real frequency Sigma:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">Sigma_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                                                              <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_sumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]],</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="n">SK_Sigma_imp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;put_Sigma: This type of Sigma is not handled.&quot;</span>

        <span class="c1"># transform the CTQMC blocks to the full matrix:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="c1"># ish is the index of the inequivalent shell corresponding to icrsh</span>
            <span class="n">ish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">SK_Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">block_sumk</span><span class="p">][</span>
                            <span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">Sigma_imp</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span>

        <span class="c1"># rotation from local to global coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">SK_Sigma_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">gf</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span><span class="n">icrsh</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toGlobal&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SumkDFT.extract_G_loc"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.extract_G_loc">[docs]</a>    <span class="k">def</span> <span class="nf">extract_G_loc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s1">&#39;iw&#39;</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Extracts the local downfolded Green function by the Brillouin-zone integration of the lattice Green&#39;s function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : real, optional</span>
<span class="sd">             Input chemical potential. If not provided the value of self.chemical_potential is used as mu.</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">                     If True then the local GF is calculated with the self-energy self.Sigma_imp.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">                  If True then the double-counting correction is subtracted from the self-energy in calculating the GF.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G_loc_inequiv : list of BlockGf (Green&#39;s function) objects</span>
<span class="sd">                        List of the local Green&#39;s functions for all inequivalent correlated shells, </span>
<span class="sd">                        rotated into the corresponding local frames.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>

        <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;iw&quot;</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_iw</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>   <span class="c1"># this list will be returned</span>
            <span class="n">beta</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span>
            <span class="n">G_loc_inequiv</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfImFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()],</span>
                                     <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s2">&quot;w&quot;</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Sigma_imp_w</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>   <span class="c1"># this list will be returned</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span>
            <span class="n">G_loc_inequiv</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span><span class="o">=</span><span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span><span class="n">indices</span><span class="o">=</span><span class="n">inner</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh</span><span class="p">))</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()],</span>
                                     <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>                          <span class="c1"># initialize to zero</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s1">&#39;iw&#39;</span><span class="p">:</span>
                <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iw_or_w</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">mesh_parameters</span> <span class="o">=</span> <span class="p">(</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">omega_min</span><span class="p">,</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">omega_max</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">G_loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="p">))</span>
                <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">mesh_parameters</span><span class="p">)</span>
            <span class="n">G_latt</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="c1"># init temporary storage</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">tmp</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">downfold</span><span class="p">(</span>
                        <span class="n">ik</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="n">bname</span><span class="p">,</span> <span class="n">G_latt</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="n">gf</span><span class="p">)</span>
                <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tmp</span>

        <span class="c1"># Collect data from mpi</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="c1"># G_loc[:] is now the sum over k projected to the local orbitals.</span>
        <span class="c1"># here comes the symmetrisation, if needed:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">G_loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">G_loc</span><span class="p">)</span>

        <span class="c1"># G_loc is rotated to the local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="n">G_loc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotloc</span><span class="p">(</span>
                        <span class="n">icrsh</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;toLocal&#39;</span><span class="p">)</span>

        <span class="c1"># transform to CTQMC blocks:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">G_loc_inequiv</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="n">G_loc</span><span class="p">[</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">block_sumk</span><span class="p">][</span><span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span>

        <span class="c1"># return only the inequivalent shells:</span>
        <span class="k">return</span> <span class="n">G_loc_inequiv</span></div>

<div class="viewcode-block" id="SumkDFT.analyse_block_structure"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.analyse_block_structure">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_block_structure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.00001</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hloc</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Determines the block structure of local Green&#39;s functions by analysing the structure of </span>
<span class="sd">        the corresponding density matrices and the local Hamiltonian. The resulting block structures </span>
<span class="sd">        for correlated shells are stored in the :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;` attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between density matrix / hloc elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of correlated shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all correlated shells will be analysed.</span>
<span class="sd">        dm : list of dict, optional</span>
<span class="sd">             List of density matrices from which block stuctures are to be analysed.</span>
<span class="sd">             Each density matrix is a dict {block names: 2d numpy arrays}.</span>
<span class="sd">             If not provided, dm will be calculated from the DFT Hamiltonian by a simple-point BZ integration.</span>
<span class="sd">        hloc : list of dict, optional</span>
<span class="sd">               List of local Hamiltonian matrices from which block stuctures are to be analysed</span>
<span class="sd">               Each Hamiltonian is a dict {block names: 2d numpy arrays}.</span>
<span class="sd">               If not provided, it will be calculated using eff_atomic_levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="p">[{}</span>
                                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">dm</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_matrix</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;using_point_integration&#39;</span><span class="p">)</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">dm</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
                    <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">hloc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">hloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eff_atomic_levels</span><span class="p">()</span>
        <span class="n">H_loc</span> <span class="o">=</span> <span class="p">[</span><span class="n">hloc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">ish</span><span class="p">]]</span>
                 <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="c1"># gives an index list of entries larger that threshold</span>
                <span class="n">dmbool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>
                <span class="n">hlocbool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">H_loc</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

                <span class="c1"># Determine off-diagonal entries in upper triangular part of</span>
                <span class="c1"># density matrix</span>
                <span class="n">offdiag</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">dmbool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="ow">or</span> <span class="n">hlocbool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="n">offdiag</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Determine the number of non-hybridising blocks in the gf</span>
                <span class="n">blocs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offdiag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pair</span> <span class="o">=</span> <span class="n">offdiag</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">blocs</span><span class="p">,</span> <span class="n">blocs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>     <span class="c1"># In separate blocks?</span>
                                <span class="c1"># Merge two blocks</span>
                                <span class="n">b1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">)))</span>
                                <span class="k">break</span>                                  <span class="c1"># Move on to next pair in offdiag</span>

                <span class="c1"># Set the gf_struct for the solver accordingly</span>
                <span class="n">num_blocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])))])</span>

                <span class="c1"># Construct sumk_to_solver taking (sumk_block, sumk_index) --&gt; (solver_block, solver_inner)</span>
                <span class="c1"># and solver_to_sumk taking (solver_block, solver_inner) --&gt;</span>
                <span class="c1"># (sumk_block, sumk_index)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">block_sumk</span> <span class="o">=</span> <span class="n">sp</span>
                        <span class="n">inner_sumk</span> <span class="o">=</span> <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">block_solv</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">inner_solv</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block_solv</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sumk</span>

            <span class="c1"># Now calculate degeneracies of orbitals</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="c1"># get dm for the blocks:</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">block</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">inner</span><span class="p">)],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">ind2</span> <span class="ow">in</span> <span class="n">inner</span><span class="p">:</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind1_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind1</span><span class="p">)]</span>
                        <span class="n">block_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span>
                            <span class="n">ish</span><span class="p">][(</span><span class="n">block</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)]</span>
                        <span class="n">dm</span><span class="p">[</span><span class="n">block</span><span class="p">][</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                            <span class="n">block_sumk</span><span class="p">][</span><span class="n">ind1_sumk</span><span class="p">,</span> <span class="n">ind2_sumk</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">block1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">block2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">dm</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">dm</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">dm</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span> <span class="o">-</span> <span class="n">dm</span><span class="p">[</span><span class="n">block2</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">())</span> <span class="ow">and</span> <span class="p">(</span><span class="n">block1</span> <span class="o">!=</span> <span class="n">block2</span><span class="p">):</span>
                            <span class="n">ind1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                            <span class="n">ind2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                            <span class="c1"># check if it was already there:</span>
                            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                                <span class="k">if</span> <span class="n">block1</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">n</span>
                                <span class="k">if</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                                    <span class="n">ind2</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="k">if</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block1</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block2</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_get_hermitian_quantity_from_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Convert G to a Hermitian quantity</span>

<span class="sd">        For G(tau) and G(iw), G(tau) is returned.</span>
<span class="sd">        For G(t) and G(w), the spectral function is returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : list of BlockGf of GfImFreq, GfImTime, GfReFreq or GfReTime</span>
<span class="sd">            the input Green&#39;s function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gf : list of BlockGf of GfImTime or GfReFreq</span>
<span class="sd">            the output G(tau) or A(w)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make a GfImTime from the supplied GfImFreq</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">_first</span><span class="p">(),</span> <span class="n">GfImFreq</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">GfImTime</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
                <span class="n">indices</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span><span class="n">n_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">g_sh</span><span class="p">],</span>
                <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">set_from_inverse_fourier</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
        <span class="c1"># keep a GfImTime from the supplied GfImTime</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">_first</span><span class="p">(),</span> <span class="n">GfImTime</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="n">G</span>
        <span class="c1"># make a spectral function from the supplied GfReFreq</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">_first</span><span class="p">(),</span> <span class="n">GfReFreq</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="p">[</span><span class="n">g_sh</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="mf">1.0j</span><span class="o">*</span><span class="p">(</span><span class="n">g</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">g_sh</span><span class="o">.</span><span class="n">_first</span><span class="p">(),</span> <span class="n">GfReTime</span><span class="p">)</span> <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">get_delta_from_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
                <span class="n">w0</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">mesh</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">w0</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">w0</span> <span class="o">=</span> <span class="n">w</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">w</span><span class="o">-</span><span class="n">w0</span>
            <span class="n">gf</span> <span class="o">=</span> <span class="p">[</span><span class="n">BlockGf</span><span class="p">(</span><span class="n">name_block_generator</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">GfReFreq</span><span class="p">(</span>
                <span class="n">window</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">get_delta_from_mesh</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)),</span> 
                <span class="n">numpy</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span><span class="o">*</span><span class="n">get_delta_from_mesh</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">))),</span>
                <span class="n">n_points</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">block</span><span class="o">.</span><span class="n">mesh</span><span class="p">),</span> <span class="n">indices</span><span class="o">=</span><span class="n">block</span><span class="o">.</span><span class="n">indices</span><span class="p">))</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">g_sh</span><span class="p">],</span> <span class="n">make_copies</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">g_sh</span> <span class="ow">in</span> <span class="n">G</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">set_from_fourier</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="mf">1.0j</span><span class="o">*</span><span class="p">(</span><span class="n">g</span><span class="o">-</span><span class="n">g</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;G must be a list of BlockGf of either GfImFreq, GfImTime, GfReFreq or GfReTime&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gf</span>



<div class="viewcode-block" id="SumkDFT.analyse_block_structure_from_gf"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.analyse_block_structure_from_gf">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_block_structure_from_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">analyse_deg_shells</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Determines the block structure of local Green&#39;s functions by analysing</span>
<span class="sd">        the structure of the corresponding non-interacting Green&#39;s function.</span>
<span class="sd">        The resulting block structures for correlated shells are</span>
<span class="sd">        stored in the :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;`</span>
<span class="sd">        attribute.</span>

<span class="sd">        This is a safer alternative to analyse_block_structure, because</span>
<span class="sd">        the full non-interacting Green&#39;s function is taken into account</span>
<span class="sd">        and not just the density matrix and Hloc.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : list of BlockGf of GfImFreq, GfImTime, GfReFreq or GfReTime</span>
<span class="sd">            the non-interacting Green&#39;s function for each inequivalent correlated shell</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between matrix elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of correlated shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all correlated shells will be analysed.</span>
<span class="sd">        analyse_deg_shells : bool</span>
<span class="sd">                             Whether to call the analyse_deg_shells function</span>
<span class="sd">                             after having finished the block structure analysis</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        G : list of BlockGf of GfImFreq or GfImTime</span>
<span class="sd">            the Green&#39;s function transformed into the new block structure</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hermitian_quantity_from_gf</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="c1"># initialize the variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="p">[{}</span>
                                     <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="c1"># the maximum value of each matrix element of each block and shell</span>
        <span class="n">max_gf</span> <span class="o">=</span> <span class="p">[{</span><span class="n">name</span><span class="p">:</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">data</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">]}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># include all shells</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>

                <span class="c1"># gives an index list of entries larger that threshold</span>
                <span class="n">maxgf_bool</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">max_gf</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span>

                <span class="c1"># Determine off-diagonal entries in upper triangular part of the</span>
                <span class="c1"># Green&#39;s function</span>
                <span class="n">offdiag</span> <span class="o">=</span> <span class="n">Set</span><span class="p">([])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_orb</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">maxgf_bool</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                            <span class="n">offdiag</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

                <span class="c1"># Determine the number of non-hybridising blocks in the gf</span>
                <span class="n">blocs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">offdiag</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pair</span> <span class="o">=</span> <span class="n">offdiag</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">blocs</span><span class="p">,</span> <span class="n">blocs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">b2</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">):</span>     <span class="c1"># In separate blocks?</span>
                                <span class="c1"># Merge two blocks</span>
                                <span class="n">b1</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">blocs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b2</span><span class="p">)))</span>
                                <span class="k">break</span>                                  <span class="c1"># Move on to next pair in offdiag</span>

                <span class="c1"># Set the gf_struct for the solver accordingly</span>
                <span class="n">num_blocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                        <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])))])</span>

                <span class="c1"># Construct sumk_to_solver taking (sumk_block, sumk_index) --&gt; (solver_block, solver_inner)</span>
                <span class="c1"># and solver_to_sumk taking (solver_block, solver_inner) --&gt;</span>
                <span class="c1"># (sumk_block, sumk_index)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_blocs</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                        <span class="n">block_sumk</span> <span class="o">=</span> <span class="n">sp</span>
                        <span class="n">inner_sumk</span> <span class="o">=</span> <span class="n">blocs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">block_solv</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                        <span class="n">inner_solv</span> <span class="o">=</span> <span class="n">j</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk</span><span class="p">[</span><span class="n">ish</span><span class="p">][(</span><span class="n">block_solv</span><span class="p">,</span> <span class="n">inner_solv</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">block_sumk</span><span class="p">,</span> <span class="n">inner_sumk</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block_solv</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_sumk</span>

        <span class="c1"># transform G to the new structure</span>
        <span class="n">full_structure</span> <span class="o">=</span> <span class="n">BlockStructure</span><span class="o">.</span><span class="n">full_structure</span><span class="p">(</span>
            <span class="p">[{</span><span class="n">sp</span><span class="p">:</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]}</span>
                <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)],</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">G_transformed</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">convert_gf</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">],</span>
                <span class="n">full_structure</span><span class="p">,</span> <span class="n">ish</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">show_warnings</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span>
                <span class="n">gf_function</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">_first</span><span class="p">()))</span>
            <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">analyse_deg_shells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">analyse_deg_shells</span><span class="p">(</span><span class="n">G_transformed</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">include_shells</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G_transformed</span></div>

<div class="viewcode-block" id="SumkDFT.analyse_deg_shells"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.analyse_deg_shells">[docs]</a>    <span class="k">def</span> <span class="nf">analyse_deg_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.e-5</span><span class="p">,</span> <span class="n">include_shells</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Determines the degenerate shells of local Green&#39;s functions by analysing</span>
<span class="sd">        the structure of the corresponding non-interacting Green&#39;s function.</span>
<span class="sd">        The results are stored in the</span>
<span class="sd">        :class:`SumkDFT.block_structure &lt;dft.block_structure.BlockStructure&gt;`</span>
<span class="sd">        attribute.</span>

<span class="sd">        Due to the implementation and numerics, the maximum difference between</span>
<span class="sd">        two matrix elements that are detected as equal can be a bit higher</span>
<span class="sd">        (e.g. a factor of two) than the actual threshold.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        G : list of BlockGf of GfImFreq or GfImTime</span>
<span class="sd">            the non-interacting Green&#39;s function for each inequivalent correlated shell</span>
<span class="sd">        threshold : real, optional</span>
<span class="sd">                    If the difference between matrix elements is below threshold,</span>
<span class="sd">                    they are considered to be equal.</span>
<span class="sd">        include_shells : list of integers, optional</span>
<span class="sd">                         List of correlated shells to be analysed.</span>
<span class="sd">                         If include_shells is not provided all correlated shells will be analysed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>

        <span class="c1"># helper function</span>
        <span class="k">def</span> <span class="nf">null</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-15</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Calculate the null-space of matrix A &quot;&quot;&quot;</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
            <span class="n">null_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">)</span>
            <span class="n">null_space</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">null_mask</span><span class="p">,</span> <span class="n">vh</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">null_space</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="n">gf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hermitian_quantity_from_gf</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">include_shells</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># include all shells</span>
            <span class="n">include_shells</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)</span>

        <span class="c1"># We consider two blocks equal, if their Green&#39;s functions obey</span>
        <span class="c1"># maybe_conjugate1( v1^dagger G1 v1 ) = maybe_conjugate2( v2^dagger G2 v2 )</span>
        <span class="c1"># where maybe_conjugate is a function that conjugates the Green&#39;s</span>
        <span class="c1"># function if the flag &#39;conjugate&#39; is set and the v are unitary</span>
        <span class="c1"># matrices</span>
        <span class="c1">#</span>
        <span class="c1"># for each pair of blocks, we check whether there is a transformation</span>
        <span class="c1"># maybe_conjugate( T G1 T^dagger ) = G2</span>
        <span class="c1"># where our goal is to find T</span>
        <span class="c1"># we just try whether there is such a T with and without conjugation</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="n">include_shells</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">block1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">block2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">block1</span><span class="o">==</span><span class="n">block2</span><span class="p">:</span> <span class="k">continue</span>

                    <span class="c1"># check if the blocks are already present in the deg_shells</span>
                    <span class="n">ind1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">ind2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">block1</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                            <span class="n">ind1</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="n">v1</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">block2</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">:</span>
                            <span class="n">ind2</span> <span class="o">=</span> <span class="n">n</span>
                            <span class="n">v2</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span>

                    <span class="c1"># if both are already present, go to the next pair of blocks</span>
                    <span class="k">if</span> <span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">gf1</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block1</span><span class="p">]</span>
                    <span class="n">gf2</span> <span class="o">=</span> <span class="n">gf</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block2</span><span class="p">]</span>

                    <span class="c1"># the two blocks have to have the same shape</span>
                    <span class="k">if</span> <span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span> <span class="o">!=</span> <span class="n">gf2</span><span class="o">.</span><span class="n">target_shape</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="c1"># Instead of directly comparing the two blocks, we</span>
                    <span class="c1"># compare its eigenvalues. As G(tau) is Hermitian,</span>
                    <span class="c1"># they are real and the eigenvector matrix is unitary.</span>
                    <span class="c1"># Thus, if the eigenvalues are equal we can transform</span>
                    <span class="c1"># one block to make it equal to the other (at least</span>
                    <span class="c1"># for tau=0).</span>

                    <span class="n">e1</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">e2</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigvalsh</span><span class="p">(</span><span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">e1</span><span class="o">-</span><span class="n">e2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">):</span> <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">conjugate</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">False</span><span class="p">,</span><span class="bp">True</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                            <span class="n">gf2</span> <span class="o">=</span> <span class="n">gf2</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>

                        <span class="c1"># we want T gf1 T^dagger = gf2</span>
                        <span class="c1"># while for a given tau, T could be calculated</span>
                        <span class="c1"># by diagonalizing gf1 and gf2, this does not</span>
                        <span class="c1"># work for all taus simultaneously because of</span>
                        <span class="c1"># numerical imprecisions</span>

                        <span class="c1"># rather, we rewrite the equation to</span>
                        <span class="c1"># T gf1 = gf2 T</span>
                        <span class="c1"># which is the Sylvester equation.</span>
                        <span class="c1"># For that equation, one can use the Kronecker</span>
                        <span class="c1"># product to get a linear problem, which consists</span>
                        <span class="c1"># of finding the null space of M vec T = 0.</span>

                        <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">),</span><span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">))</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="n">null</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>

                        <span class="c1"># now we get the intersection of the null spaces</span>
                        <span class="c1"># of all values of tau</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
                            <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">),</span><span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span><span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">))</span>
                            <span class="c1"># transform M into current null space</span>
                            <span class="n">M</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
                            <span class="n">N</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">null</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="k">break</span>

                        <span class="c1"># no intersection of the null spaces -&gt; no symmetry</span>
                        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>

                        <span class="c1"># reshape N: it then has the indices matrix, matrix, number of basis vectors of the null space</span>
                        <span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>

                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        any matrix in the null space can now be constructed as</span>
<span class="sd">                        M = 0</span>
<span class="sd">                        for i in range(N.shape[-1]):</span>
<span class="sd">                            M += y[i]*N[:,:,i]</span>
<span class="sd">                        with coefficients (complex numbers) y[i].</span>

<span class="sd">                        We want to get a set of coefficients y so that M is unitary.</span>
<span class="sd">                        Unitary means M M^dagger = 1.</span>
<span class="sd">                        Thus,</span>
<span class="sd">                            sum  y[i] N[:,:,i] y[j].conjugate() N[:,:,j].conjugate().transpose() = eye.</span>
<span class="sd">                        The object N[:,:,i] N[:,:,j] is a four-index object which we call Z.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="n">Z</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;aci,bcj-&gt;abij&#39;</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>

                        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        function chi2</span>
<span class="sd">                        This function takes a real parameter vector y and reinterprets it as complex.</span>
<span class="sd">                        Then, it calculates the chi2 of</span>
<span class="sd">                            sum  y[i] N[:,:,i] y[j].conjugate() N[:,:,j].conjugate().transpose() - eye.</span>
<span class="sd">                        &quot;&quot;&quot;</span>
                        <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
                            <span class="c1"># reinterpret y as complex number</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                            <span class="n">ret</span> <span class="o">=</span> <span class="mf">0.0</span>
                            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                                    <span class="n">ret</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">y</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()))</span>
                                                  <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
                            <span class="k">return</span> <span class="n">ret</span>

                        <span class="c1"># use the minimization routine from scipy</span>
                        <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">chi2</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

                        <span class="c1"># if the minimization fails, there is probably no symmetry</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span> <span class="k">continue</span>
                        <span class="c1"># check if the minimization returned zero within the tolerance</span>
                        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">fun</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span> <span class="k">continue</span>

                        <span class="c1"># reinterpret the solution as a complex number</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>

                        <span class="c1"># reconstruct the T matrix</span>
                        <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
                            <span class="n">T</span> <span class="o">+=</span> <span class="n">N</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="c1"># transform gf1 using T</span>
                        <span class="n">G_transformed</span> <span class="o">=</span> <span class="n">gf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">G_transformed</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">gf1</span><span class="p">,</span> <span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>

                        <span class="c1"># it does not make sense to check the tails for an</span>
                        <span class="c1"># absolute error because it will usually not hold;</span>
                        <span class="c1"># we could just check the relative error</span>
                        <span class="c1"># (here, we ignore it, reasoning that if the data</span>
                        <span class="c1"># is the same, the tails have to coincide as well)</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">assert_arrays_are_close</span><span class="p">(</span><span class="n">G_transformed</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">gf2</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">threshold</span><span class="p">)</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">RuntimeError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
                            <span class="c1"># the symmetry does not hold</span>
                            <span class="k">continue</span>

                        <span class="c1"># Now that we have found a valid T, we have to</span>
                        <span class="c1"># rewrite it to match the convention that</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2),</span>
                        <span class="c1"># where C conjugates if the flag is True</span>

                        <span class="c1"># For each group of degenerate shells, the list</span>
                        <span class="c1"># SK.deg_shells[ish] contains a dict. The keys</span>
                        <span class="c1"># of the dict are the block names, the values</span>
                        <span class="c1"># are tuples. The first entry of the tuple is</span>
                        <span class="c1"># the transformation matrix v, the second entry</span>
                        <span class="c1"># is the conjugation flag</span>

                        <span class="c1"># the second block is already present</span>
                        <span class="c1"># set v1 and C1 so that they are compatible with</span>
                        <span class="c1"># C(T gf1 T^dagger) = gf2</span>
                        <span class="c1"># and with</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">][</span><span class="n">block1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()),</span> <span class="ow">not</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind2</span><span class="p">][</span><span class="n">block1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">v2</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">v2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># the first block is already present</span>
                        <span class="c1"># set v2 and C2 so that they are compatible with</span>
                        <span class="c1"># C(T gf1 T^dagger) = gf2</span>
                        <span class="c1"># and with</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2)</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">][</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()),</span> <span class="ow">not</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">ind1</span><span class="p">][</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">v1</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">v1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="c1"># the blocks are not already present</span>
                        <span class="c1"># we arbitrarily choose v1=eye and C1=False and</span>
                        <span class="c1"># set v2 and C2 so that they are compatible with</span>
                        <span class="c1"># C(T gf1 T^dagger) = gf2</span>
                        <span class="c1"># and with</span>
                        <span class="c1"># C1(v1^dagger G1 v1) = C2(v2^dagger G2 v2)</span>
                        <span class="k">elif</span> <span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ind2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                            <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
                            <span class="n">d</span><span class="p">[</span><span class="n">block1</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">gf1</span><span class="o">.</span><span class="n">target_shape</span><span class="p">),</span> <span class="bp">False</span>
                            <span class="k">if</span> <span class="n">conjugate</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(),</span> <span class="bp">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">d</span><span class="p">[</span><span class="n">block2</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="p">,</span> <span class="bp">False</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

                        <span class="c1"># a block was found, break out of the loop</span>
                        <span class="k">break</span></div>


<div class="viewcode-block" id="SumkDFT.density_matrix"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;using_gf&#39;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">40.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate density matrices in one of two ways.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : string, optional</span>

<span class="sd">                 - if &#39;using_gf&#39;: First get lattice gf (g_loc is not set up), then density matrix.</span>
<span class="sd">                                  It is useful for Hubbard I, and very quick.</span>
<span class="sd">                                  No assumption on the hopping structure is made (ie diagonal or not).</span>
<span class="sd">                 - if &#39;using_point_integration&#39;: Only works for diagonal hopping matrix (true in wien2k).</span>

<span class="sd">        beta : float, optional</span>
<span class="sd">               Inverse temperature.      </span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens_mat : list of dicts</span>
<span class="sd">                   Density matrix for each spin in each correlated shell.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                    <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;using_gf&quot;</span><span class="p">:</span>

                <span class="n">G_latt_iw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                    <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;iw&quot;</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">)</span>
                <span class="n">G_latt_iw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>
                <span class="n">dm</span> <span class="o">=</span> <span class="n">G_latt_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
                <span class="n">MMat</span> <span class="o">=</span> <span class="p">[</span><span class="n">dm</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]]</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;using_point_integration&quot;</span><span class="p">:</span>

                <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
                <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
                <span class="n">MMat</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dims</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">spn</span><span class="p">):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]):</span>
                        <span class="c1"># only works for diagonal hopping matrix (true in</span>
                        <span class="c1"># wien2k)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">isp</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                            <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">inu</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;density_matrix: the method &#39;</span><span class="si">%s</span><span class="s2">&#39; is not supported.&quot;</span> <span class="o">%</span> <span class="n">method</span>

            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                    <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
                    <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;using_gf&quot;</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">]),</span>
                                                         <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>
                    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;using_point_integration&quot;</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">[</span><span class="n">isp</span><span class="p">]),</span>
                                                                               <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span>

        <span class="c1"># get data from nodes:</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">)</span>

        <span class="c1"># Rotate to local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]),</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>

    <span class="c1"># For simple dft input, get crystal field splittings.</span>
<div class="viewcode-block" id="SumkDFT.eff_atomic_levels"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.eff_atomic_levels">[docs]</a>    <span class="k">def</span> <span class="nf">eff_atomic_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the effective local Hamiltonian required as an input for</span>
<span class="sd">        the Hubbard I Solver.</span>
<span class="sd">        The local Hamiltonian (effective atomic levels) is calculated by</span>
<span class="sd">        projecting the on-site Bloch Hamiltonian:</span>

<span class="sd">        .. math:: H^{loc}_{m m&#39;} = \sum_{k} P_{m \nu}(k) H_{\nu\nu&#39;}(k) P^{*}_{\nu&#39; m&#39;}(k),</span>

<span class="sd">        where</span>

<span class="sd">        .. math:: H_{\nu\nu&#39;}(k) = [\epsilon_{\nu k} - h_{z} \sigma_{z}] \delta_{\nu\nu&#39;}.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        eff_atlevels : gf_struct_sumk like</span>
<span class="sd">                       Effective local Hamiltonian :math:`H^{loc}_{m m&#39;}` for each</span>
<span class="sd">                       inequivalent correlated shell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># define matrices for inequivalent shells:</span>
        <span class="n">eff_atlevels</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                    <span class="n">sp</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>

        <span class="c1"># sum over k:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Hsumk&quot;</span><span class="p">):</span>
            <span class="c1"># calculate the sum over k. Does not depend on mu, so do it only</span>
            <span class="c1"># once:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]):</span>
                    <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">]</span>
                        <span class="n">MMat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">n_orb</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                        <span class="n">MMat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span>
                            <span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">isp</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_field</span> <span class="o">*</span> <span class="n">MMat</span>
                        <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">MMat</span><span class="p">),</span>
                                                                                 <span class="n">projmat</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
            <span class="c1"># symmetrisation:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">)</span>

            <span class="c1"># Rotate to local coordinate system:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span>
                                <span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]),</span>
                                                          <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="c1"># add to matrix:</span>
        <span class="k">for</span> <span class="n">ish</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_inequiv_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">]:</span>
                <span class="n">eff_atlevels</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span>
                    <span class="n">sp</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hsumk</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">inequiv_to_corr</span><span class="p">[</span><span class="n">ish</span><span class="p">]][</span><span class="n">sp</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">eff_atlevels</span></div>

<div class="viewcode-block" id="SumkDFT.init_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.init_dc">[docs]</a>    <span class="k">def</span> <span class="nf">init_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Initializes the double counting terms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span> <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span></div>

<div class="viewcode-block" id="SumkDFT.set_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.set_dc">[docs]</a>    <span class="k">def</span> <span class="nf">set_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dc_imp</span><span class="p">,</span> <span class="n">dc_energ</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Sets double counting corrections to given values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dc_imp : gf_struct_sumk like</span>
<span class="sd">                 Double-counting self-energy term.</span>
<span class="sd">        dc_energ : list of floats</span>
<span class="sd">                   Double-counting energy corrections for each correlated shell. </span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span> <span class="o">=</span> <span class="n">dc_imp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span> <span class="o">=</span> <span class="n">dc_energ</span></div>

<div class="viewcode-block" id="SumkDFT.calc_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_dc">[docs]</a>    <span class="k">def</span> <span class="nf">calc_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">U_interact</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">J_hund</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">use_dc_formula</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates and sets the double counting corrections.</span>

<span class="sd">        If &#39;use_dc_value&#39; is provided the double-counting term is uniformly initialized</span>
<span class="sd">        with this constant and &#39;U_interact&#39; and &#39;J_hund&#39; are ignored.</span>

<span class="sd">        If &#39;use_dc_value&#39; is None the correction is evaluated according to </span>
<span class="sd">        one of the following formulae:</span>

<span class="sd">        * use_dc_formula = 0: fully-localised limit (FLL)</span>
<span class="sd">        * use_dc_formula = 1: Held&#39;s formula, i.e. mean-field formula for the Kanamori</span>
<span class="sd">                              type of the interaction Hamiltonian</span>
<span class="sd">        * use_dc_formula = 2: around mean-field (AMF)</span>

<span class="sd">        Note that FLL and AMF formulae were derived assuming a full Slater-type interaction</span>
<span class="sd">        term and should be thus used accordingly. For the Kanamori-type interaction</span>
<span class="sd">        one should use formula 1.</span>

<span class="sd">        The double-counting self-energy term is stored in `self.dc_imp` and the energy</span>
<span class="sd">        correction in `self.dc_energ`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dens_mat : gf_struct_solver like</span>
<span class="sd">                   Density matrix for the specified correlated shell.</span>
<span class="sd">        orb : int, optional</span>
<span class="sd">              Index of an inequivalent shell.</span>
<span class="sd">        U_interact : float, optional</span>
<span class="sd">                     Value of interaction parameter `U`.</span>
<span class="sd">        J_hund : float, optional</span>
<span class="sd">                 Value of interaction parameter `J`.</span>
<span class="sd">        use_dc_formula : int, optional</span>
<span class="sd">                         Type of double-counting correction (see description).</span>
<span class="sd">        use_dc_value : float, optional</span>
<span class="sd">                       Value of the double-counting correction. If specified</span>
<span class="sd">                       `U_interact`, `J_hund` and `use_dc_formula` are ignored.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>

            <span class="c1"># ish is the index of the inequivalent shell corresponding to icrsh</span>
            <span class="n">ish</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_to_inequiv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ish</span> <span class="o">!=</span> <span class="n">orb</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># ignore this orbital</span>
            <span class="c1"># *(1+self.corr_shells[icrsh][&#39;SO&#39;])</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;SO&#39;</span><span class="p">]]</span>

            <span class="n">Ncr</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
            <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="n">ish</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">bl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver_to_sumk_block</span><span class="p">[</span><span class="n">ish</span><span class="p">][</span><span class="n">block</span><span class="p">]</span>
                <span class="n">Ncr</span><span class="p">[</span><span class="n">bl</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">block</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span>
            <span class="n">Ncrtot</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Ncr</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># average the densities if there is no SP:</span>
                    <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncrtot</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">spn</span><span class="p">)</span>
                <span class="c1"># correction for SO: we have only one block in this case, but</span>
                <span class="c1"># in DC we need N/2</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="n">Ncrtot</span> <span class="o">/</span> <span class="mf">2.0</span>

            <span class="k">if</span> <span class="n">use_dc_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">U_interact</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">J_hund</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s2">&quot;set_dc: either provide U_interact and J_hund or set use_dc_value to dc value.&quot;</span>

                <span class="k">if</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># FLL</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">U_interact</span> <span class="o">/</span> \
                        <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Ncrtot</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                        <span class="n">Uav</span> <span class="o">=</span> <span class="n">U_interact</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="n">J_hund</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Uav</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">-=</span> <span class="n">J_hund</span> <span class="o">/</span> \
                            <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s2">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s2"> and block </span><span class="si">%(sp)s</span><span class="s2"> = </span><span class="si">%(Uav)f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>

                <span class="k">elif</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Held&#39;s formula, with U_interact the interorbital onsite interaction</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span>
                        <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Ncrtot</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                        <span class="n">Uav</span> <span class="o">=</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                               <span class="o">*</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">-</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Uav</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s2">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s2"> and block </span><span class="si">%(sp)s</span><span class="s2"> = </span><span class="si">%(Uav)f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>

                <span class="k">elif</span> <span class="n">use_dc_formula</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># AMF</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">U_interact</span> <span class="o">*</span> <span class="n">Ncrtot</span> <span class="o">*</span> <span class="n">Ncrtot</span>
                    <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                        <span class="n">Uav</span> <span class="o">=</span> <span class="n">U_interact</span> <span class="o">*</span> \
                            <span class="p">(</span><span class="n">Ncrtot</span> <span class="o">-</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">)</span> <span class="o">-</span> \
                            <span class="n">J_hund</span> <span class="o">*</span> <span class="p">(</span><span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">-</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">/</span> <span class="n">dim</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">Uav</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span>
                            <span class="n">icrsh</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">U_interact</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">J_hund</span><span class="p">)</span> <span class="o">/</span> <span class="n">dim</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">*</span> <span class="n">Ncr</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span>
                        <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                            <span class="s2">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s2"> and block </span><span class="si">%(sp)s</span><span class="s2"> = </span><span class="si">%(Uav)f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>

                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;DC energy for shell </span><span class="si">%s</span><span class="s2"> = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="n">icrsh</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]))</span>

            <span class="k">else</span><span class="p">:</span>  <span class="c1"># use value provided for user to determine dc_energ and dc_imp</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">use_dc_value</span> <span class="o">*</span> <span class="n">Ncrtot</span>
                <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">sp</span><span class="p">]</span> <span class="o">*=</span> <span class="n">use_dc_value</span>

                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span>
                    <span class="s2">&quot;DC for shell </span><span class="si">%(icrsh)i</span><span class="s2"> = </span><span class="si">%(use_dc_value)f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">locals</span><span class="p">())</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;DC energy = </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span></div>

<div class="viewcode-block" id="SumkDFT.add_dc"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.add_dc">[docs]</a>    <span class="k">def</span> <span class="nf">add_dc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;iw&quot;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Subtracts the double counting term from the impurity self energy.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iw_or_w : string, optional</span>

<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sigma_minus_dc : gf_struct_sumk like</span>
<span class="sd">                         Self-energy with a subtracted double-counting term.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Be careful: Sigma_imp is already in the global coordinate system!!</span>
        <span class="n">sigma_minus_dc</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                          <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;Sigma_imp_&quot;</span> <span class="o">+</span> <span class="n">iw_or_w</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]:</span>
                <span class="c1"># Transform dc_imp to global coordinate system</span>
                <span class="n">dccont</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span>
                                   <span class="n">bname</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()))</span>
                <span class="n">sigma_minus_dc</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="n">bname</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dccont</span>

        <span class="k">return</span> <span class="n">sigma_minus_dc</span></div>

<div class="viewcode-block" id="SumkDFT.symm_deg_gf"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.symm_deg_gf">[docs]</a>    <span class="k">def</span> <span class="nf">symm_deg_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gf_to_symm</span><span class="p">,</span> <span class="n">orb</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Averages a GF over degenerate shells.</span>

<span class="sd">        Degenerate shells of an inequivalent correlated shell are defined by</span>
<span class="sd">        `self.deg_shells`. This function enforces corresponding degeneracies</span>
<span class="sd">        in the input GF.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gf_to_symm : gf_struct_solver like</span>
<span class="sd">                     Input and output GF (i.e., it gets overwritten)</span>
<span class="sd">        orb : int</span>
<span class="sd">              Index of an inequivalent shell.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># when reading block_structures written with older versions from</span>
        <span class="c1"># an h5 file, self.deg_shells might be None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span> <span class="k">return</span>

        <span class="k">for</span> <span class="n">degsh</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">deg_shells</span><span class="p">[</span><span class="n">orb</span><span class="p">]:</span>
            <span class="c1"># ss will hold the averaged orbitals in the basis where the</span>
            <span class="c1"># blocks are all equal</span>
            <span class="c1"># i.e. maybe_conjugate(v^dagger gf v)</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">n_deg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">degsh</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">degsh</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ss</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">ss</span> <span class="o">=</span> <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">ss</span><span class="o">.</span><span class="n">zero</span><span class="p">()</span>
                    <span class="n">helper</span> <span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># get the transformation matrix</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degsh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">degsh</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># for backward compatibility, allow degsh to be a list</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">target_shape</span><span class="p">)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="c1"># the helper is in the basis where the blocks are all equal</span>
                <span class="n">helper</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">helper</span> <span class="o">&lt;&lt;</span> <span class="n">helper</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
                <span class="c1"># average over all shells</span>
                <span class="n">ss</span> <span class="o">+=</span> <span class="n">helper</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">n_deg</span><span class="p">)</span>
            <span class="c1"># now put back the averaged gf to all shells</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">degsh</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">degsh</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">degsh</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># for backward compatibility, allow degsh to be a list</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="o">*</span><span class="n">ss</span><span class="o">.</span><span class="n">target_shape</span><span class="p">)</span>
                    <span class="n">C</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">if</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">gf_to_symm</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">from_L_G_R</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span></div>

<div class="viewcode-block" id="SumkDFT.total_density"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.total_density">[docs]</a>    <span class="k">def</span> <span class="nf">total_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;iw&quot;</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the total charge within the energy window for a given chemical potential. </span>
<span class="sd">        The chemical potential is either given by parameter `mu` or, if it is not specified,</span>
<span class="sd">        taken from `self.chemical_potential`.</span>

<span class="sd">        The total charge is calculated from the trace of the GF in the Bloch basis.</span>
<span class="sd">        By default, a full interacting GF is used. To use the non-interacting GF, set</span>
<span class="sd">        parameter `with_Sigma = False`.</span>

<span class="sd">        The number of bands within the energy windows generally depends on `k`. The trace is</span>
<span class="sd">        therefore calculated separately for each `k`-point.</span>

<span class="sd">        Since in general n_orbitals depends on k, the calculation is done in the following order:</span>

<span class="sd">        .. math:: n_{tot} = \sum_{k} n(k),</span>

<span class="sd">        with</span>

<span class="sd">        .. math:: n(k) = Tr G_{\nu\nu&#39;}(k, i\omega_{n}). </span>

<span class="sd">        The calculation is done in the global coordinate system, if distinction is made between local/global.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">             Input chemical potential. If not specified, `self.chemical_potential` is used instead.</span>
<span class="sd">        iw_or_w : string, optional</span>
<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>
<span class="sd">        with_Sigma : boolean, optional</span>
<span class="sd">             If `True` the full interacing GF is evaluated, otherwise the self-energy is not</span>
<span class="sd">             included and the charge would correspond to a non-interacting system.</span>
<span class="sd">        with_dc : boolean, optional</span>
<span class="sd">             Whether or not to subtract the double-counting term from the self-energy.</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dens : float</span>
<span class="sd">               Total charge :math:`n_{tot}`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">G_latt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">with_Sigma</span><span class="o">=</span><span class="n">with_Sigma</span><span class="p">,</span> <span class="n">with_dc</span><span class="o">=</span><span class="n">with_dc</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
            <span class="n">dens</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">G_latt</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>
        <span class="c1"># collect data from mpi:</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">dens</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">dens</span></div>

<div class="viewcode-block" id="SumkDFT.set_mu"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.set_mu">[docs]</a>    <span class="k">def</span> <span class="nf">set_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Sets a new chemical potential.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu : float</span>
<span class="sd">             New value of the chemical potential.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">mu</span></div>

<div class="viewcode-block" id="SumkDFT.calc_mu"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_mu">[docs]</a>    <span class="k">def</span> <span class="nf">calc_mu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s1">&#39;iw&#39;</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Searches for the chemical potential that gives the DFT total charge.</span>
<span class="sd">        A simple bisection method is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : float, optional</span>
<span class="sd">                    A desired precision of the resulting total charge.</span>
<span class="sd">        iw_or_w : string, optional</span>
<span class="sd">                  - `iw_or_w` = &#39;iw&#39; for a imaginary-frequency self-energy</span>
<span class="sd">                  - `iw_or_w` = &#39;w&#39; for a real-frequency self-energy</span>
<span class="sd">        broadening : float, optional</span>
<span class="sd">                     Imaginary shift for the axis along which the real-axis GF is calculated.</span>
<span class="sd">                     If not provided, broadening will be set to double of the distance between mesh points in &#39;mesh&#39;.</span>
<span class="sd">                     Only relevant for real-frequency GF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu : float</span>
<span class="sd">             Value of the chemical potential giving the DFT total charge</span>
<span class="sd">             within specified precision.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">mu</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span>
            <span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="n">iw_or_w</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span>
        <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_required</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_below</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">dichotomy</span><span class="o">.</span><span class="n">dichotomy</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">F</span><span class="p">,</span>
                                                      <span class="n">x_init</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">y_value</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
                                                      <span class="n">precision_on_y</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">delta_x</span><span class="o">=</span><span class="n">delta</span><span class="p">,</span> <span class="n">max_loops</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                                                      <span class="n">x_name</span><span class="o">=</span><span class="s2">&quot;Chemical Potential&quot;</span><span class="p">,</span> <span class="n">y_name</span><span class="o">=</span><span class="s2">&quot;Total Density&quot;</span><span class="p">,</span>
                                                      <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span></div>

<div class="viewcode-block" id="SumkDFT.calc_density_correction"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_density_correction">[docs]</a>    <span class="k">def</span> <span class="nf">calc_density_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dm_type</span><span class="o">=</span><span class="s1">&#39;wien2k&#39;</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Calculates the charge density correction and stores it into a file.</span>

<span class="sd">        The charge density correction is needed for charge-self-consistent DFT+DMFT calculations.</span>
<span class="sd">        It represents a density matrix of the interacting system defined in Bloch basis</span>
<span class="sd">        and it is calculated from the sum over Matsubara frequecies of the full GF,</span>

<span class="sd">        ..math:: N_{\nu\nu&#39;}(k) = \sum_{i\omega_{n}} G_{\nu\nu&#39;}(k, i\omega_{n})</span>

<span class="sd">        The density matrix for every `k`-point is stored into a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : string</span>
<span class="sd">                   Name of the file to store the charge density correction.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (deltaN, dens) : tuple</span>
<span class="sd">                         Returns a tuple containing the density matrix `deltaN` and</span>
<span class="sd">                         the corresponing total charge `dens`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">dm_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;vasp&#39;</span><span class="p">,</span> <span class="s1">&#39;wien2k&#39;</span><span class="p">),</span> <span class="s2">&quot;&#39;dm_type&#39; must be either &#39;vasp&#39; or &#39;wienk&#39;&quot;</span>

        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;wien2k&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;dens_mat.dat&#39;</span>
            <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;GAMMA&#39;</span>

        <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="o">==</span> <span class="n">StringType</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;calc_density_correction: &quot;</span>
                                              <span class="s2">&quot;filename has to be a string!&quot;</span><span class="p">)</span>

        <span class="n">ntoi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_names_to_ind</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">spn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spin_block_names</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">SO</span><span class="p">]</span>
        <span class="n">dens</span> <span class="o">=</span> <span class="p">{</span><span class="n">sp</span><span class="p">:</span> <span class="mf">0.0</span> <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">}</span>
        <span class="n">band_en_correction</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1"># Fetch Fermi weights and energy window band indices</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="n">fermi_weights</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">band_window</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="n">ar</span> <span class="o">=</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hdf_file</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
                <span class="n">fermi_weights</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">][</span><span class="s1">&#39;dft_fermi_weights&#39;</span><span class="p">]</span>
                <span class="n">band_window</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dft_misc_input&#39;</span><span class="p">][</span><span class="s1">&#39;band_window&#39;</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">ar</span>
            <span class="n">fermi_weights</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">fermi_weights</span><span class="p">)</span>
            <span class="n">band_window</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">band_window</span><span class="p">)</span>

<span class="c1"># Convert Fermi weights to a density matrix</span>
            <span class="n">dens_mat_dft</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
                <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fermi_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">],</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)]</span>


        <span class="c1"># Set up deltaN:</span>
        <span class="n">deltaN</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sp</span> <span class="ow">in</span> <span class="n">spn</span><span class="p">:</span>
            <span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span>
                                      <span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">sp</span><span class="p">]]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span> <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">)]</span>

        <span class="n">ikarray</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="n">mpi</span><span class="o">.</span><span class="n">slice_array</span><span class="p">(</span><span class="n">ikarray</span><span class="p">):</span>
            <span class="n">G_latt_iw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice_gf</span><span class="p">(</span>
                <span class="n">ik</span><span class="o">=</span><span class="n">ik</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">,</span> <span class="n">iw_or_w</span><span class="o">=</span><span class="s2">&quot;iw&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bname</span><span class="p">,</span> <span class="n">gf</span> <span class="ow">in</span> <span class="n">G_latt_iw</span><span class="p">:</span>
                <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">G_latt_iw</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>

                <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">G_latt_iw</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
<span class="c1"># In &#39;vasp&#39;-mode subtract the DFT density matrix</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]]</span>
                    <span class="n">diag_inds</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
                    <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">diag_inds</span><span class="p">]</span> <span class="o">-=</span> <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">][:</span><span class="n">nb</span><span class="p">]</span>
                    <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">*</span> <span class="n">dens_mat_dft</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">.</span><span class="n">real</span>
                    <span class="n">isp</span> <span class="o">=</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span>
                    <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="n">isp</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">nb</span> <span class="o">=</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">assert</span> <span class="n">nb</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">ntoi</span><span class="p">[</span><span class="n">bname</span><span class="p">]],</span> <span class="s2">&quot;Number of bands is inconsistent at ik = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ik</span><span class="p">)</span>
                    <span class="n">band_en_correction</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">hopping</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">,</span> <span class="p">:</span><span class="n">nb</span><span class="p">,</span> <span class="p">:</span><span class="n">nb</span><span class="p">])</span><span class="o">.</span><span class="n">trace</span><span class="p">()</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="c1"># mpi reduce:</span>
        <span class="k">for</span> <span class="n">bname</span> <span class="ow">in</span> <span class="n">deltaN</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                    <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">bname</span><span class="p">][</span><span class="n">ik</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">dens</span><span class="p">[</span><span class="n">bname</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">mpi</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="n">band_en_correction</span> <span class="o">=</span> <span class="n">mpi</span><span class="o">.</span><span class="n">all_reduce</span><span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">world</span><span class="p">,</span> <span class="n">band_en_correction</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="p">:</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># now save to file:</span>
        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;wien2k&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                    <span class="n">f1</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s1">&#39;dn&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="c1"># write chemical potential (in Rydberg):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="c1"># write beta in rydberg-1</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">G_latt_iw</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">f1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">G_latt_iw</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy_unit</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># no spin-polarization</span>

                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                                <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                         <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                         <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># with spin-polarization</span>

                    <span class="c1"># dict of filename: (spin index, block_name)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">to_write</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;up&#39;</span><span class="p">),</span> <span class="n">f1</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;down&#39;</span><span class="p">)}</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">SO</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">to_write</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ud&#39;</span><span class="p">),</span> <span class="n">f1</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;ud&#39;</span><span class="p">)}</span>
                    <span class="k">for</span> <span class="n">fout</span> <span class="ow">in</span> <span class="n">to_write</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">():</span>
                        <span class="n">isp</span><span class="p">,</span> <span class="n">sp</span> <span class="o">=</span> <span class="n">to_write</span><span class="p">[</span><span class="n">fout</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">])</span>
                            <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]):</span>
                                <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="n">isp</span><span class="p">]):</span>
                                    <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2"> &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span>
                                               <span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">deltaN</span><span class="p">[</span><span class="n">sp</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
                                <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="n">fout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="n">fout</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">SP</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Spin-polarized density matrix is not implemented&quot;</span>

            <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%i</span><span class="s2">  -1  ! Number of k-points, default number of bands</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
                        <span class="n">ib1</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">ib2</span> <span class="o">=</span> <span class="n">band_window</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ik</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%i</span><span class="s2">  </span><span class="si">%i</span><span class="s2">  </span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ib1</span><span class="p">,</span> <span class="n">ib2</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">inu</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                            <span class="k">for</span> <span class="n">imu</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
                                <span class="n">valre</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">valim</span> <span class="o">=</span> <span class="p">(</span><span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span> <span class="o">+</span> <span class="n">deltaN</span><span class="p">[</span><span class="s1">&#39;down&#39;</span><span class="p">][</span><span class="n">ik</span><span class="p">][</span><span class="n">inu</span><span class="p">,</span> <span class="n">imu</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
                                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">%.14f</span><span class="s2">  </span><span class="si">%.14f</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">valre</span><span class="p">,</span> <span class="n">valim</span><span class="p">))</span>
                            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Unknown density matrix type: &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">dm_type</span><span class="p">))</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">deltaN</span><span class="p">,</span> <span class="n">dens</span>

        <span class="k">if</span> <span class="n">dm_type</span> <span class="o">==</span> <span class="s1">&#39;vasp&#39;</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="p">(</span><span class="n">band_en_correction</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">res</span></div>


<span class="c1">################</span>
<span class="c1"># FIXME LEAVE UNDOCUMENTED</span>
<span class="c1">################</span>

<div class="viewcode-block" id="SumkDFT.calc_dc_for_density"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.calc_dc_for_density">[docs]</a>    <span class="k">def</span> <span class="nf">calc_dc_for_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orb</span><span class="p">,</span> <span class="n">dc_init</span><span class="p">,</span> <span class="n">dens_mat</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Searches for DC in order to fulfill charge neutrality.</span>
<span class="sd">           If density is given, then DC is set such that the LOCAL charge of orbital</span>
<span class="sd">           orb coincides with the given density.&quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">F</span><span class="p">(</span><span class="n">dc</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dens_mat</span><span class="o">=</span><span class="n">dens_mat</span><span class="p">,</span> <span class="n">U_interact</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                         <span class="n">J_hund</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">orb</span><span class="o">=</span><span class="n">orb</span><span class="p">,</span> <span class="n">use_dc_value</span><span class="o">=</span><span class="n">dc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dens_req</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_density</span><span class="p">(</span><span class="n">mu</span><span class="o">=</span><span class="n">mu</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_G_loc</span><span class="p">()[</span><span class="n">orb</span><span class="p">]</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">density</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">density</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">density_required</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">charge_below</span>

        <span class="n">dc</span> <span class="o">=</span> <span class="n">dichotomy</span><span class="o">.</span><span class="n">dichotomy</span><span class="p">(</span><span class="n">function</span><span class="o">=</span><span class="n">F</span><span class="p">,</span>
                                 <span class="n">x_init</span><span class="o">=</span><span class="n">dc_init</span><span class="p">,</span> <span class="n">y_value</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
                                 <span class="n">precision_on_y</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">delta_x</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                                 <span class="n">max_loops</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">x_name</span><span class="o">=</span><span class="s2">&quot;Double Counting&quot;</span><span class="p">,</span> <span class="n">y_name</span><span class="o">=</span><span class="s2">&quot;Total Density&quot;</span><span class="p">,</span>
                                 <span class="n">verbosity</span><span class="o">=</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dc</span></div>

<div class="viewcode-block" id="SumkDFT.check_projectors"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.check_projectors">[docs]</a>    <span class="k">def</span> <span class="nf">check_projectors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculated the density matrix from projectors (DM = P Pdagger) to check that it is correct and </span>
<span class="sd">           specifically that it matches DFT.&quot;&quot;&quot;</span>
        <span class="n">dens_mat</span> <span class="o">=</span> <span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]],</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex_</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
                <span class="n">n_orb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orbitals</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">projmat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_mat</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">icrsh</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">dim</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">n_orb</span><span class="p">]</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">][</span>
                    <span class="p">:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">projmat</span><span class="p">,</span> <span class="n">projmat</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">conjugate</span><span class="p">())</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">bz_weights</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symm_op</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmcorr</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">dens_mat</span><span class="p">)</span>

        <span class="c1"># Rotate to local coordinate system:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_rotations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">icrsh</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_corr_shells</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat_time_inv</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
                <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(),</span> <span class="n">dens_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">]),</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">rot_mat</span><span class="p">[</span><span class="n">icrsh</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">dens_mat</span></div>

<div class="viewcode-block" id="SumkDFT.sorts_of_atoms"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.sorts_of_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">sorts_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shells</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the number of inequivalent sorts.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sortlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;sort&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))]</span>
        <span class="n">n_sorts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sortlst</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_sorts</span></div>

<div class="viewcode-block" id="SumkDFT.number_of_atoms"><a class="viewcode-back" href="../../reference/sumk_dft.html#triqs_dft_tools.sumk_dft.SumkDFT.number_of_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">number_of_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shells</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the number of inequivalent atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atomlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;atom&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">))]</span>
        <span class="n">n_atoms</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atomlst</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">n_atoms</span></div>

    <span class="c1"># The following methods are here to ensure backward-compatibility</span>
    <span class="c1"># after introducing the block_structure class</span>
    <span class="k">def</span> <span class="nf">__get_gf_struct_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk</span>
    <span class="k">def</span> <span class="nf">__set_gf_struct_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">gf_struct_sumk</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_gf_struct_sumk</span><span class="p">,</span><span class="n">__set_gf_struct_sumk</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_gf_struct_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver</span>
    <span class="k">def</span> <span class="nf">__set_gf_struct_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">gf_struct_solver</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_gf_struct_solver</span><span class="p">,</span><span class="n">__set_gf_struct_solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_solver_to_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk</span>
    <span class="k">def</span> <span class="nf">__set_solver_to_sumk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">solver_to_sumk</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_solver_to_sumk</span><span class="p">,</span><span class="n">__set_solver_to_sumk</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_sumk_to_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">sumk_to_solver</span>
    <span class="k">def</span> <span class="nf">__set_sumk_to_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">sumk_to_solver</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_sumk_to_solver</span><span class="p">,</span><span class="n">__set_sumk_to_solver</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_solver_to_sumk_block</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk_block</span>
    <span class="k">def</span> <span class="nf">__set_solver_to_sumk_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">solver_to_sumk_block</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_solver_to_sumk_block</span><span class="p">,</span><span class="n">__set_solver_to_sumk_block</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__get_deg_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">deg_shells</span>
    <span class="k">def</span> <span class="nf">__set_deg_shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">block_structure</span><span class="o">.</span><span class="n">deg_shells</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">deg_shells</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">__get_deg_shells</span><span class="p">,</span><span class="n">__set_deg_shells</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2011-2013, M. Aichhorn, L. Pourovskii, V. Vildosola, C. Martins.
    </div>
  </body>
</html>