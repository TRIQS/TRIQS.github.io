
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Elk to TRIQS &#8212; triqs_dft_tools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/triqs.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=default"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head><body>
<div class="pageheader">
  <ul>
    
    <li><a href="../../install.html">Install</a></li>
    
    <li><a href="../../documentation.html">Documentation</a></li>
    
    <li><a href="../../tutorials.html">Tutorials</a></li>
    
    <li><a href="../../issues.html">Issues</a></li>
    
    <li><a href="../../about.html">About DFTTools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../../index.html">dft tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://triqs.github.io/triqs">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Elk to TRIQS</a></li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Elk to TRIQS</a></li>
<li><a class="reference internal" href="#the-dmft-calculation">The DMFT calculation</a><ul>
<li><a class="reference internal" href="#loading-modules">Loading modules</a></li>
<li><a class="reference internal" href="#initializing-sumkdft">Initializing SumkDFT</a></li>
<li><a class="reference internal" href="#initializing-the-solver">Initializing the solver</a></li>
<li><a class="reference internal" href="#dmft-cycle">DMFT cycle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#triqs-to-elk-fully-charge-self-consistent-dft-dmft">TRIQS to Elk (Fully Charge Self-Consistent DFT+DMFT)</a><ul>
<li><a class="reference internal" href="#tail-fit-parameters">Tail fit parameters</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/tutorials/svo_elk/srvo3.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p id="srvo3-elk">This example is almost identical to the <a class="reference internal" href="../srvo3.html#srvo3"><span class="std std-ref">Wien2k-TRIQS SrVO3 example</span></a>. On the example of SrVO3 we will discuss now how to set up a full working calculation using Elk, including the initialization of the <a class="reference external" href="https://triqs.github.io/cthyb/latest/index.html#welcome" title="(in TRIQS Hybridization Expansion Solver v3.0.0)"><span class="xref std std-ref">CTHYB solver</span></a>. Some additional parameter are introduced to make the calculation more efficient. This is a more advanced example, which is also suited for parallel execution.</p>
<p>For the convenience of the user, we provide also a full python script (<a class="reference download internal" download="" href="../../_downloads/4331612df7a91990008a11e40e2223cf/dft_dmft_cthyb_elk.py"><code class="xref download docutils literal notranslate"><span class="pre">dft_dmft_cthyb_elk.py</span></code></a>). The user has to adapt it to their own needs. How to execute your script is described <a class="reference internal" href="../../basicnotions/structure.html#runpy"><span class="std std-ref">here</span></a>.</p>
<p>For more details we refer to the <a class="reference internal" href="../../guide/conversion.html#conversion"><span class="std std-ref">documentation</span></a>, now we will discuss the conversion for Elk.</p>
<p>A brief note before discussing the example. This interface works for any type of ground state Elk calculation using the interface calls described in this example (i.e. the interface is universal). If the user wishes to perform a spin-polarized calculation in DMFT alone (non magnetic DFT inputs), they have to lift the up / down spin symmetry manually (not shown here).</p>
<div class="section" id="elk-to-triqs">
<h1>Elk to TRIQS<a class="headerlink" href="#elk-to-triqs" title="Permalink to this headline">¶</a></h1>
<p>First, we perform a DFT calculation, using the Elk package. As main input file we have to provide the so-called elk.in <code class="file docutils literal notranslate"><span class="pre">elk.in</span></code>. We use the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>!Calculates the V t2g Wannier projectors, Wannier charge and Wannier DOS of SrVO3

!Example by Alyn D. N. James

tasks
 0
 805

ngridk
 12 12 12

sppath
  &#39;../../../species/&#39;

rgkmax
 7.0

avec
   7.260500000       0.000000000       0.000000000
   0.000000000       7.260500000       0.000000000
   0.000000000       0.000000000       7.260500000

atoms
   3                                    : nspecies
&#39;Sr.in&#39;                                 : spfname
   1                                    : natoms; atposl, bfcmt below
    0.50000000    0.50000000    0.50000000    0.00000000  0.00000000  0.00000000
&#39;V.in&#39;                                  : spfname
   1                                    : natoms; atposl, bfcmt below
    0.00000000    0.00000000    0.00000000    0.00000000  0.00000000  0.00000000
&#39;O.in&#39;                                  : spfname
   3                                    : natoms; atposl, bfcmt below
    0.50000000    0.00000000    0.00000000    0.00000000  0.00000000  0.00000000
    0.00000000    0.50000000    0.00000000    0.00000000  0.00000000  0.00000000
    0.00000000    0.00000000    0.50000000    0.00000000  0.00000000  0.00000000

wanproj		!projector flag
 1		!number of projectors - next 3 lines are repeated for each projector
 2 2 3		!species, l, reduced max lm (rlmmax) value
 7 8 9 		!the lm quanties which will be projected (vector length eq. rlmmax)
-0.055 0.07	![-1.5, 1.9] eV t2g correlated energy window
</pre></div>
</div>
<p>This <a class="reference download internal" download="" href="../../_downloads/d1b05aab1517eea0a610c6e2311bd75b/elk.in"><code class="xref download docutils literal notranslate"><span class="pre">elk.in</span></code></a> will generate the ground state (task 0) and the Wannier projectors (task 805) in a small energy window for the <span class="math notranslate nohighlight">\(V\)</span> <span class="math notranslate nohighlight">\(t_{2g}\)</span> orbitals. The elk executable is run in the directory including the elk.in file.</p>
<p>A simple python script that initializes the converter is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools.converters.elk</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">Converter</span> <span class="o">=</span> <span class="n">elkConverter</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;SrVO3&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>After initializing the converter, we can now convert the input text files into an hdf5 archive by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Converter</span><span class="o">.</span><span class="n">convert_dft_input</span><span class="p">()</span>
</pre></div>
</div>
<p>This reads all necessary data from the <a class="reference internal" href="../../guide/conv_elk.html#elk-files"><span class="std std-ref">Elk output</span></a>, and stores the converted input for the DMFT calculation in the file <code class="file docutils literal notranslate"><span class="pre">SrVO3.h5</span></code>.</p>
</div>
<div class="section" id="the-dmft-calculation">
<h1>The DMFT calculation<a class="headerlink" href="#the-dmft-calculation" title="Permalink to this headline">¶</a></h1>
<p>The DMFT script itself is, except very few details, independent of the DFT package that was used to calculate the local orbitals. As soon as one has converted everything to the hdf5 format, the following procedure is practically the same.</p>
<div class="section" id="loading-modules">
<h2>Loading modules<a class="headerlink" href="#loading-modules" title="Permalink to this headline">¶</a></h2>
<p>First, we load the necessary modules:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools.sumk_dft</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">triqs.gf</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">h5</span> <span class="k">import</span> <span class="n">HDFArchive</span>
<span class="kn">from</span> <span class="nn">triqs.operators.util</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">triqs_cthyb</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">triqs.utility.mpi</span> <span class="k">as</span> <span class="nn">mpi</span>
</pre></div>
</div>
<p>The last two lines load the modules for the construction of the
<a class="reference external" href="https://triqs.github.io/cthyb/latest/index.html#welcome" title="(in TRIQS Hybridization Expansion Solver v3.0.0)"><span class="xref std std-ref">CTHYB solver</span></a>.</p>
</div>
<div class="section" id="initializing-sumkdft">
<h2>Initializing SumkDFT<a class="headerlink" href="#initializing-sumkdft" title="Permalink to this headline">¶</a></h2>
<p>We define some parameters, which should be self-explanatory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">dft_filename</span> <span class="o">=</span> <span class="s1">&#39;SrVO3&#39;</span>          <span class="c1"># filename</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">4.0</span>                         <span class="c1"># interaction parameters</span>
<span class="n">J</span> <span class="o">=</span> <span class="mf">0.65</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mi">40</span>                       <span class="c1"># inverse temperature</span>
<span class="n">loops</span> <span class="o">=</span> <span class="mi">15</span>                      <span class="c1"># number of DMFT loops</span>
<span class="n">mix</span> <span class="o">=</span> <span class="mf">0.8</span>                       <span class="c1"># mixing factor of Sigma after solution of the AIM</span>
<span class="n">dc_type</span> <span class="o">=</span> <span class="mi">1</span>                     <span class="c1"># DC type: 0 FLL, 1 Held, 2 AMF</span>
<span class="n">use_blocks</span> <span class="o">=</span> <span class="kc">True</span>               <span class="c1"># use bloc structure from DFT input</span>
<span class="n">prec_mu</span> <span class="o">=</span> <span class="mf">0.0001</span>                <span class="c1"># precision of chemical potential</span>
</pre></div>
</div>
<p>And next, we can initialize the <code class="xref py py-class docutils literal notranslate"><span class="pre">SumkDFT</span></code> class:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SK</span> <span class="o">=</span> <span class="n">SumkDFT</span><span class="p">(</span><span class="n">hdf_file</span><span class="o">=</span><span class="n">dft_filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span><span class="n">use_dft_blocks</span><span class="o">=</span><span class="n">use_blocks</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="initializing-the-solver">
<h2>Initializing the solver<a class="headerlink" href="#initializing-the-solver" title="Permalink to this headline">¶</a></h2>
<p>We also have to specify the <a class="reference external" href="https://triqs.github.io/cthyb/latest/index.html#welcome" title="(in TRIQS Hybridization Expansion Solver v3.0.0)"><span class="xref std std-ref">CTHYB solver</span></a> related settings. We assume that the DMFT script for SrVO3 is executed on 16 cores. A sufficient set of parameters for a first guess is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
<span class="c1"># solver</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;length_cycle&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;n_warmup_cycles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;n_cycles&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000000</span>
<span class="c1"># tail fit</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;perform_tail_fit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;fit_max_moment&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;fit_min_n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">p</span><span class="p">[</span><span class="s2">&quot;fit_max_n&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">60</span>
</pre></div>
</div>
<p>Here we use a tail fit to deal with numerical noise of higher Matsubara frequencies. For other options and more details on the solver parameters, we refer to <a class="reference external" href="https://triqs.github.io/cthyb/latest/index.html#welcome" title="(in TRIQS Hybridization Expansion Solver v3.0.0)"><span class="xref std std-ref">CTHYB solver</span></a> documentation. It is important to note that the solver parameters have to be adjusted for each material individually. A guide on how to set the tail fit parameters is given <a class="reference internal" href="#tailfit"><span class="std std-ref">below</span></a>.</p>
<p>The next step is to initialize the <a class="reference external" href="https://triqs.github.io/cthyb/latest/reference/solver.html#triqs_cthyb.Solver" title="(in TRIQS Hybridization Expansion Solver v3.0.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">solver</span> <span class="pre">class</span></code></a>. It consist of two parts:</p>
<ol class="arabic simple">
<li><p>Calculating the multi-band interaction matrix, and constructing the
interaction Hamiltonian.</p></li>
<li><p>Initializing the solver class itself.</p></li>
</ol>
<p>The first step is done using methods of the <a class="reference external" href="https://triqs.github.io/triqs/latest/index.html#welcome" title="(in TRIQS v3.0.0)"><span class="xref std std-ref">TRIQS</span></a> library:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">n_orb</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;dim&#39;</span><span class="p">]</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">corr_shells</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;l&#39;</span><span class="p">]</span>
<span class="n">spin_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span><span class="s2">&quot;down&quot;</span><span class="p">]</span>
<span class="n">orb_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_orb</span><span class="p">)]</span>
<span class="c1"># Use GF structure determined by DFT blocks:</span>
<span class="n">gf_struct</span> <span class="o">=</span> <span class="p">[(</span><span class="n">block</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="k">for</span> <span class="n">block</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">SK</span><span class="o">.</span><span class="n">gf_struct_solver</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
<span class="c1"># Construct U matrix for density-density calculations:</span>
<span class="n">Umat</span><span class="p">,</span> <span class="n">Upmat</span> <span class="o">=</span> <span class="n">U_matrix_kanamori</span><span class="p">(</span><span class="n">n_orb</span><span class="o">=</span><span class="n">n_orb</span><span class="p">,</span> <span class="n">U_int</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span><span class="o">=</span><span class="n">J</span><span class="p">)</span>
</pre></div>
</div>
<p>We assumed here that we want to use an interaction matrix with Kanamori definitions of <span class="math notranslate nohighlight">\(U\)</span> and <span class="math notranslate nohighlight">\(J\)</span>.</p>
<p>Next, we construct the Hamiltonian and the solver:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">h_int</span> <span class="o">=</span> <span class="n">h_int_density</span><span class="p">(</span><span class="n">spin_names</span><span class="p">,</span> <span class="n">orb_names</span><span class="p">,</span> <span class="n">map_operator_structure</span><span class="o">=</span><span class="n">SK</span><span class="o">.</span><span class="n">sumk_to_solver</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">U</span><span class="o">=</span><span class="n">Umat</span><span class="p">,</span> <span class="n">Uprime</span><span class="o">=</span><span class="n">Upmat</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="n">beta</span><span class="p">,</span> <span class="n">gf_struct</span><span class="o">=</span><span class="n">gf_struct</span><span class="p">)</span>
</pre></div>
</div>
<p>For simplicity, we take only density-density interactions into account here. Other Hamiltonians with, e.g. with full rotational invariant interactions are:</p>
<ul class="simple">
<li><p>h_int_kanamori</p></li>
<li><p>h_int_slater</p></li>
</ul>
<p>For other choices of the interaction matrices (e.g Slater representation) or Hamiltonians, we refer to the reference manual of the <a class="reference external" href="https://triqs.github.io/triqs/latest/index.html#welcome" title="(in TRIQS v3.0.0)"><span class="xref std std-ref">TRIQS</span></a> library.</p>
<p>As a last step, we initialize the subgroup in the hdf5 archive to store the results:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ar</span><span class="o">.</span><span class="n">is_group</span><span class="p">(</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">)):</span>
            <span class="n">ar</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dmft-cycle">
<h2>DMFT cycle<a class="headerlink" href="#dmft-cycle" title="Permalink to this headline">¶</a></h2>
<p>Now we can go to the definition of the self-consistency step. It consists again of the basic steps with some additional refinements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">iteration_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">loops</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span> <span class="nb">print</span> <span class="s2">&quot;Iteration = &quot;</span><span class="p">,</span> <span class="n">iteration_number</span>

    <span class="n">SK</span><span class="o">.</span><span class="n">symm_deg_gf</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">,</span><span class="n">ish</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>                        <span class="c1"># symmetrizing Sigma</span>
    <span class="n">SK</span><span class="o">.</span><span class="n">set_Sigma</span><span class="p">([</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="p">])</span>                            <span class="c1"># put Sigma into the SumK class</span>
    <span class="n">chemical_potential</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">calc_mu</span><span class="p">(</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">prec_mu</span> <span class="p">)</span>  <span class="c1"># find the chemical potential for given density</span>
    <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">SK</span><span class="o">.</span><span class="n">extract_G_loc</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>                         <span class="c1"># calc the local Green function</span>
    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Total charge of Gloc : </span><span class="si">%.6f</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">total_density</span><span class="p">())</span>

    <span class="c1"># In the first loop, init the DC term and the real part of Sigma:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span>
        <span class="n">SK</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">U_interact</span> <span class="o">=</span> <span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span> <span class="o">=</span> <span class="n">J</span><span class="p">,</span> <span class="n">orb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="n">dc_type</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">SK</span><span class="o">.</span><span class="n">dc_imp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;up&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate new G0_iw to input into the solver:</span>
    <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">+</span> <span class="n">inverse</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="p">)</span>
    <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span> <span class="o">&lt;&lt;</span> <span class="n">inverse</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span><span class="p">)</span>

    <span class="c1"># Solve the impurity problem:</span>
    <span class="n">S</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">h_int</span><span class="o">=</span><span class="n">h_int</span><span class="p">,</span> <span class="o">**</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># Solved. Now do post-solution stuff:</span>
    <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Total charge of impurity problem : </span><span class="si">%.6f</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">total_density</span><span class="p">())</span>

    <span class="c1"># Now mix Sigma and G with factor mix, if wanted:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">iteration_number</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
            <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
                <span class="n">mpi</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s2">&quot;Mixing Sigma and G with factor </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">mix</span><span class="p">)</span>
                <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mix</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;Sigma_iw&#39;</span><span class="p">]</span>
                <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mix</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;G_iw&#39;</span><span class="p">]</span>
        <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span> <span class="o">&lt;&lt;</span> <span class="n">mpi</span><span class="o">.</span><span class="n">bcast</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">)</span>

    <span class="c1"># Write the final Sigma and G to the hdf5 archive:</span>
    <span class="k">if</span> <span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">():</span>
        <span class="k">with</span> <span class="n">HDFArchive</span><span class="p">(</span><span class="n">dft_filename</span><span class="o">+</span><span class="s1">&#39;.h5&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ar</span><span class="p">:</span>
              <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;iterations&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">iteration_number</span>
              <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;G_0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G0_iw</span>
              <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;G_tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_tau</span>
              <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;G_iw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span>
              <span class="n">ar</span><span class="p">[</span><span class="s1">&#39;dmft_output&#39;</span><span class="p">][</span><span class="s1">&#39;Sigma_iw&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span>

    <span class="c1"># Set the new double counting:</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">G_iw</span><span class="o">.</span><span class="n">density</span><span class="p">()</span> <span class="c1"># compute the density matrix of the impurity problem</span>
    <span class="n">SK</span><span class="o">.</span><span class="n">calc_dc</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">U_interact</span> <span class="o">=</span> <span class="n">U</span><span class="p">,</span> <span class="n">J_hund</span> <span class="o">=</span> <span class="n">J</span><span class="p">,</span> <span class="n">orb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">use_dc_formula</span> <span class="o">=</span> <span class="n">dc_type</span><span class="p">)</span>

    <span class="c1"># Save stuff into the user_data group of hdf5 archive in case of rerun:</span>
    <span class="n">SK</span><span class="o">.</span><span class="n">save</span><span class="p">([</span><span class="s1">&#39;chemical_potential&#39;</span><span class="p">,</span><span class="s1">&#39;dc_imp&#39;</span><span class="p">,</span><span class="s1">&#39;dc_energ&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="triqs-to-elk-fully-charge-self-consistent-dft-dmft">
<h1>TRIQS to Elk (Fully Charge Self-Consistent DFT+DMFT)<a class="headerlink" href="#triqs-to-elk-fully-charge-self-consistent-dft-dmft" title="Permalink to this headline">¶</a></h1>
<p>To output the DMATDMFT.OUT file for a fully charge self-consistent calculation, add the following lines to the end of the DMFT python script:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#output the density matrix for Elk interface</span>
<span class="n">dN</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">SK</span><span class="o">.</span><span class="n">calc_density_correction</span><span class="p">()</span>
<span class="c1">#correlation energy via the Migdal formula</span>
<span class="n">correnerg</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">G_iw</span> <span class="o">*</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">)</span><span class="o">.</span><span class="n">total_density</span><span class="p">()</span>
<span class="c1">#subtract the double counting energy</span>
<span class="n">correnerg</span> <span class="o">-=</span> <span class="n">SK</span><span class="o">.</span><span class="n">dc_energ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">#convert to Hartree</span>
<span class="n">correnerg</span> <span class="o">=</span> <span class="n">correnerg</span><span class="o">/</span><span class="n">SK</span><span class="o">.</span><span class="n">energy_unit</span>
<span class="c1">#save the correction to energy</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mpi</span><span class="o">.</span><span class="n">is_master_node</span><span class="p">()):</span>
  <span class="n">f</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s1">&#39;DMATDMFT.OUT&#39;</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
  <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%.16f</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">correnerg</span><span class="p">)</span>
  <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>To update the electron density and solve the Kohn-Sham equations once, run task 808 in elk.in. Automating this cycle can be done by running the shell script (<a class="reference download internal" download="" href="../../_downloads/5473e1c8ea5d5fdabfe61307c2a9e13c/elk_fcsc.sh"><code class="xref download docutils literal notranslate"><span class="pre">elk_fcsc.sh</span></code></a>) and having an <a class="reference download internal" download="" href="../../_downloads/feed3685c149783c14ebe43558c67e89/elk_master.in"><code class="xref download docutils literal notranslate"><span class="pre">elk_master.in</span></code></a> file which replaces the tasks in elk.in for each new task in the FCSC DFT+DMFT cycle (see <a class="reference download internal" download="" href="../../_downloads/feed3685c149783c14ebe43558c67e89/elk_master.in"><code class="xref download docutils literal notranslate"><span class="pre">elk_master.in</span></code></a>.  Assuming that the ground state has been calculated, this shell script executes the following:</p>
<ol class="arabic simple">
<li><p>generate the projectors (task 805)</p></li>
<li><p>execute the DMFT cycle(s)</p></li>
<li><p>update the electron density</p></li>
<li><p>-&gt; (1) …</p></li>
</ol>
<p>The user just needs to specify the maximum number of FCSC cycles, as well as the number of OpenMP threads for Elk (<cite>OMP_NUM_THREADS</cite>) and the number of MPI ranks in the bash script.</p>
<p>This is all we need for the one-shot or FCSC DFT+DMFT calculation. All results of this calculation will be stored in a separate subgroup in the hdf5 file, called <cite>dmft_output</cite>. Note that the script performs 15 DMFT cycles, but does not check for convergence. It would be possible to build in convergence criteria.  A simple check for convergence can be also done if you store multiple quantities of each iteration and analyse the convergence manually. In general, it is advisable to start with less good statistics (fewer measurements), and increase the number of measurements close to convergence (e.g. after a few initial iterations). This helps to keep computational costs low during the first iterations.</p>
<p>Using the Kanamori Hamiltonian and the parameters above (but on 16 cores), your self energy after the <strong>first iteration</strong> should look something like:</p>
<a class="reference internal image-reference" href="../../_images/SrVO3_Sigma_iw_it1.png"><img alt="../../_images/SrVO3_Sigma_iw_it1.png" class="align-center" src="../../_images/SrVO3_Sigma_iw_it1.png" style="width: 700px;" /></a>
<div class="section" id="tail-fit-parameters">
<span id="tailfit"></span><h2>Tail fit parameters<a class="headerlink" href="#tail-fit-parameters" title="Permalink to this headline">¶</a></h2>
<p>A good way to identify suitable tail fit parameters is by “human inspection”. Therefore disabled the tail fitting first:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;perform_tail_fit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
<p>and perform only one DMFT iteration. The resulting self energy can be tail fitted by hand:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Sigma_iw_fit</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">Sigma_iw_fit</span> <span class="o">&lt;&lt;</span> <span class="n">tail_fit</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">Sigma_iw</span><span class="p">,</span> <span class="n">fit_max_moment</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">fit_min_n</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">fit_max_n</span> <span class="o">=</span> <span class="mi">160</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>Plot the self energy and adjust the tail fit parameters such that you obtain a proper fit. The <code class="xref py py-meth docutils literal notranslate"><span class="pre">fit_tail</span> <span class="pre">function</span></code> is part of the <a class="reference external" href="https://triqs.github.io/triqs/latest/index.html#welcome" title="(in TRIQS v3.0.0)"><span class="xref std std-ref">TRIQS</span></a> library.</p>
<p>For a self energy which is going to zero for <span class="math notranslate nohighlight">\(i\omega \rightarrow 0\)</span> our suggestion is to start the tail fit (<em>fit_min_n</em>) at a Matsubara frequency considerable above the minimum of the self energy and to stop (<em>fit_max_n</em>) before the noise fully takes over. If it is difficult to find a reasonable fit in this region you should increase your statistics (number of measurements). Keep in mind that <em>fit_min_n</em> and <em>fit_max_n</em> also depend on <span class="math notranslate nohighlight">\(\beta\)</span>.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
    <li><a href="../../index.html">Home</a> &raquo;</li>

        <li class="nav-item nav-item-this"><a href="">Elk to TRIQS</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2020.
    </div>
  </body>
</html>