
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Orbital construction and conversion &#8212; TRIQS DFTTools  documentation</title>
    <link rel="stylesheet" href="../_static/triqs.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=default"></script>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Single-shot DFT+DMFT" href="dftdmft_singleshot.html" />
    <link rel="prev" title="Structure of DFTTools" href="../basicnotions/structure.html" />
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
    <script src="../_static/cufon-yui.js" type="text/javascript"></script>
    <script src="../_static/spaceman.cufonfonts.js" type="text/javascript"></script>
    <script type="text/javascript">
      Cufon.replace('.triqs', { fontFamily: 'spaceman', hover: true }); 
    </script>
 
    <style type="text/css">
      table.right { float: right; margin-left: 20px; }
      table.right td { border: 1px solid #ccc; }
      
    </style>

  </head>
  <body>
<div class="pageheader">
  <ul>
    
    <li><a href="../install.html">Install</a></li>
    
    <li><a href="../documentation.html">Documentation</a></li>
    
    <li><a href="../issues.html">Issues</a></li>
    
    <li><a href="../about.html">About DFTTools</a></li>
    
  </ul>
  <div>
    <h1 style="padding:0; margin: 10px 0 0 0;"><a class="triqs" href="../index.html">dft tools</a></h1>
    <span style="font-size: 14px; margin: 0px; padding: 0px;">connecting <a class="triqs" style="font-size: 12px" href="http://triqs.github.io/triqs">TRIQS</a> to DFT packages</span>
  </div>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dftdmft_singleshot.html" title="Single-shot DFT+DMFT"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="../basicnotions/structure.html" title="Structure of DFTTools"
             accesskey="P">previous</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" accesskey="U">Documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Orbital construction and conversion</a><ul>
<li><a class="reference internal" href="#interface-with-wien2k">Interface with Wien2k</a><ul>
<li><a class="reference internal" href="#conversion-for-the-dmft-self-consistency-cycle">Conversion for the DMFT self-consistency cycle</a></li>
<li><a class="reference internal" href="#data-for-post-processing">Data for post-processing</a></li>
<li><a class="reference internal" href="#data-for-transport-calculations">Data for transport calculations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interface-with-vasp">Interface with VASP</a><ul>
<li><a class="reference internal" href="#id1">Conversion for the DMFT self-consistency cycle</a></li>
</ul>
</li>
<li><a class="reference internal" href="#a-general-h-k">A general H(k)</a></li>
<li><a class="reference internal" href="#wannier90-converter">Wannier90 Converter</a></li>
<li><a class="reference internal" href="#mpi-issues">MPI issues</a></li>
<li><a class="reference internal" href="#interfaces-to-other-packages">Interfaces to other packages</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="../basicnotions/structure.html"
                        title="previous chapter">Structure of <strong class="program">DFTTools</strong></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="dftdmft_singleshot.html"
                        title="next chapter">Single-shot DFT+DMFT</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/guide/conversion.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="orbital-construction-and-conversion">
<span id="conversion"></span><h1>Orbital construction and conversion<a class="headerlink" href="#orbital-construction-and-conversion" title="Permalink to this headline">¶</a></h1>
<p>The first step for a DMFT calculation is to provide the necessary
input based on a DFT calculation. We will not review how to do the DFT
calculation here in this documentation, but refer the user to the
documentation and tutorials that come with the actual DFT
package. Here, we will describe how to use output created by Wien2k,
as well as how to use the light-weight general interface.</p>
<div class="section" id="interface-with-wien2k">
<h2>Interface with Wien2k<a class="headerlink" href="#interface-with-wien2k" title="Permalink to this headline">¶</a></h2>
<p>We assume that the user has obtained a self-consistent solution of the
Kohn-Sham equations. We further have to require that the user is
familiar with the main in/output files of Wien2k, and how to run
the DFT code.</p>
<div class="section" id="conversion-for-the-dmft-self-consistency-cycle">
<h3>Conversion for the DMFT self-consistency cycle<a class="headerlink" href="#conversion-for-the-dmft-self-consistency-cycle" title="Permalink to this headline">¶</a></h3>
<p>First, we have to write the necessary
quantities into a file that can be processed further by invoking in a
shell the command</p>
<blockquote>
<div><cite>x lapw2 -almd</cite></div></blockquote>
<p>We note that any other flag for lapw2, such as -c or -so (for
spin-orbit coupling) has to be added also to this line. This creates
some files that we need for the Wannier orbital construction.</p>
<p>The orbital construction itself is done by the Fortran program
<strong class="program">dmftproj</strong>. For an extensive manual to this program see
<a class="reference download internal" href="../_downloads/TutorialDmftproj.pdf" download=""><code class="xref download docutils literal"><span class="pre">TutorialDmftproj.pdf</span></code></a>.
Here we will only describe the basic steps.</p>
<p>Let us take the compound SrVO3, a commonly used
example for DFT+DMFT calculations. The input file for
<strong class="program">dmftproj</strong> looks like</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>3                ! Nsort
1 1 3            ! Mult(Nsort)
3                ! lmax
complex          ! choice of angular harmonics
1 0 0 0          ! l included for each sort
0 0 0 0          ! If split into ireps, gives number of ireps. for a given orbital (otherwise 0)
cubic            ! choice of angular harmonics
1 1 2 0          ! l included for each sort
0 0 2 0          ! If split into ireps, gives number of ireps. for a given orbital (otherwise 0)
01               !
0                ! SO flag
complex          ! choice of angular harmonics
1 1 0 0          ! l included for each sort
0 0 0 0          ! If split into ireps, gives number of ireps. for a given orbital (otherwise 0)
-0.11 0.14


</pre></div>
</div>
<p>The first three lines give the number of inequivalent sites, their
multiplicity (to be in accordance with the Wien2k <em>struct</em> file) and
the maximum orbital quantum number <span class="math">\(l_{max}\)</span>. In our case our
struct file contains the atoms in the order Sr, V, O.</p>
<p>Next we have to
specify for each of the inequivalent sites, whether we want to treat
their orbitals as correlated or not. This information is given by the
following 3 to 5 lines:</p>
<ol class="arabic simple">
<li>We specify which basis set is used (complex or cubic
harmonics).</li>
<li>The four numbers refer to <em>s</em>, <em>p</em>, <em>d</em>, and <em>f</em> electrons,
resp. Putting 0 means doing nothing, putting 1 will calculate
<strong>unnormalized</strong> projectors in compliance with the Wien2k
definition. The important flag is 2, this means to include these
electrons as correlated electrons, and calculate normalized Wannier
functions for them. In the example above, you see that only for the
vanadium <em>d</em> we set the flag to 2. If you want to do simply a DMFT
calculation, then set everything to 0, except one flag 2 for the
correlated electrons.</li>
<li>In case you have a irrep splitting of the correlated shell, you can
specify here how many irreps you have. You see that we put 2, since
eg and t2g symmetries are irreps in this cubic case. If you don’t
want to use this splitting, just put 0.</li>
<li>(optional) If you specifies a number different from 0 in above line, you have
to tell now, which of the irreps you want to be treated
correlated. We want to t2g, and not the eg, so we set 0 for eg and
1 for t2g. Note that the example above is what you need in 99% of
the cases when you want to treat only t2g electrons. For eg’s only
(e.g. nickelates), you set 10 and 01 in this line.</li>
<li>(optional) If you have specified a correlated shell for this atom,
you have to tell if spin-orbit coupling should be taken into
account. 0 means no, 1 is yes.</li>
</ol>
<p>These lines have to be repeated for each inequivalent atom.</p>
<p>The last line gives the energy window, relative to the Fermi energy,
that is used for the projective Wannier functions. Note that, in
accordance with Wien2k, we give energies in Rydberg units!</p>
<p>After setting up this input file, you run:</p>
<blockquote>
<div><cite>dmftproj</cite></div></blockquote>
<p>Again, adding possible flags like -so for spin-orbit coupling. This
program produces the following files (in the following, take <em>case</em> as
the standard Wien2k place holder, to be replaced by the actual working
directory name):</p>
<blockquote>
<div><ul class="simple">
<li><code class="file docutils literal"><span class="pre">case.ctqmcout</span></code> and <code class="file docutils literal"><span class="pre">case.symqmc</span></code> containing projector
operators and symmetry operations for orthonormalized Wannier
orbitals, respectively.</li>
<li><code class="file docutils literal"><span class="pre">case.parproj</span></code> and <code class="file docutils literal"><span class="pre">case.sympar</span></code> containing projector
operators and symmetry operations for uncorrelated states,
respectively. These files are needed for projected
density-of-states or spectral-function calculations in
post-processing only.</li>
<li><code class="file docutils literal"><span class="pre">case.oubwin</span></code> needed for the charge density recalculation in
the case of fully self-consistent DFT+DMFT run (see below).</li>
</ul>
</div></blockquote>
<p>Now we convert these files into an hdf5 file that can be used for the
DMFT calculations. For this purpose we
use the python module <code class="xref py py-class docutils literal"><span class="pre">Wien2kConverter</span></code>. It is initialized as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools.converters.wien2k_converter</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">Converter</span> <span class="o">=</span> <span class="n">Wien2kConverter</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">case</span><span class="p">)</span>
</pre></div>
</div>
<p>The only necessary parameter to this construction is the parameter <cite>filename</cite>.
It has to be the root of the files produces by dmftproj. For our
example, the Wien2k naming convention is that all files are
called the same, for instance
<code class="file docutils literal"><span class="pre">SrVO3.*</span></code>, so you would give <cite>filename = “SrVO3”</cite>. The constructor opens
an hdf5 archive, named <code class="file docutils literal"><span class="pre">case.h5</span></code>, where all the data is
stored. For other parameters of the constructor please visit the
<a class="reference internal" href="../reference/converters.html#refconverters"><span class="std std-ref">Converters</span></a> section of the reference manual.</p>
<p>After initializing the interface module, we can now convert the input
text files to the hdf5 archive by:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Converter</span><span class="o">.</span><span class="n">convert_dft_input</span><span class="p">()</span>
</pre></div>
</div>
<p>This reads all the data, and stores it in the file <code class="file docutils literal"><span class="pre">case.h5</span></code>.
In this step, the files <code class="file docutils literal"><span class="pre">case.ctqmcout</span></code> and
<code class="file docutils literal"><span class="pre">case.symqmc</span></code>
have to be present in the working directory.</p>
<p>After this step, all the necessary information for the DMFT loop is
stored in the hdf5 archive, where the string variable
<cite>Converter.hdf_filename</cite> gives the file name of the archive.</p>
<p>At this point you should use the method <code class="xref py py-meth docutils literal"><span class="pre">dos_wannier_basis</span></code>
contained in the module <code class="xref py py-class docutils literal"><span class="pre">SumkDFTTools</span></code> to check the density of
states of the Wannier orbitals (see <a class="reference internal" href="analysis.html#analysis"><span class="std std-ref">Tools for analysis</span></a>).</p>
<p>You have now everything for performing a DMFT calculation, and you can
proceed with the section on <a class="reference internal" href="dftdmft_singleshot.html#singleshot"><span class="std std-ref">single-shot DFT+DMFT calculations</span></a>.</p>
</div>
<div class="section" id="data-for-post-processing">
<h3>Data for post-processing<a class="headerlink" href="#data-for-post-processing" title="Permalink to this headline">¶</a></h3>
<p>In case you want to do post-processing of your data using the module
<code class="xref py py-class docutils literal"><span class="pre">SumkDFTTools</span></code>, some more files
have to be converted to the hdf5 archive. For instance, for
calculating the partial density of states or partial charges
consistent with the definition of Wien2k, you have to invoke:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Converter</span><span class="o">.</span><span class="n">convert_parproj_input</span><span class="p">()</span>
</pre></div>
</div>
<p>This reads and converts the files <code class="file docutils literal"><span class="pre">case.parproj</span></code> and
<code class="file docutils literal"><span class="pre">case.sympar</span></code>.</p>
<p>If you want to plot band structures, one has to do the
following. First, one has to do the Wien2k calculation on the given
<span class="math">\(\mathbf{k}\)</span>-path, and run <strong class="program">dmftproj</strong> on that path:</p>
<blockquote>
<div><div class="line-block">
<div class="line"><cite>x lapw1 -band</cite></div>
<div class="line"><cite>x lapw2 -band -almd</cite></div>
<div class="line"><cite>dmftproj -band</cite></div>
</div>
</div></blockquote>
<p>Again, maybe with the optional additional extra flags according to
Wien2k. Now we use a routine of the converter module allows to read
and convert the input for <code class="xref py py-class docutils literal"><span class="pre">SumkDFTTools</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Converter</span><span class="o">.</span><span class="n">convert_bands_input</span><span class="p">()</span>
</pre></div>
</div>
<p>After having converted this input, you can further proceed with the
<a class="reference internal" href="analysis.html#analysis"><span class="std std-ref">Tools for analysis</span></a>. For more options on the converter module, please have
a look at the <a class="reference internal" href="../reference/converters.html#refconverters"><span class="std std-ref">Converters</span></a> section of the reference manual.</p>
</div>
<div class="section" id="data-for-transport-calculations">
<h3>Data for transport calculations<a class="headerlink" href="#data-for-transport-calculations" title="Permalink to this headline">¶</a></h3>
<p>For the transport calculations, the situation is a bit more involved,
since we need also the <strong class="program">optics</strong> package of Wien2k. Please
look at the section on <a class="reference internal" href="transport.html#transport"><span class="std std-ref">Transport calculations</span></a> to see how to do the necessary
steps, including the conversion.</p>
</div>
</div>
<div class="section" id="interface-with-vasp">
<h2>Interface with VASP<a class="headerlink" href="#interface-with-vasp" title="Permalink to this headline">¶</a></h2>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The VASP interface is in the alpha-version and the VASP part of it is not
yet publicly released. The documentation may, thus, be subject to changes
before the final release.</p>
</div>
<p>Note that this VASP interface relies on new options introduced since version
5.4.x.</p>
<p>Additionally, the interface only works correctly if the k-point symmetries
are turned off during the VASP run (ISYM=-1).</p>
<p>The output of raw (non-normalized) projectors is controlled by an INCAR option
LOCPROJ whose complete syntax is described in the VASP documentaion.</p>
<p>The definition of a projector set starts with specifying which sites
and which local states we are going to project onto.
This information is provided by option LOCPROJ</p>
<blockquote>
<div><div class="line-block">
<div class="line"><cite>LOCPROJ = &lt;sites&gt; : &lt;shells&gt; : &lt;projector type&gt;</cite></div>
</div>
</div></blockquote>
<p>where <cite>&lt;sites&gt;</cite> represents a list of site indices separated by spaces,
with the indices corresponding to the site position in the POSCAR file;
<cite>&lt;shells&gt;</cite> specifies local states (e.g. <span class="math">\(s\)</span>, <span class="math">\(p\)</span>, <span class="math">\(d\)</span>,
<span class="math">\(d_{x^2-y^2}\)</span>, etc.);
<cite>&lt;projector type&gt;</cite> chooses a particular type of the local basis function.</p>
<p>Some projector types also require parameters <cite>EMIN</cite>, <cite>EMAX</cite> in INCAR to
be set to define an (approximate) energy window corresponding to the
valence states.</p>
<p>When either a self-consistent (<cite>ICHARG &lt; 10</cite>) or a non-self-consistent
(<cite>ICHARG &gt;= 10</cite>) calculation is done VASP produces file <cite>LOCPROJ</cite> which
will serve as the main input for the conversion routine.</p>
<div class="section" id="id1">
<h3>Conversion for the DMFT self-consistency cycle<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>In order to use the projectors generated by VASP for defining an
impurity problem they must be processed, i.e. normalized, possibly
transformed, and then converted to a format suitable for DFT_tools scripts.</p>
<p>Currently, it is necessary to add the Fermi energy by hand as the fifth value
in the first line of the LOCPROJ file before the next steps can be executed.</p>
<p>The processing of projectors is performed by the program <strong class="program">plovasp</strong>
invoked as</p>
<blockquote>
<div><div class="line-block">
<div class="line"><cite>plovasp &lt;plo.cfg&gt;</cite></div>
</div>
</div></blockquote>
<p>where <cite>&lt;plo.cfg&gt;</cite> is a input file controlling the conversion of projectors.</p>
<p>The format of input file <cite>&lt;plo.cfg&gt;</cite> is described in details in
<a class="reference internal" href="plovasp.html#plovasp"><span class="std std-ref">PLOVasp input file</span></a>. Here we just give a simple example for the case
of SrVO3:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Shell</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">LSHELL</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">IONS</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">EWINDOW</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.45</span>  <span class="mf">1.8</span>

<span class="n">TRANSFORM</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>
            <span class="mf">0.0</span>  <span class="mf">1.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>
            <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">0.0</span>  <span class="mf">1.0</span>  <span class="mf">0.0</span>
</pre></div>
</div>
<p>A projector shell is defined by a section <cite>[Shell 1]</cite> where the number
can be arbitrary and used only for user convenience. Several
parameters are required</p>
<ul class="simple">
<li><strong>IONS</strong>: list of site indices which must be a subset of indices
given earlier in <cite>LOCPROJ</cite>.</li>
<li><strong>LSHELL</strong>: <span class="math">\(l\)</span>-quantum number of the projector shell; the corresponding
orbitals must be present in <cite>LOCPROJ</cite>.</li>
<li><strong>EWINDOW</strong>: energy window in which the projectors are normalized;
note that the energies are defined with respect to the Fermi level.</li>
</ul>
<p>Option <strong>TRANSFORM</strong> is optional but here it is specified to extract
only three <span class="math">\(t_{2g}\)</span> orbitals out of five <cite>d</cite> orbitals given by
<span class="math">\(l = 2\)</span>.</p>
<p>For the conversion to a h5 file we use on the python level (in analogy to the Wien2kConverter):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools.converters.vasp_converter</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">Converter</span> <span class="o">=</span> <span class="n">VaspConverter</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span><span class="p">)</span>
<span class="n">Converter</span><span class="o">.</span><span class="n">convert_dft_input</span><span class="p">()</span>
</pre></div>
</div>
<p>As usual, the resulting h5-file can then be used with the SumkDFT class.</p>
<p>Note that the automatic detection of the correct blockstructure might fail for VASP inputs.
This can be circumvented by increase the <code class="xref py py-class docutils literal"><span class="pre">SumkDFT</span></code> threshold to e.g.:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">SK</span><span class="o">.</span><span class="n">analyse_block_structure</span><span class="p">(</span><span class="n">threshold</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">)</span>
</pre></div>
</div>
<p>However, only do this after a careful study of the density matrix and the dos in the wannier basis.</p>
</div>
</div>
<div class="section" id="a-general-h-k">
<h2>A general H(k)<a class="headerlink" href="#a-general-h-k" title="Permalink to this headline">¶</a></h2>
<p>In addition to the more complicated Wien2k converter,
<strong class="program">DFTTools</strong> contains also a light converter. It takes only
one inputfile, and creates the necessary hdf outputfile for
the DMFT calculation. The header of this input file has a defined
format, an example is the following (do not use the text/comments in your
input file):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">64</span>                  <span class="c1"># number of k-points</span>
<span class="mf">1.0</span>                 <span class="c1"># electron density</span>
<span class="mi">2</span>                   <span class="c1"># number of total atomic shells</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span>             <span class="c1"># atom, sort, l, dim</span>
<span class="mi">2</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span>             <span class="c1"># atom, sort, l, dim</span>
<span class="mi">1</span>                   <span class="c1"># number of correlated shells</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">0</span> <span class="mi">0</span>         <span class="c1"># atom, sort, l, dim, SO, irep</span>
<span class="mi">1</span> <span class="mi">5</span>                 <span class="c1"># number of ireps, dim of irep</span>
</pre></div>
</div>
<p>The lines of this header define</p>
<ol class="arabic">
<li><p class="first">Number of <span class="math">\(\mathbf{k}\)</span>-points used in the calculation</p>
</li>
<li><p class="first">Electron density for setting the chemical potential</p>
</li>
<li><p class="first">Number of total atomic shells in the hamiltonian matrix. In short,
this gives the number of lines described in the following. IN the
example file give above this number is 2.</p>
</li>
<li><p class="first">The next line(s) contain four numbers each: index of the atom, index
of the equivalent shell, <span class="math">\(l\)</span> quantum number, dimension
of this shell. Repeat this line for each atomic shell, the number
of the shells is given in the previous line.</p>
<p>In the example input file given above, we have two inequivalent
atomic shells, one on atom number 1 with a full d-shell (dimension 5),
and one on atom number 2 with one p-shell (dimension 3).</p>
<p>Other examples for these lines are:</p>
<ol class="arabic simple">
<li>Full d-shell in a material with only one correlated atom in the
unit cell (e.g. SrVO3). One line is sufficient and the numbers
are <cite>1 1 2 5</cite>.</li>
<li>Full d-shell in a material with two equivalent atoms in the unit
cell (e.g. FeSe): You need two lines, one for each equivalent
atom. First line is <cite>1 1 2 5</cite>, and the second line is
<cite>2 1 2 5</cite>. The only difference is the first number, which tells on
which atom the shell is located. The second number is the
same in both lines, meaning that both atoms are equivalent.</li>
<li>t2g orbitals on two non-equivalent atoms in the unit cell: Two
lines again. First line is <cite>1 1 2 3</cite>, second line <cite>2 2 2 3</cite>. The
difference to the case above is that now also the second number
differs. Therefore, the two shells are treated independently in
the calculation.</li>
<li>d-p Hamiltonian in a system with two equivalent atoms each in
the unit cell (e.g. FeSe has two Fe and two Se in the unit
cell). You need for lines. First line <cite>1 1 2 5</cite>, second
line
<cite>2 1 2 5</cite>. These two lines specify Fe as in the case above. For the p
orbitals you need line three as <cite>3 2 1 3</cite> and line four
as <cite>4 2 1 3</cite>. We have 4 atoms, since the first number runs from 1 to 4,
but only two inequivalent atoms, since the second number runs
only form 1 to 2.</li>
</ol>
<p>Note that the total dimension of the hamiltonian matrices that are
read in is the sum of all shell dimensions that you specified. For
example number 4 given above we have a dimension of 5+5+3+3=16. It is important
that the order of the shells that you give here must be the same as
the order of the orbitals in the hamiltonian matrix. In the last
example case above the code assumes that matrix index 1 to 5
belongs to the first d shell, 6 to 10 to the second, 11 to 13 to
the first p shell, and 14 to 16 the second p shell.</p>
</li>
<li><p class="first">Number of correlated shells in the hamiltonian matrix, in the same
spirit as line 3.</p>
</li>
<li><p class="first">The next line(s) contain six numbers: index of the atom, index
of the equivalent shell, <span class="math">\(l\)</span> quantum number, dimension
of the correlated shells, a spin-orbit parameter, and another
parameter defining interactions. Note that the latter two
parameters are not used at the moment in the code, and only kept
for compatibility reasons. In our example file we use only the
d-shell as correlated, that is why we have only one line here.</p>
</li>
<li><p class="first">The last line contains several numbers: the number of irreducible
representations, and then the dimensions of the irreps. One
possibility is as the example above, another one would be 2
2 3. This would mean, 2 irreps (eg and t2g), of dimension 2 and 3,
resp.</p>
</li>
</ol>
<p>After these header lines, the file has to contain the Hamiltonian
matrix in orbital space. The standard convention is that you give for
each <span class="math">\(\mathbf{k}\)</span>-point first the matrix of the real part, then the
matrix of the imaginary part, and then move on to the next <span class="math">\(\mathbf{k}\)</span>-point.</p>
<p>The converter itself is used as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools.converters.hk_converter</span> <span class="k">import</span> <span class="o">*</span>
<span class="n">Converter</span> <span class="o">=</span> <span class="n">HkConverter</span><span class="p">(</span><span class="n">filename</span> <span class="o">=</span> <span class="n">hkinputfile</span><span class="p">)</span>
<span class="n">Converter</span><span class="o">.</span><span class="n">convert_dft_input</span><span class="p">()</span>
</pre></div>
</div>
<p>where <code class="file docutils literal"><span class="pre">hkinputfile</span></code> is the name of the input file described
above. This produces the hdf file that you need for a DMFT calculation.</p>
<p>For more options of this converter, have a look at the
<a class="reference internal" href="../reference/converters.html#refconverters"><span class="std std-ref">Converters</span></a> section of the reference manual.</p>
</div>
<div class="section" id="wannier90-converter">
<h2>Wannier90 Converter<a class="headerlink" href="#wannier90-converter" title="Permalink to this headline">¶</a></h2>
<p>Using this converter it is possible to convert the output of
<a class="reference external" href="http://wannier.org">wannier90</a>
Maximally Localized Wannier Functions (MLWF) and create a HDF5 archive
suitable for one-shot DMFT calculations with the
<code class="xref py py-class docutils literal"><span class="pre">SumkDFT</span></code> class.</p>
<p>The user must supply two files in order to run the Wannier90 Converter:</p>
<ol class="arabic simple">
<li>The file <code class="file docutils literal"><span class="pre">seedname_hr.dat</span></code>, which contains the DFT Hamiltonian
in the MLWF basis calculated through <strong class="program">wannier90</strong> with <code class="docutils literal"><span class="pre">hr_plot</span> <span class="pre">=</span> <span class="pre">true</span></code>
(please refer to the <strong class="program">wannier90</strong> documentation).</li>
<li>A file named <code class="file docutils literal"><span class="pre">seedname.inp</span></code>, which contains the required
information about the <span class="math">\(\mathbf{k}\)</span>-point mesh, the electron density,
the correlated shell structure, … (see below).</li>
</ol>
<p>Here and in the following, the keyword <code class="docutils literal"><span class="pre">seedname</span></code> should always be intended
as a placeholder for the actual prefix chosen by the user when creating the
input for <strong class="program">wannier90</strong>.
Once these two files are available, one can use the converter as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">triqs_dft_tools.converters</span> <span class="k">import</span> <span class="n">Wannier90Converter</span>
<span class="n">Converter</span> <span class="o">=</span> <span class="n">Wannier90Converter</span><span class="p">(</span><span class="n">seedname</span><span class="o">=</span><span class="s1">&#39;seedname&#39;</span><span class="p">)</span>
<span class="n">Converter</span><span class="o">.</span><span class="n">convert_dft_input</span><span class="p">()</span>
</pre></div>
</div>
<p>The converter input <code class="file docutils literal"><span class="pre">seedname.inp</span></code> is a simple text file with
the following format (do not use the text/comments in your input file):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span> <span class="mi">0</span>  <span class="mi">6</span> <span class="mi">4</span> <span class="mi">6</span>               <span class="c1"># specification of the k-mesh</span>
<span class="mf">8.0</span>                     <span class="c1"># electron density</span>
 <span class="mi">4</span>                      <span class="c1"># number of atoms</span>
 <span class="mi">0</span>  <span class="mi">0</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">0</span>  <span class="mi">0</span>       <span class="c1"># atom, sort, l, dim, SO, irep</span>
 <span class="mi">1</span>  <span class="mi">0</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">0</span>  <span class="mi">0</span>       <span class="c1"># atom, sort, l, dim, SO, irep</span>
 <span class="mi">2</span>  <span class="mi">0</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">0</span>  <span class="mi">0</span>       <span class="c1"># atom, sort, l, dim, SO, irep</span>
 <span class="mi">3</span>  <span class="mi">0</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">0</span>  <span class="mi">0</span>       <span class="c1"># atom, sort, l, dim, SO, irep</span>
</pre></div>
</div>
<p>The example shows the input for the perovskite crystal of LaVO<sub>3</sub>
in the room-temperature <cite>Pnma</cite> symmetry. The unit cell contains four
symmetry-equivalent correlated sites (the V atoms) and the total number
of electrons per unit cell is 8 (see second line).
The first line specifies how to generate the <span class="math">\(\mathbf{k}\)</span>-point
mesh that will be used to obtain <span class="math">\(H(\mathbf{k})\)</span>
by Fourier transforming <span class="math">\(H(\mathbf{R})\)</span>.
Currently implemented options are:</p>
<ul class="simple">
<li><span class="math">\(\Gamma\)</span>-centered uniform grid with dimensions
<span class="math">\(n_{k_x} \times n_{k_y} \times n_{k_z}\)</span>;
specify <code class="docutils literal"><span class="pre">0</span></code> followed by the three grid dimensions,
like in the example above</li>
<li><span class="math">\(\Gamma\)</span>-centered uniform grid with dimensions
automatically determined by the converter (from the number of
<span class="math">\(\mathbf{R}\)</span> vectors found in <code class="file docutils literal"><span class="pre">seedname_hr.dat</span></code>);
just specify <code class="docutils literal"><span class="pre">-1</span></code></li>
</ul>
<p>Inside <code class="file docutils literal"><span class="pre">seedname.inp</span></code>, it is crucial to correctly specify the
correlated shell structure, which depends on the contents of the
<strong class="program">wannier90</strong> output <code class="file docutils literal"><span class="pre">seedname_hr.dat</span></code> and on the order
of the MLWFs contained in it. In this example we have four lines for the
four V atoms. The MLWFs were constructed for the t<sub>2g</sub> subspace, and thus
we set <code class="docutils literal"><span class="pre">l</span></code> to 2 and <code class="docutils literal"><span class="pre">dim</span></code> to 3 for all V atoms. Further the spin-orbit coupling (<code class="docutils literal"><span class="pre">SO</span></code>)
is set to 0 and <code class="docutils literal"><span class="pre">irep</span></code> to 0.
As in this example all 4 V atoms are equivalent we set <code class="docutils literal"><span class="pre">sort</span></code> to 0. We note
that, e.g., for a magnetic DMFT calculation the correlated atoms can be made
inequivalent at this point by using different values for <code class="docutils literal"><span class="pre">sort</span></code>.</p>
<p>The number of MLWFs must be equal to, or greater than the total number
of correlated orbitals (i.e., the sum of all <code class="docutils literal"><span class="pre">dim</span></code> in <code class="file docutils literal"><span class="pre">seedname.inp</span></code>).
If the converter finds fewer MLWFs inside <code class="file docutils literal"><span class="pre">seedname_hr.dat</span></code>, then it
stops with an error; if it finds more MLWFs, then it assumes that the
additional MLWFs correspond to uncorrelated orbitals (e.g., the O-<cite>2p</cite> shells).
When reading the hoppings <span class="math">\(\langle w_i | H(\mathbf{R}) | w_j \rangle\)</span>
(where <span class="math">\(w_i\)</span> is the <span class="math">\(i\)</span>-th MLWF), the converter also assumes that
the first indices correspond to the correlated shells (in our example,
the V-t<sub>2g</sub> shells). Therefore, the MLWFs corresponding to the
uncorrelated shells (if present) must be listed <strong>after</strong> those of the
correlated shells.
With the <strong class="program">wannier90</strong> code, this can be achieved by listing the
projections for the uncorrelated shells after those for the correlated shells.
In our <cite>Pnma</cite>-LaVO<sub>3</sub> example, for instance, we could use:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Begin</span> <span class="n">Projections</span>
 <span class="n">V</span><span class="p">:</span><span class="n">l</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">mr</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">:</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">x</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
 <span class="n">O</span><span class="p">:</span><span class="n">l</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">mr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="n">x</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span>
<span class="n">End</span> <span class="n">Projections</span>
</pre></div>
</div>
<p>where the <code class="docutils literal"><span class="pre">x=-1,1,0</span></code> option indicates that the V–O bonds in the octahedra are
rotated by (approximatively) 45 degrees with respect to the axes of the <cite>Pbnm</cite> cell.</p>
<p>The converter will analyse the matrix elements of the local Hamiltonian
to find the symmetry matrices <cite>rot_mat</cite> needed for the global-to-local
transformation of the basis set for correlated orbitals
(see section <a class="reference internal" href="../reference/h5structure.html#hdfstructure"><span class="std std-ref">hdf5 structure</span></a>).
The matrices are obtained by finding the unitary transformations that diagonalize
<span class="math">\(\langle w_i | H_I(\mathbf{R}=0,0,0) | w_j \rangle\)</span>, where <span class="math">\(I\)</span> runs
over the correlated shells and <cite>i,j</cite> belong to the same shell (more details elsewhere…).
If two correlated shells are defined as equivalent in <code class="file docutils literal"><span class="pre">seedname.inp</span></code>,
then the corresponding eigenvalues have to match within a threshold of 10<sup>-5</sup>,
otherwise the converter will produce an error/warning.
If this happens, please carefully check your data in <code class="file docutils literal"><span class="pre">seedname_hr.dat</span></code>.
This method might fail in non-trivial cases (i.e., more than one correlated
shell is present) when there are some degenerate eigenvalues:
so far tests have not shown any issue, but one must be careful in those cases
(the converter will print a warning message).</p>
<p>The current implementation of the Wannier90 Converter has some limitations:</p>
<ul class="simple">
<li>Since <strong class="program">wannier90</strong> does not make use of symmetries (symmetry-reduction
of the <span class="math">\(\mathbf{k}\)</span>-point grid is not possible), the converter always
sets <code class="docutils literal"><span class="pre">symm_op=0</span></code> (see the <a class="reference internal" href="../reference/h5structure.html#hdfstructure"><span class="std std-ref">hdf5 structure</span></a> section).</li>
<li>No charge self-consistency possible at the moment.</li>
<li>Calculations with spin-orbit (<code class="docutils literal"><span class="pre">SO=1</span></code>) are not supported.</li>
<li>The spin-polarized case (<code class="docutils literal"><span class="pre">SP=1</span></code>) is not yet tested.</li>
<li>The post-processing routines in the module
<code class="xref py py-class docutils literal"><span class="pre">SumkDFTTools</span></code>
were not tested with this converter.</li>
<li><code class="docutils literal"><span class="pre">proj_mat_all</span></code> are not used, so there are no projectors onto the
uncorrelated orbitals for now.</li>
</ul>
</div>
<div class="section" id="mpi-issues">
<h2>MPI issues<a class="headerlink" href="#mpi-issues" title="Permalink to this headline">¶</a></h2>
<p>The interface packages are written such that all the file operations
are done only on the master node. In general, the philosophy of the
package is that whenever you read in something from the archive
yourself, you have to <em>manually</em> broadcast it to the nodes. An
exception to this rule is when you use routines from <code class="xref py py-class docutils literal"><span class="pre">SumkDFT</span></code>
or <code class="xref py py-class docutils literal"><span class="pre">SumkDFTTools</span></code>, where the broadcasting is done for you.</p>
</div>
<div class="section" id="interfaces-to-other-packages">
<h2>Interfaces to other packages<a class="headerlink" href="#interfaces-to-other-packages" title="Permalink to this headline">¶</a></h2>
<p>Because of the modular structure, it is straight forward to extend the <a class="reference external" href="https://triqs.github.io/triqs/master/index.html#welcome" title="(in TRIQS v2.0.168)"><span class="xref std std-ref">TRIQS</span></a> package
in order to work with other band-structure codes. The only necessary requirement is that
the interface module produces an hdf5 archive, that stores all the data in the specified
form. For the details of what data is stored in detail, see the
<a class="reference internal" href="../reference/h5structure.html#hdfstructure"><span class="std std-ref">hdf5 structure</span></a> part of the reference manual.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="dftdmft_singleshot.html" title="Single-shot DFT+DMFT"
             >next</a> |</li>
        <li class="right" >
          <a href="../basicnotions/structure.html" title="Structure of DFTTools"
             >previous</a> |</li>
    <li><a href="../index.html">Home</a> &raquo;</li>

          <li class="nav-item nav-item-1"><a href="../documentation.html" >Documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2011-2013, M. Aichhorn, L. Pourovskii, V. Vildosola, C. Martins.
    </div>
  </body>
</html>